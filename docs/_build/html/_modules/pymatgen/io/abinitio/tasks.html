
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pymatgen.io.abinitio.tasks &mdash; pymatgen 2.8.8 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/proBlue.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '2.8.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="top" title="pymatgen 2.8.8 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">pymatgen 2.8.8 documentation</a> &raquo;</li>
          <li><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for pymatgen.io.abinitio.tasks</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes defining Abinit calculations and workflows</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pymatgen.io.abinitio</span> <span class="kn">import</span> <span class="n">abiinspect</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.abinitio</span> <span class="kn">import</span> <span class="n">events</span> 

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pydispatch</span> <span class="kn">import</span> <span class="n">dispatcher</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="kn">from</span> <span class="nn">pymatgen.core.design_patterns</span> <span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">AttrDict</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.io_utils</span> <span class="kn">import</span> <span class="n">FileLock</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.string_utils</span> <span class="kn">import</span> <span class="n">stream_has_colours</span><span class="p">,</span> <span class="n">is_string</span><span class="p">,</span> <span class="n">list_strings</span><span class="p">,</span> <span class="n">WildCard</span>
<span class="kn">from</span> <span class="nn">pymatgen.serializers.json_coders</span> <span class="kn">import</span> <span class="n">MSONable</span><span class="p">,</span> <span class="n">json_load</span><span class="p">,</span> <span class="n">json_pretty_dump</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.abinitio.utils</span> <span class="kn">import</span> <span class="n">File</span><span class="p">,</span> <span class="n">Directory</span><span class="p">,</span> <span class="n">irdvars_for_ext</span><span class="p">,</span> <span class="n">abi_splitext</span><span class="p">,</span> <span class="n">abi_extensions</span><span class="p">,</span> <span class="n">FilepathFixer</span><span class="p">,</span> <span class="n">Condition</span>

<span class="kn">from</span> <span class="nn">pymatgen.io.abinitio.qadapters</span> <span class="kn">import</span> <span class="n">qadapter_class</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.abinitio.netcdf</span> <span class="kn">import</span> <span class="n">ETSF_Reader</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.abinitio.strategies</span> <span class="kn">import</span> <span class="n">StrategyWithInput</span><span class="p">,</span> <span class="n">OpticInput</span><span class="p">,</span> <span class="n">AnaddbInput</span><span class="p">,</span> <span class="n">order_pseudos</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s">&quot;Matteo Giantomassi&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s">&quot;Copyright 2013, The Materials Project&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s">&quot;0.1&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s">&quot;Matteo Giantomassi&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&quot;TaskManager&quot;</span><span class="p">,</span>
    <span class="s">&quot;ScfTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;NscfTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;RelaxTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;DDK_Task&quot;</span><span class="p">,</span>
    <span class="s">&quot;PhononTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;G_Task&quot;</span><span class="p">,</span>
    <span class="s">&quot;HaydockBseTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;OpticTask&quot;</span><span class="p">,</span>
    <span class="s">&quot;AnaddbTask&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">class</span> <span class="nc">TaskResults</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">MSONable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary used to store the most important results produced by a Task.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_MANDATORY_KEYS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&quot;task_name&quot;</span><span class="p">,</span>
        <span class="s">&quot;task_returncode&quot;</span><span class="p">,</span>
        <span class="s">&quot;task_status&quot;</span><span class="p">,</span>
        <span class="c">#&quot;task_events&quot;,</span>
    <span class="p">]</span>

    <span class="n">EXC_KEY</span> <span class="o">=</span> <span class="s">&quot;_exceptions&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TaskResults</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                                               
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">EXC_KEY</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">EXC_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exceptions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">EXC_KEY</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">push_exceptions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exceptions</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">exc</span> <span class="ow">in</span> <span class="n">exceptions</span><span class="p">:</span>
            <span class="n">newstr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newstr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exceptions</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">EXC_KEY</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">newstr</span><span class="p">,]</span>

    <span class="k">def</span> <span class="nf">assert_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an empty list if results seem valid. </span>

<span class="sd">        The try assert except trick allows one to get a string with info on the exception.</span>
<span class="sd">        We use the += operator so that sub-classes can add their own message.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO Better treatment of events.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s">&quot;task_returncode&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="s">&quot;task_status&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">push_exceptions</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exceptions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">d</span><span class="p">[</span><span class="s">&quot;@module&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__module__</span>
        <span class="n">d</span><span class="p">[</span><span class="s">&quot;@class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="k">return</span> <span class="n">d</span>
                                                                                
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;@module&quot;</span><span class="p">,</span> <span class="s">&quot;@class&quot;</span><span class="p">,]})</span>

    <span class="k">def</span> <span class="nf">json_dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="n">json_pretty_dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span> 

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">json_load</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">json_load</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>    


<span class="k">class</span> <span class="nc">ParalHintsError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class for `ParalHints`.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ParalConf</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object store the parameters associated to one </span>
<span class="sd">    of the possible parallel configurations reported by ABINIT.</span>
<span class="sd">    Essentially it is a dictionary whose values can also be accessed </span>
<span class="sd">    as attributes. It also provides default values for selected keys</span>
<span class="sd">    that might not be present in the ABINIT dictionary.</span>

<span class="sd">    Example:</span>

<span class="sd">        --- !Autoparal</span>
<span class="sd">        info: </span>
<span class="sd">            version: 1</span>
<span class="sd">            autoparal: 1</span>
<span class="sd">            max_ncpus: 108</span>

<span class="sd">        configurations:</span>
<span class="sd">            -   tot_ncpus: 2         # Total number of CPUs</span>
<span class="sd">                mpi_ncpus: 2         # Number of MPI processes.</span>
<span class="sd">                omp_ncpus: 1         # Number of OMP threads (1 if not present)</span>
<span class="sd">                mem_per_cpus: 10     # Estimated memory requirement per MPI processor in Gigabytes (None if not specified)</span>
<span class="sd">                efficiency: 0.4      # 1.0 corresponds to an &quot;expected&quot; optimal efficiency (strong scaling).</span>
<span class="sd">                vars: {              # Dictionary with the variables that should be added to the input.</span>
<span class="sd">                      varname1: varvalue1</span>
<span class="sd">                      varname2: varvalue2</span>
<span class="sd">                      }</span>
<span class="sd">            -</span>
<span class="sd">        ...</span>

<span class="sd">    For paral_kgb we have:</span>
<span class="sd">    nproc     npkpt  npspinor    npband     npfft    bandpp    weight   </span>
<span class="sd">       108       1         1        12         9         2        0.25</span>
<span class="sd">       108       1         1       108         1         2       27.00</span>
<span class="sd">        96       1         1        24         4         1        1.50</span>
<span class="sd">        84       1         1        12         7         2        0.25</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_DEFAULTS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&quot;omp_ncpus&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>     
        <span class="s">&quot;mem_per_cpu&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> 
        <span class="s">&quot;vars&quot;</span><span class="p">:</span> <span class="p">{}</span>       
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParalConf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="c"># Add default values if not already in self.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DEFAULTS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">speedup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimated speedup reported by ABINIT.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">efficiency</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tot_ncpus</span>


<span class="k">class</span> <span class="nc">ParalHintsParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">Error</span> <span class="o">=</span> <span class="n">ParalHintsError</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the AutoParal section (YAML forma) from filename.</span>
<span class="sd">        Assumes the file contains only one section.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">YamlTokenizer</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">next_doc_with_tag</span><span class="p">(</span><span class="s">&quot;!Autoparal&quot;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">text_notag</span><span class="p">)</span>
                <span class="c">#print(d)</span>
                <span class="k">return</span> <span class="n">ParalHints</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s">&quot;info&quot;</span><span class="p">],</span> <span class="n">confs</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s">&quot;configurations&quot;</span><span class="p">])</span>

            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;Wrong YAML doc:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">doc</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ParalHints</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterable with the hints for the parallel execution reported by ABINIT.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">ParalHintsError</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">confs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ParalConf</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">confs</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">__len__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span> <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select_with_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">):</span>
        <span class="n">new_confs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">condition</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="n">conf</span><span class="p">):</span>
                <span class="n">new_confs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span> <span class="o">=</span> <span class="n">new_confs</span>

    <span class="k">def</span> <span class="nf">sort_by_efficiency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the configurations in place so that conf with lowest efficieny </span>
<span class="sd">        appears in the first positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">efficiency</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sort_by_speedup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the configurations in place so that conf with lowest speedup </span>
<span class="sd">        appears in the first positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">speedup</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

    <span class="c">#def sort_by_mem_cpu(self, reverse=False):</span>
    <span class="c">#    self._confs.sort(key=lambda c: c.mem_per_cpus, reverse=reverse)</span>

    <span class="k">def</span> <span class="nf">select_optimal_conf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the optimal configuration according on policy.&quot;&quot;&quot;</span>
        <span class="c"># Make a copy since we are gonna change the object in place.</span>
        <span class="n">hints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c"># First select the configurations satisfying the </span>
        <span class="c"># condition specified by the user (if any)</span>
        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">condition</span><span class="p">:</span>
            <span class="n">hints</span><span class="o">.</span><span class="n">select_with_condition</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
            <span class="c">#if not hints: hints = self.copy()</span>
            <span class="c">#print(&quot;after condition&quot;, hints)</span>

        <span class="n">hints</span><span class="o">.</span><span class="n">sort_by_speedup</span><span class="p">()</span>

        <span class="c"># If no configuration fullfills the requirements, </span>
        <span class="c"># we return the one with the highest speedup.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hints</span><span class="p">:</span>
            <span class="n">hints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">hints</span><span class="o">.</span><span class="n">sort_by_speedup</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">hints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c"># Find the optimal configuration according to policy.mode.</span>
        <span class="c">#mode = policy.mode</span>
        <span class="c">#if mode in [&quot;default&quot;, &quot;aggressive&quot;]:</span>
        <span class="c">#    hints.sort_by_spedup(reverse=True)</span>
        <span class="c">#elif mode == &quot;conservative&quot;:</span>
        <span class="c">#    hints.sort_by_efficiency(reverse=True)</span>
        <span class="c">#else:</span>
        <span class="c">#    raise ValueError(&quot;Wrong value for mode: %s&quot; % str(mode))</span>

        <span class="c"># Return a copy of the configuration.</span>
        <span class="n">optimal</span> <span class="o">=</span> <span class="n">hints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Will relaunch the job with optimized parameters:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">optimal</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">optimal</span>


<span class="k">class</span> <span class="nc">TaskPolicy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores the parameters used by the `TaskManager` to </span>
<span class="sd">    create the submission script and/or to modify the ABINIT variables </span>
<span class="sd">    governing the parallel execution. A `TaskPolicy` object contains </span>
<span class="sd">    a set of variables that specify the launcher, as well as the options</span>
<span class="sd">    and the condition used to select the optimal configuration for the parallel run </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">autoparal</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;default&quot;</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">use_fw</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> 
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            autoparal: </span>
<span class="sd">                Value of ABINIT autoparal input variable. None to disable the autoparal feature.</span>
<span class="sd">            mode:</span>
<span class="sd">                Select the algorith to select the optimal configuration for the parallel execution.</span>
<span class="sd">                Possible values: [&quot;default&quot;, &quot;aggressive&quot;, &quot;conservative&quot;]</span>
<span class="sd">            max_ncpus:</span>
<span class="sd">                Max number of CPUs that can be used (must be specified if autoparal &gt; 0).</span>
<span class="sd">            use_fw: </span>
<span class="sd">                True if we are using fireworks.</span>
<span class="sd">            condition: </span>
<span class="sd">                condition used to filter the autoparal configuration (Mongodb syntax)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">=</span> <span class="n">autoparal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">max_ncpus</span> <span class="o">=</span> <span class="n">max_ncpus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_fw</span> <span class="o">=</span> <span class="n">use_fw</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">condition</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoparal</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_ncpus</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;When autoparal is not zero, max_ncpus must be specified.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">&quot;:&quot;</span><span class="p">]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">app</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<div class="viewcode-block" id="TaskManager"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager">[docs]</a><span class="k">class</span> <span class="nc">TaskManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A `TaskManager` is responsible for the generation of the job script and the submission </span>
<span class="sd">    of the task, as well as of the specification of the parameters passed to the resource manager</span>
<span class="sd">    (e.g. Slurm, PBS ...) and/or the run-time specification of the ABINIT variables governing the </span>
<span class="sd">    parallel execution. A `TaskManager` delegates the generation of the submission</span>
<span class="sd">    script and the submission of the task to the `QueueAdapter`. </span>
<span class="sd">    A `TaskManager` has a `TaskPolicy` that governs the specification of the </span>
<span class="sd">    parameters for the parallel executions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">YAML_FILE</span> <span class="o">=</span> <span class="s">&quot;taskmanager.yml&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qtype</span><span class="p">,</span> <span class="n">qparams</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">setup</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">shell_env</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">omp_env</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
                 <span class="n">pre_run</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">post_run</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mpi_runner</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="n">qad_class</span> <span class="o">=</span> <span class="n">qadapter_class</span><span class="p">(</span><span class="n">qtype</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span> <span class="o">=</span> <span class="n">qad_class</span><span class="p">(</span><span class="n">qparams</span><span class="o">=</span><span class="n">qparams</span><span class="p">,</span> <span class="n">setup</span><span class="o">=</span><span class="n">setup</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="n">modules</span><span class="p">,</span> <span class="n">shell_env</span><span class="o">=</span><span class="n">shell_env</span><span class="p">,</span> <span class="n">omp_env</span><span class="o">=</span><span class="n">omp_env</span><span class="p">,</span> 
                                  <span class="n">pre_run</span><span class="o">=</span><span class="n">pre_run</span><span class="p">,</span> <span class="n">post_run</span><span class="o">=</span><span class="n">post_run</span><span class="p">,</span> <span class="n">mpi_runner</span><span class="o">=</span><span class="n">mpi_runner</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">policy</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Use default policy.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">TaskPolicy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">TaskPolicy</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">policy</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Assume dict-like object.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">TaskPolicy</span><span class="p">(</span><span class="o">**</span><span class="n">policy</span><span class="p">)</span> 

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="n">app</span><span class="p">(</span><span class="s">&quot;tot_ncpus </span><span class="si">%d</span><span class="s">, mpi_ncpus </span><span class="si">%d</span><span class="s">, omp_ncpus </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tot_ncpus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_ncpus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_ncpus</span><span class="p">))</span>
        <span class="n">app</span><span class="p">(</span><span class="s">&quot;MPI_RUNNER </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">mpi_runner</span><span class="p">))</span>
        <span class="n">app</span><span class="p">(</span><span class="s">&quot;policy: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">policy</span><span class="p">))</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.from_dict"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.from_dict">[docs]</a>    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.from_file"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.from_file">[docs]</a>    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the configuration parameters from a Yaml file.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="TaskManager.from_user_config"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.from_user_config">[docs]</a>    <span class="k">def</span> <span class="nf">from_user_config</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the `TaskManager` from the YAML file &#39;taskmanager.yaml&#39;.</span>
<span class="sd">        Search first in the workind directory and then in the configuration</span>
<span class="sd">        directory of abipy.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError if file is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Try in the current directory.</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">cls</span><span class="o">.</span><span class="n">YAML_FILE</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="c"># Try in the configuration directory.</span>
        <span class="n">home</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;HOME&quot;</span><span class="p">)</span>
        <span class="n">dirpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">home</span><span class="p">,</span> <span class="s">&quot;.abinit&quot;</span><span class="p">,</span> <span class="s">&quot;abipy&quot;</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">YAML_FILE</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot locate </span><span class="si">%s</span><span class="s"> neither in current directory nor in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">YAML_FILE</span><span class="p">,</span> <span class="n">dirpath</span><span class="p">))</span>
</div>
    <span class="nd">@classmethod</span> 
<div class="viewcode-block" id="TaskManager.sequential"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.sequential">[docs]</a>    <span class="k">def</span> <span class="nf">sequential</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a simple `TaskManager` that submits jobs via a simple shell script.</span>
<span class="sd">        Assume the shell environment has been already initialized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">qtype</span><span class="o">=</span><span class="s">&quot;shell&quot;</span><span class="p">)</span>
</div>
    <span class="nd">@classmethod</span> 
<div class="viewcode-block" id="TaskManager.simple_mpi"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.simple_mpi">[docs]</a>    <span class="k">def</span> <span class="nf">simple_mpi</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">mpi_runner</span><span class="o">=</span><span class="s">&quot;mpirun&quot;</span><span class="p">,</span> <span class="n">mpi_ncpus</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a `TaskManager` that submits jobs with a simple shell script and mpirun.</span>
<span class="sd">        Assume the shell environment is already properly initialized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">qtype</span><span class="o">=</span><span class="s">&quot;shell&quot;</span><span class="p">,</span> <span class="n">qparams</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">MPI_NCPUS</span><span class="o">=</span><span class="n">mpi_ncpus</span><span class="p">),</span> <span class="n">mpi_runner</span><span class="o">=</span><span class="n">mpi_runner</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">policy</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="TaskManager.tot_ncpus"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.tot_ncpus">[docs]</a>    <span class="k">def</span> <span class="nf">tot_ncpus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of CPUs used to run the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">tot_ncpus</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="TaskManager.mpi_ncpus"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.mpi_ncpus">[docs]</a>    <span class="k">def</span> <span class="nf">mpi_ncpus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of CPUs used for MPI.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">mpi_ncpus</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="TaskManager.omp_ncpus"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.omp_ncpus">[docs]</a>    <span class="k">def</span> <span class="nf">omp_ncpus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of CPUs used for OpenMP.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">omp_ncpus</span>
</div>
<div class="viewcode-block" id="TaskManager.to_shell_manager"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.to_shell_manager">[docs]</a>    <span class="k">def</span> <span class="nf">to_shell_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_ncpus</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new `TaskManager` with the same parameters as self but replace the `QueueAdapter` </span>
<span class="sd">        with a `ShellAdapter` with mpi_ncpus so that we can submit the job without passing through the queue.</span>
<span class="sd">        Replace self.policy with a `TaskPolicy` with autoparal==0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>
        <span class="n">qad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>

        <span class="n">policy</span> <span class="o">=</span> <span class="n">TaskPolicy</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">policy</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">policy</span>

        <span class="n">new</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="s">&quot;shell&quot;</span><span class="p">,</span> <span class="n">qparams</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;MPI_NCPUS&quot;</span><span class="p">:</span> <span class="n">mpi_ncpus</span><span class="p">},</span> <span class="n">setup</span><span class="o">=</span><span class="n">qad</span><span class="o">.</span><span class="n">setup</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="n">qad</span><span class="o">.</span><span class="n">modules</span><span class="p">,</span> 
                  <span class="n">shell_env</span><span class="o">=</span><span class="n">qad</span><span class="o">.</span><span class="n">shell_env</span><span class="p">,</span> <span class="n">omp_env</span><span class="o">=</span><span class="n">qad</span><span class="o">.</span><span class="n">omp_env</span><span class="p">,</span> <span class="n">pre_run</span><span class="o">=</span><span class="n">qad</span><span class="o">.</span><span class="n">pre_run</span><span class="p">,</span> 
                  <span class="n">post_run</span><span class="o">=</span><span class="n">qad</span><span class="o">.</span><span class="n">post_run</span><span class="p">,</span> <span class="n">mpi_runner</span><span class="o">=</span><span class="n">qad</span><span class="o">.</span><span class="n">mpi_runner</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">policy</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span>
</div>
<div class="viewcode-block" id="TaskManager.copy"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shallow copy of self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskManager.deepcopy"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy of self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskManager.set_mpi_ncpus"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.set_mpi_ncpus">[docs]</a>    <span class="k">def</span> <span class="nf">set_mpi_ncpus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_ncpus</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of MPI nodes to use.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">set_mpi_ncpus</span><span class="p">(</span><span class="n">mpi_ncpus</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TaskManager.set_omp_ncpus"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.set_omp_ncpus">[docs]</a>    <span class="k">def</span> <span class="nf">set_omp_ncpus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omp_ncpus</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of OpenMp threads to use.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">set_omp_ncpus</span><span class="p">(</span><span class="n">omp_ncpus</span><span class="p">)</span>

    <span class="c"># TODO</span>
    <span class="c">#def set_mem_per_cpu(self, mem_per_cpu):</span>
    <span class="c">#    &quot;&quot;&quot;Set the memory (in gigabytes) per CPU.&quot;&quot;&quot;</span>
    <span class="c">#    self.qadapter.set_mem_per_cpu(mem_per_cpu)</span>
</div>
<div class="viewcode-block" id="TaskManager.autoparal"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.autoparal">[docs]</a>    <span class="k">def</span> <span class="nf">autoparal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find an optimal set of parameters for the execution of the task </span>
<span class="sd">        using the options specified in `TaskPolicy`.</span>
<span class="sd">        This method can change the ABINIT input variables and/or the </span>
<span class="sd">        parameters passed to the `TaskManager` e.g. the number of CPUs for MPI and OpenMp.</span>

<span class="sd">        Returns:</span>
<span class="sd">           confs, optimal </span>
<span class="sd">           where confs is a `ParalHints` object with the configuration reported by </span>
<span class="sd">           autoparal and optimal is the optimal configuration selected.</span>
<span class="sd">           Returns (None, None) if some problem occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">policy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">policy</span>

        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">policy</span><span class="o">.</span><span class="n">max_ncpus</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span> 
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Nothing to do in autoparal, returning (None, None)&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

        <span class="k">assert</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="c"># 1) Run ABINIT in sequential to get the possible configurations with max_ncpus</span>

        <span class="c"># Set the variables for automatic parallelization</span>
        <span class="n">autoparal_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">autoparal</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span><span class="p">,</span>
            <span class="n">max_ncpus</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">max_ncpus</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">task</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">autoparal_vars</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

        <span class="c"># Build a simple manager to run the job in a shell subprocess on the frontend</span>
        <span class="c"># we don&#39;t want to make a request to the queue manager for this simple job!</span>
        <span class="n">seq_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_shell_manager</span><span class="p">(</span><span class="n">mpi_ncpus</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c"># Return code is always != 0 </span>
        <span class="n">process</span> <span class="o">=</span> <span class="n">seq_manager</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
        <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>  

        <span class="c"># Remove the variables added for the automatic parallelization</span>
        <span class="n">task</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">remove_extra_abivars</span><span class="p">(</span><span class="n">autoparal_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c"># 2) Parse the autoparal configurations</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">ParalHintsParser</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">confs</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">parser</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

        <span class="c"># 3) Select the optimal configuration according to policy</span>
        <span class="n">optimal</span> <span class="o">=</span> <span class="n">confs</span><span class="o">.</span><span class="n">select_optimal_conf</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;optimal Autoparal conf:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">optimal</span><span class="p">)</span>

        <span class="c"># 4) Change the input file and/or the submission script</span>
        <span class="n">task</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">optimal</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>
                                                                  
        <span class="c"># Change the number of MPI nodes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_mpi_ncpus</span><span class="p">(</span><span class="n">optimal</span><span class="o">.</span><span class="n">mpi_ncpus</span><span class="p">)</span>

        <span class="c"># Change the number of OpenMP threads.</span>
        <span class="c">#if optimal.omp_ncpus &gt; 1:</span>
        <span class="c">#    self.set_omp_ncpus(optimal.omp_ncpus)</span>
        <span class="c">#else:</span>
        <span class="c">#    self.qadapter.disable_omp()</span>

        <span class="c"># Change the memory per node.</span>
        <span class="c">#if optimal.mem_per_cpu is not None</span>
        <span class="c">#    self.qadapter.set_mem_per_cpu(optimal.mem_per_cpu)</span>

        <span class="c"># Reset the status, remove garbage files ...</span>
        <span class="n">task</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">S_READY</span><span class="p">)</span>

        <span class="c"># Remove the output file since Abinit likes to create new files </span>
        <span class="c"># with extension .outA, .outB if the file already exists.</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">confs</span><span class="p">,</span> <span class="n">optimal</span>
</div>
<div class="viewcode-block" id="TaskManager.write_jobfile"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.write_jobfile">[docs]</a>    <span class="k">def</span> <span class="nf">write_jobfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the submission script.</span>

<span class="sd">        Args:</span>
<span class="sd">            task:</span>
<span class="sd">                `AbinitTask` object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The path of the script file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Construct the submission script.</span>
        <span class="n">script</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">get_script_str</span><span class="p">(</span>
            <span class="n">job_name</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> 
            <span class="n">launch_dir</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> 
            <span class="n">executable</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span>
            <span class="n">qout_path</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">qerr_path</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">stdin</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">files_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> 
            <span class="n">stdout</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">stderr</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c"># Write the script.</span>
        <span class="n">script_file</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">job_file</span><span class="o">.</span><span class="n">path</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">script_file</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">script_file</span>
</div>
<div class="viewcode-block" id="TaskManager.launch"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.TaskManager.launch">[docs]</a>    <span class="k">def</span> <span class="nf">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the input files and submit the task via the `Qadapter` </span>

<span class="sd">        Args:</span>
<span class="sd">            task:</span>
<span class="sd">                `TaskObject`</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Process object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

        <span class="n">script_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_jobfile</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

        <span class="c"># Submit the task.</span>
        <span class="n">task</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">)</span>

        <span class="c"># FIXME: CD to script file dir?</span>
        <span class="n">process</span><span class="p">,</span> <span class="n">queue_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">submit_to_queue</span><span class="p">(</span><span class="n">script_file</span><span class="p">)</span>

        <span class="c"># Save the queue id.</span>
        <span class="n">task</span><span class="o">.</span><span class="n">set_queue_id</span><span class="p">(</span><span class="n">queue_id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">process</span>


<span class="c"># The code below initializes a counter from a file when the module is imported </span>
<span class="c"># and save the counter&#39;s updated value automatically when the program terminates </span>
<span class="c"># without relying on the application making an explicit call into this module at termination.</span></div></div>
<span class="n">conf_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;HOME&quot;</span><span class="p">),</span> <span class="s">&quot;.abinit&quot;</span><span class="p">,</span> <span class="s">&quot;abipy&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">conf_dir</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">conf_dir</span><span class="p">)</span>

<span class="n">_COUNTER_FILE</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conf_dir</span><span class="p">,</span> <span class="s">&quot;nodecounter&quot;</span><span class="p">)</span>
<span class="k">del</span> <span class="n">conf_dir</span>

<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">_COUNTER_FILE</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
        <span class="n">_COUNTER</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

<span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
    <span class="n">_COUNTER</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">def</span> <span class="nf">get_newnode_id</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a new node identifier used both for `Task` and `Workflow` objects.</span>

<span class="sd">    .. warnings:</span>
<span class="sd">        The id is unique inside the same python process so be careful when </span>
<span class="sd">        Workflows and Task are constructed at run-time or when threads are used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_COUNTER</span>
    <span class="n">_COUNTER</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">_COUNTER</span>


<span class="k">def</span> <span class="nf">save_lastnode_id</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Save the id of the last node created.&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">FileLock</span><span class="p">(</span><span class="n">_COUNTER_FILE</span><span class="p">)</span> <span class="k">as</span> <span class="n">lock</span><span class="p">:</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">_COUNTER_FILE</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">_COUNTER</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">atexit</span>
<span class="n">atexit</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">save_lastnode_id</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FakeProcess</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object is attached to a Task instance if the task has not been submitted</span>
<span class="sd">    This trick allows us to simulate a process that is still running so that </span>
<span class="sd">    we can safely poll task.process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot wait a FakeProcess&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">communicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot communicate with a FakeProcess&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;Cannot kill a FakeProcess&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">returncode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span>


<span class="k">class</span> <span class="nc">Product</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A product represents an output file produced by ABINIT instance.</span>
<span class="sd">    This file is needed to start another `Task` or another `Workflow`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            ext:</span>
<span class="sd">                ABINIT file extension</span>
<span class="sd">            path:</span>
<span class="sd">                (asbolute) filepath</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">abi_extensions</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Extension </span><span class="si">%s</span><span class="s"> has not been registered in the internal database&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;File=</span><span class="si">%s</span><span class="s">, Extension=</span><span class="si">%s</span><span class="s">, &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the file.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">path</span>

    <span class="k">def</span> <span class="nf">connecting_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary with the ABINIT variables that </span>
<span class="sd">        must be used to make the code use this file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ext</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Dependency</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object describes the dependencies among the nodes of a calculation.</span>

<span class="sd">    A `Dependency` consists of a `Node` that produces a list of products (files) </span>
<span class="sd">    that are used by the other nodes (`Task` or `Workflow`) to start the calculation.</span>
<span class="sd">    One usually creates the object by calling work.register </span>

<span class="sd">    Example:</span>

<span class="sd">        # Register the SCF task in work.</span>
<span class="sd">        scf_task = work.register(scf_strategy)</span>

<span class="sd">        # Register the NSCF calculation and its dependency on the SCF run via deps.</span>
<span class="sd">        nscf_task = work.register(nscf_strategy, deps={scf_task: &quot;DEN&quot;})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">exts</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            node:</span>
<span class="sd">                The task or the worfklow associated to the dependency.</span>
<span class="sd">            exts:</span>
<span class="sd">                Extensions of the output files that are needed for running the other tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node</span> <span class="o">=</span> <span class="n">node</span>

        <span class="k">if</span> <span class="n">exts</span> <span class="ow">and</span> <span class="n">is_string</span><span class="p">(</span><span class="n">exts</span><span class="p">):</span>
            <span class="n">exts</span> <span class="o">=</span> <span class="n">exts</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">exts</span> <span class="o">=</span> <span class="n">exts</span> <span class="ow">or</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Node </span><span class="si">%s</span><span class="s"> will produce: </span><span class="si">%s</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Node </span><span class="si">%s</span><span class="s"> will produce: </span><span class="si">%s</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The node associated to the dependency.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The status of the dependency, i.e. the status of the node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">status</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">products</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of output files produces by self.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_products</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_products</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exts</span><span class="p">:</span>
                <span class="n">prod</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">opath_from_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_products</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_products</span>

    <span class="k">def</span> <span class="nf">connecting_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary with the variables that must be added to the </span>
<span class="sd">        input file in order to connect this `Node` to its dependencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">:</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">prod</span><span class="o">.</span><span class="n">connecting_vars</span><span class="p">())</span>

        <span class="k">return</span> <span class="nb">vars</span>

    <span class="k">def</span> <span class="nf">get_filepaths_and_exts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the paths of the output files produced by self and its extensions&quot;&quot;&quot;</span>
        <span class="n">filepaths</span> <span class="o">=</span> <span class="p">[</span><span class="n">prod</span><span class="o">.</span><span class="n">filepath</span> <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">]</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="p">[</span><span class="n">prod</span><span class="o">.</span><span class="n">ext</span> <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">products</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">filepaths</span><span class="p">,</span> <span class="n">exts</span>


<span class="c"># Possible status of the node.</span>
<span class="n">STATUS2STR</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">([</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Initialized&quot;</span><span class="p">),</span>   <span class="c"># Node has been initialized</span>
    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Locked&quot;</span><span class="p">),</span>        <span class="c"># Task is locked an must be explicitly unlocked by en external subject (Workflow).</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Ready&quot;</span><span class="p">),</span>         <span class="c"># Node is ready i.e. all the depencies of the node have status S_OK</span>
    <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Submitted&quot;</span><span class="p">),</span>     <span class="c"># Node has been submitted (The `Task` is running or we have started to finalize the Workflow)</span>
    <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;Running&quot;</span><span class="p">),</span>       <span class="c"># Node is running.</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s">&quot;Done&quot;</span><span class="p">),</span>          <span class="c"># Node done, This does not imply that results are ok or that the calculation completed successfully</span>
    <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s">&quot;Error&quot;</span><span class="p">),</span>         <span class="c"># Node raised some kind of Error (the submission process, the queue manager or ABINIT ...).</span>
    <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="s">&quot;Unconverged&quot;</span><span class="p">),</span>   <span class="c"># This usually means that an iterative algorithm didn&#39;t converge.</span>
    <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="s">&quot;Completed&quot;</span><span class="p">),</span>     <span class="c"># Execution completed successfully.</span>
<span class="p">])</span>

<span class="k">class</span> <span class="nc">Status</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">, at </span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">STATUS2STR</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class defining the interface that must be </span>
<span class="sd">    implemented by the nodes of the calculation.</span>

<span class="sd">    Nodes are hashable and can be tested for equality</span>
<span class="sd">    (both operation use the node identifier).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span>

    <span class="c"># Possible status of the node.</span>
    <span class="n">S_INIT</span> <span class="o">=</span> <span class="n">Status</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">S_LOCKED</span> <span class="o">=</span> <span class="n">Status</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">S_READY</span> <span class="o">=</span> <span class="n">Status</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">S_SUB</span> <span class="o">=</span> <span class="n">Status</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">S_RUN</span> <span class="o">=</span> <span class="n">Status</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">S_DONE</span> <span class="o">=</span> <span class="n">Status</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">S_ERROR</span> <span class="o">=</span> <span class="n">Status</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">S_UNCONVERGED</span> <span class="o">=</span> <span class="n">Status</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">S_OK</span> <span class="o">=</span> <span class="n">Status</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Node identifier.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_id</span> <span class="o">=</span> <span class="n">get_newnode_id</span><span class="p">()</span>

        <span class="c"># List of dependencies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># Used to push additional info during the execution. </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

        <span class="c"># Set to true if the node has been finalized.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">node_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__class__</span>
                                                       
    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;&lt;</span><span class="si">%s</span><span class="s">, node_id </span><span class="si">%s</span><span class="s">, workdir=</span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">))</span>

        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># this usually happens when workdir has not been initialized</span>
            <span class="k">return</span> <span class="s">&quot;&lt;</span><span class="si">%s</span><span class="s">, node_id </span><span class="si">%s</span><span class="s">, workdir=None&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">)</span>
                                                                                            
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;&lt;</span><span class="si">%s</span><span class="s">, workdir=</span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># this usually happens when workdir has not been initialized</span>
            <span class="k">return</span> <span class="s">&quot;&lt;</span><span class="si">%s</span><span class="s">, workdir=None&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The name of node </span>
<span class="sd">        (only used for facilitating its identification in the user interface).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the name of the Node.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Node identifier.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_id</span>
                                                         
    <span class="k">def</span> <span class="nf">set_node_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the node identifier. Use it carefully!&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_id</span> <span class="o">=</span> <span class="n">node_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">finalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the `Workflow` has been finalized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span>

    <span class="nd">@finalized.setter</span>
    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boolean</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="n">boolean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Finalized on </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>
                                                         
    <span class="c">#@abc.abstractproperty</span>
    <span class="c">#def workdir(self):</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_subnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if self contains sub-nodes e.g. `Workflow` object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">deps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List of `Dependency` objects defining the dependencies </span>
<span class="sd">        of this `Node`. Empty list if this `Node` does not have dependencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deps</span>

    <span class="k">def</span> <span class="nf">add_deps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a list of dependencies to the `Node`.</span>

<span class="sd">        Args:</span>
<span class="sd">            deps:</span>
<span class="sd">                List of `Dependency` objects specifying the </span>
<span class="sd">                dependencies of the node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># We want a list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deps</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">deps</span> <span class="o">=</span> <span class="p">[</span><span class="n">deps</span><span class="p">]</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Dependency</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">)</span>

        <span class="c"># Add the dependencies to the node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_subnodes</span><span class="p">:</span>
            <span class="c"># This means that the node contains sub-nodes </span>
            <span class="c"># that should inherit the same dependency.</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">add_deps</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_deps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a list of dependencies from the `Node`.</span>

<span class="sd">        Args:</span>
<span class="sd">            deps:</span>
<span class="sd">                List of `Dependency` objects specifying the </span>
<span class="sd">                dependencies of the node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">deps</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">deps</span> <span class="o">=</span> <span class="p">[</span><span class="n">deps</span><span class="p">]</span>
                                                                                      
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Dependency</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_deps</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deps</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">]</span>
                                                                                      
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_subnodes</span><span class="p">:</span>
            <span class="c"># This means that the node consists of sub-nodes </span>
            <span class="c"># that should remove the same list of dependencies.</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">task</span><span class="o">.</span><span class="n">remove_deps</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>                                                                                                                                        

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">deps_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list with the status of the dependencies.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">]</span>
                                                                  
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">status</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">depends_on</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this node depends on the other node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">str_deps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the string representation of the dependecies of the node.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="n">app</span><span class="p">(</span><span class="s">&quot;Dependencies of node </span><span class="si">%s</span><span class="s">:&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dep</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">):</span>
            <span class="n">app</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s">) </span><span class="si">%s</span><span class="s">, status=</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">dep</span><span class="o">.</span><span class="n">node</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">dep</span><span class="o">.</span><span class="n">status</span><span class="p">)))</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="c">#@abc.abstractmethod</span>
    <span class="c">#def set_status(self, status):</span>
    <span class="c">#    &quot;&quot;&quot;Set the status of the `Node`.&quot;&quot;&quot;</span>
    <span class="c">#</span>
    <span class="c">#def status(self):</span>
    <span class="c">#    &quot;&quot;&quot;Return the status of the `Node`.&quot;&quot;&quot;</span>
    <span class="c">#   return self._status</span>

    <span class="c">#@abc.abstractmethod</span>
    <span class="c">#def check_status(self, status):</span>
    <span class="c">#    &quot;&quot;&quot;Check the status of the `Node`.&quot;&quot;&quot;</span>

    <span class="c">#@abc.abstractmethod</span>
    <span class="c">#def connect_signals():</span>
    <span class="c">#    &quot;&quot;&quot;Connect the signals.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">FakeDirectory</span><span class="p">(</span><span class="n">Directory</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="n">Directory</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span> <span class="o">=</span> <span class="n">filepath</span>

    <span class="k">def</span> <span class="nf">has_abiext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Redefine has_abiext so that we only check self.filepath.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">ext</span> <span class="o">+</span> <span class="s">&quot;.nc&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span>
        <span class="k">return</span> <span class="s">&quot;&quot;</span>

<span class="k">class</span> <span class="nc">FileNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A node of the calculation consisting of an already existing file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FileNode</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">):</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s">&quot;File </span><span class="si">%s</span><span class="s"> </span><span class="se">\n</span><span class="s"> must exist when the FileNode is initialized&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">workdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_node_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span>

        <span class="c"># FIXME: Find a better aproach for this</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span> <span class="o">=</span> <span class="n">FakeDirectory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">opath_from_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the path of the output file with extension ext.</span>
<span class="sd">        Use it when the file does not exist yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span>
        <span class="c">#return os.path.join(self.workdir, self.prefix.odata + &quot;_&quot; + ext)</span>


<span class="k">class</span> <span class="nc">TaskError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base Exception for `Task` methods&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">TaskRestartError</span><span class="p">(</span><span class="n">TaskError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception raised while trying to restart the `Task`.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">Task</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span>

    <span class="n">Error</span> <span class="o">=</span> <span class="n">TaskError</span>

    <span class="c"># List of `AbinitEvent` subclasses that are tested in the not_converged method. </span>
    <span class="c"># Subclasses should provide their own list if they need to check the converge status.</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">]</span>

    <span class="c"># Prefixes for Abinit (input, output, temporary) files.</span>
    <span class="n">Prefix</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s">&quot;Prefix&quot;</span><span class="p">,</span> <span class="s">&quot;idata odata tdata&quot;</span><span class="p">)</span>
    <span class="n">pj</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span>

    <span class="n">prefix</span> <span class="o">=</span> <span class="n">Prefix</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="s">&quot;indata&quot;</span><span class="p">,</span> <span class="s">&quot;in&quot;</span><span class="p">),</span> <span class="n">pj</span><span class="p">(</span><span class="s">&quot;outdata&quot;</span><span class="p">,</span> <span class="s">&quot;out&quot;</span><span class="p">),</span> <span class="n">pj</span><span class="p">(</span><span class="s">&quot;tmpdata&quot;</span><span class="p">,</span> <span class="s">&quot;tmp&quot;</span><span class="p">))</span>
    <span class="k">del</span> <span class="n">Prefix</span><span class="p">,</span> <span class="n">pj</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            strategy: </span>
<span class="sd">                Input file or `Strategy` instance defining the calculation.</span>
<span class="sd">            workdir:</span>
<span class="sd">                Path to the working directory.</span>
<span class="sd">            manager:</span>
<span class="sd">                `TaskManager` object.</span>
<span class="sd">            deps:</span>
<span class="sd">                Dictionary specifying the dependency of this node.</span>
<span class="sd">                None means that this obj has no dependency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Init the node</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Task</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="c"># Save the strategy to use to generate the input file.</span>
        <span class="c"># FIXME</span>
        <span class="c">#self.strategy = strategy.deepcopy()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">=</span> <span class="n">strategy</span>
                                                               
        <span class="k">if</span> <span class="n">workdir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_workdir</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>
                                                               
        <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;setting manager&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_manager</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>
        <span class="c">#else:</span>
        <span class="c">#    self.set_manager(TaskManager.sequential())</span>

        <span class="c"># Handle possible dependencies.</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="n">deps</span> <span class="o">=</span> <span class="p">[</span><span class="n">Dependency</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span> <span class="ow">in</span> <span class="n">deps</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_deps</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>

        <span class="c"># Set the initial status.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">)</span>

        <span class="c"># Number of restarts effectuated and max number (-1 --&gt; no limit).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_num_restarts</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return state is pickled as the contents for the instance.</span>
<span class="sd">                                                                                      </span>
<span class="sd">        In this case we just remove the process since Subprocess objects cannot be pickled.</span>
<span class="sd">        This is the reason why we have to store the returncode in self._returncode instead</span>
<span class="sd">        of using self.process.returncode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;_process&quot;</span><span class="p">,]}</span>

    <span class="k">def</span> <span class="nf">set_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the working directory. Cannot be set more than once.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;workdir&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">workdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>

        <span class="c"># Files required for the execution.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.abi&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.abo&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.files&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">job_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;job.sh&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.log&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;run.err&quot;</span><span class="p">))</span>

        <span class="c"># Directories with input|output|temporary data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;indata&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;outdata&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;tmpdata&quot;</span><span class="p">))</span>

        <span class="c"># stderr and output file of the queue manager.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;queue.err&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;queue.out&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the `TaskManager` to use to launch the Task.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The flow containing this `Task`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flow</span>

    <span class="k">def</span> <span class="nf">set_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the flow associated to this `Task`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_flow&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flow</span> <span class="o">=</span> <span class="n">flow</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flow</span> <span class="o">!=</span> <span class="n">flow</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;self._flow != flow&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct and write the input file of the calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">make_input</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">ipath_from_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the path of the input file with extension ext.</span>
<span class="sd">        Use it when the file does not exist yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">idata</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">opath_from_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the path of the output file with extension ext.</span>
<span class="sd">        Use it when the file does not exist yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">odata</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>

    <span class="nd">@abc.abstractproperty</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Path to the executable associated to the task (internally stored in self._executable).</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_executable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">executable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the executable associate to this task.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span> <span class="o">=</span> <span class="n">executable</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c"># Attach a fake process so that we can poll it.</span>
            <span class="k">return</span> <span class="n">FakeProcess</span><span class="p">()</span>

    <span class="c">#@property</span>
    <span class="c">#def is_allocated(self):</span>
    <span class="c">#    &quot;&quot;&quot;</span>
    <span class="c">#    True if the task has been allocated, </span>
    <span class="c">#    i.e. if it has been submitted or if it&#39;s running.</span>
    <span class="c">#    &quot;&quot;&quot;</span>
    <span class="c">#    return self.status in [self.S_SUB, self.S_RUN]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_completed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the task has been executed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">can_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The task can run if its status is &lt; S_SUB and all the other depencies (if any) are done!&quot;&quot;&quot;</span>
        <span class="n">all_ok</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">stat</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span> <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps_status</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span> <span class="ow">and</span> <span class="n">all_ok</span>

    <span class="k">def</span> <span class="nf">not_converged</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the calculation is not converged.&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;not_converged method of the base class will always return False&quot;</span><span class="p">)</span>
        <span class="n">report</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">report</span><span class="o">.</span><span class="n">filter_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CRITICAL_EVENTS</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_on_done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fix_ofiles</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fix_ofiles</span><span class="p">()</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ok</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called once the `Task` has reached status S_OK. </span>
<span class="sd">        Subclasses should provide their own implementation</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary that must contain at least the following entries:</span>
<span class="sd">                returncode:</span>
<span class="sd">                    0 on success. </span>
<span class="sd">                message: </span>
<span class="sd">                    a string that should provide a human-readable description of what has been performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">returncode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
                    <span class="n">message</span><span class="o">=</span><span class="s">&quot;Calling on_all_ok of the base class!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fix_ofiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the task reaches S_OK.</span>
<span class="sd">        It changes the extension of particular output files</span>
<span class="sd">        produced by Abinit so that the &#39;official&#39; extension</span>
<span class="sd">        is preserved e.g. out_1WF14 --&gt; out_1WF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filepaths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;in fix_ofiles with filepaths </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filepaths</span><span class="p">)</span> 

        <span class="n">old2new</span> <span class="o">=</span> <span class="n">FilepathFixer</span><span class="p">()</span><span class="o">.</span><span class="n">fix_paths</span><span class="p">(</span><span class="n">filepaths</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">old2new</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;will rename old </span><span class="si">%s</span><span class="s"> to new </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">))</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by restart once we have finished preparing the task for restarting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&quot;Restarted on </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>

        <span class="c"># Increase the counter and relaunch the task.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Restarted on </span><span class="si">%s</span><span class="s">, num_restarts </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restart the calculation. This method is called if the calculation is not converged </span>
<span class="sd">        and we can restart the task. See restart_if_needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Calling the **empty** restart method of the base class&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">restart_if_needed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback that is executed once the job is done. </span>
<span class="sd">        The implementation of the two methods: </span>

<span class="sd">           - not_converged</span>
<span class="sd">           - restart </span>
<span class="sd">           </span>
<span class="sd">        is delegated to the subclasses.</span>

<span class="sd">        Returns:</span>
<span class="sd">            0 if succes, 1 if restart was not possible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_converged</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_restarts</span><span class="p">:</span>
                <span class="n">info_msg</span> <span class="o">=</span> <span class="s">&quot;Reached maximum number of restarts. Cannot restart anymore Returning&quot;</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info_msg</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info_msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">1</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">restart</span><span class="p">()</span>
    
            <span class="k">except</span> <span class="n">TaskRestartError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">info_msg</span> <span class="o">=</span> <span class="s">&quot;Calculation not converged but restart was not possible!</span><span class="se">\n</span><span class="s">Exception: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">exc</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">info_msg</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="n">info_msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">1</span>
     
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if child process has terminated. Set and return returncode attribute.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wait for child process to terminate. Set and return returncode attribute.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span>

    <span class="k">def</span> <span class="nf">communicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached. </span>
<span class="sd">        Wait for process to terminate. The optional input argument should be a string to be sent to the </span>
<span class="sd">        child process, or None, if no data should be sent to the child.</span>

<span class="sd">        communicate() returns a tuple (stdoutdata, stderrdata).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stdoutdata</span><span class="p">,</span> <span class="n">stderrdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="nb">input</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">returncode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stdoutdata</span><span class="p">,</span> <span class="n">stderrdata</span> 

    <span class="k">def</span> <span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Kill the child.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">returncode</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">returncode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The child return code, set by poll() and wait() (and indirectly by communicate()). </span>
<span class="sd">        A None value indicates that the process hasn&#39;t terminated yet.</span>
<span class="sd">        A negative value -N indicates that the child was terminated by signal N (Unix only).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the task status. Mainly used if we made a silly mistake in the initial</span>
<span class="sd">        setup of the queue manager and we want to fix it and rerun the task.</span>

<span class="sd">        Returns:</span>
<span class="sd">            0 on success, 1 if reset failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Can only reset tasks that are done.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&quot;Reset on </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>

        <span class="c"># TODO send a signal to the flow </span>
        <span class="c">#self.workflow.check_status()</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">queue_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Queue identifier returned by the Queue manager. None if not set&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_queue_id</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">set_queue_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the task identifier.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue_id</span> <span class="o">=</span> <span class="n">queue_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_queue_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are submitting jobs via a queue manager.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s">&quot;shell&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tot_ncpus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of CPUs used to run the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">tot_ncpus</span>
                                                         
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mpi_ncpus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of CPUs used for MPI.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mpi_ncpus</span>
                                                         
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">omp_ncpus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of CPUs used for OpenMP.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">omp_ncpus</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the status of the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status</span>

    <span class="k">def</span> <span class="nf">set_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the status of the task.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">status</span> <span class="ow">in</span> <span class="n">STATUS2STR</span>

        <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;_status&quot;</span><span class="p">):</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="n">status</span>

        <span class="c"># Add new entry to history only if the status has changed.</span>
        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_submission_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Submitted on </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Completed on </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Error info:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">info_msg</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_on_done</span><span class="p">()</span>
                                                                                
        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
            <span class="c">#if status == self.S_UNCONVERGED:</span>
            <span class="c">#    logger.debug(&quot;Task %s broadcasts signal S_UNCONVERGED&quot; % self)</span>
            <span class="c">#    dispatcher.send(signal=self.S_UNCONVERGED, sender=self)</span>
                                                                                
            <span class="c"># Finalize the task.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_on_ok</span><span class="p">()</span>
                                                                                
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Task </span><span class="si">%s</span><span class="s"> broadcasts signal S_OK&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">dispatcher</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">,</span> <span class="n">sender</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">status</span>

    <span class="k">def</span> <span class="nf">check_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function check the status of the task by inspecting the output and the </span>
<span class="sd">        error files produced by the application and by the queue manager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># A locked task can only be unlocked by calling set_status explicitly.</span>
        <span class="n">black_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="n">black_list</span><span class="p">:</span> <span class="k">return</span>

        <span class="c"># Check the returncode of the process first.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="s">&quot;return code </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span><span class="p">)</span>

        <span class="c"># Start to check when the output file has been created.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;output_file does not exists&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
                <span class="c"># The job is still in the queue.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Analyze the standard error of the executable:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
                    <span class="n">err_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">err_msg</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: executable stderr:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">err_msg</span><span class="p">))</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="n">err_msg</span><span class="p">)</span>

                <span class="c"># Analyze the error file of the resource manager.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
                    <span class="n">err_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">err_info</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: queue stderr:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">err_msg</span><span class="p">))</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="n">err_info</span><span class="p">)</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span>

        <span class="c"># Check if the run completed successfully.</span>
        <span class="n">report</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">report</span><span class="o">.</span><span class="n">run_completed</span><span class="p">:</span>
            <span class="c"># Check if the calculation converged.</span>
            <span class="n">not_ok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_converged</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">not_ok</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_UNCONVERGED</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">)</span>

        <span class="c"># This is the delicate part since we have to discern among different possibilities:</span>
        <span class="c">#</span>
        <span class="c"># 1) Calculation stopped due to an Abinit Error or Bug.</span>
        <span class="c">#</span>
        <span class="c"># 2) Segmentation fault that (by definition) was not handled by ABINIT.</span>
        <span class="c">#    In this case we check if the ABINIT standard error is not empty.</span>
        <span class="c">#    hoping that nobody has written to sdterr (e.g. libraries in debug mode)</span>
        <span class="c">#</span>
        <span class="c"># 3) Problem with the resource manager and/or the OS (walltime error, resource error, phase of the moon ...)</span>
        <span class="c">#    In this case we check if the error file of the queue manager is not empty.</span>
        <span class="c">#    Also in this case we *assume* that there&#39;s something wrong if the stderr of the queue manager is not empty</span>
        <span class="c"># </span>
        <span class="c"># 4) Calculation is still running!</span>
        <span class="c">#</span>
        <span class="c"># Point 2) and 3) are the most complicated since there&#39;s no standard!</span>

        <span class="c"># 1) Search for possible errors or bugs in the ABINIT **output** file.</span>
        <span class="k">if</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span> <span class="ow">or</span> <span class="n">report</span><span class="o">.</span><span class="n">bugs</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Found Errors or Bugs in ABINIT main output!&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">report</span><span class="o">.</span><span class="n">bugs</span><span class="p">))</span>

        <span class="c"># 2) Analyze the stderr file for Fortran runtime errors.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">err_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">err_info</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="n">err_info</span><span class="p">)</span>

        <span class="c"># 3) Analyze the error file of the resource manager.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">err_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">err_info</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="n">err_info</span><span class="p">)</span>

        <span class="c"># 4) Assume the job is still running.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_RUN</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">out_to_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move an output file to the output data directory of the `Task` </span>
<span class="sd">        and rename the file so that ABINIT will read it as an input data file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The absolute path of the new file in the indata directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">in_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">out_file</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;out&quot;</span><span class="p">,</span> <span class="s">&quot;in&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">in_file</span><span class="p">)</span>
                                                                           
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">islink</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
           <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Will overwrite </span><span class="si">%s</span><span class="s"> with </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">out_file</span><span class="p">))</span>
                                                                           
        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">inlink_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a symbolic link to the specified file in the </span>
<span class="sd">        directory containing the input files of the task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span> 
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Creating symbolic link to not existent file </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">filepath</span><span class="p">)</span>

        <span class="c"># Extract the Abinit extension and add the prefix for input files.</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">abiext</span> <span class="o">=</span> <span class="n">abi_splitext</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

        <span class="n">infile</span> <span class="o">=</span> <span class="s">&quot;in_&quot;</span> <span class="o">+</span> <span class="n">abiext</span>
        <span class="n">infile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>

        <span class="c"># Link path to dest if dest link does not exist.</span>
        <span class="c"># else check that it points to the expected file.</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Linking path </span><span class="si">%s</span><span class="s"> --&gt; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">infile</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Linking path </span><span class="si">%s</span><span class="s"> --&gt; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">infile</span><span class="p">))</span>
                                                             
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">infile</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">infile</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span> <span class="o">!=</span> <span class="n">filepath</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;infile </span><span class="si">%s</span><span class="s"> does not point to filepath </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">filepath</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create symbolic links to the output files produced by the other tasks.</span>

<span class="sd">        ..warning:</span>
<span class="sd">            </span>
<span class="sd">            This method should be called only when the calculation is READY because</span>
<span class="sd">            it uses a heuristic approach to find the file to link.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="n">filepaths</span><span class="p">,</span> <span class="n">exts</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">get_filepaths_and_exts</span><span class="p">()</span>
            <span class="c">#print(filepaths, exts)</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">filepaths</span><span class="p">,</span> <span class="n">exts</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;need path </span><span class="si">%s</span><span class="s"> with ext </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ext</span><span class="p">))</span>
                <span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipath_from_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span> 
                    <span class="c"># Try netcdf file.</span>
                    <span class="c"># TODO: this case should be treated in a cleaner way.</span>
                    <span class="n">path</span> <span class="o">+=</span> <span class="s">&quot;-etsf.nc&quot;</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                        <span class="n">dest</span> <span class="o">+=</span> <span class="s">&quot;-etsf.nc&quot;</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                    <span class="n">err_msg</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s"> is needed by this task but it does not exist&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

                <span class="c"># Link path to dest if dest link does not exist.</span>
                <span class="c"># else check that it points to the expected file.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Linking path </span><span class="si">%s</span><span class="s"> --&gt; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dest</span><span class="p">))</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">!=</span> <span class="n">path</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;dest </span><span class="si">%s</span><span class="s"> does not point to path </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>

    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public method called before submitting the task.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method calls self.setup after having performed additional operations</span>
<span class="sd">        such as the creation of the symbolic links needed to connect different tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_links</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>

    <span class="c"># TODO: For the time being, we inspect the log file,</span>
    <span class="c"># We will start to use the output file when the migration to YAML is completed</span>
    <span class="k">def</span> <span class="nf">get_event_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s">&quot;log&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyzes the main output file for possible Errors or Warnings.</span>

<span class="sd">        Args:</span>
<span class="sd">            source:</span>
<span class="sd">                &quot;output&quot; for the main output file.</span>
<span class="sd">                &quot;log&quot; for the log file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `EventReport` instance or None if the main output file does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">file</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&quot;output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">,</span>
            <span class="s">&quot;log&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="p">,</span>
        <span class="p">}[</span><span class="n">source</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">parser</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">EventsParser</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">parser</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c"># Return a report with an error entry with info on the exception.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Exception while parsing ABINIT events:</span><span class="se">\n</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">info_msg</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">report_exception</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The results produced by the task. Set by get_results&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span>

        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_results</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> 

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method called once the calculation is completed, </span>
<span class="sd">        Updates self._results and returns TaskResults instance.</span>
<span class="sd">        Subclasses should extend this method (if needed) by adding </span>
<span class="sd">        specialized code that performs some kind of post-processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check whether the process completed.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;return code is None, you should call wait, communitate or poll&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;Task is not completed&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">TaskResults</span><span class="p">({</span>
            <span class="s">&quot;task_name&quot;</span>      <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s">&quot;task_returncode&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span><span class="p">,</span>
            <span class="s">&quot;task_status&quot;</span>    <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">,</span>
            <span class="c">#&quot;task_events&quot;    : self.events.to_dict</span>
        <span class="p">})</span>

    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">is_abspath</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively move self.workdir to another location. This is similar to the Unix &quot;mv&quot; command.</span>
<span class="sd">        The destination path must not already exist. If the destination already exists</span>
<span class="sd">        but is not a directory, it may be overwritten depending on os.rename() semantics.</span>

<span class="sd">        Be default, dest is located in the parent directory of self.workdir.</span>
<span class="sd">        Use is_abspath=True to specify an absolute path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_abspath</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">),</span> <span class="n">dest</span><span class="p">)</span>

        <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">in_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the input data files used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">out_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the output data files produced.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tmp_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the input data files produced.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">path_in_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the absolute path of filename in the top-level working directory.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_basename</span><span class="p">,</span> <span class="n">dest_basename</span><span class="p">,</span> <span class="n">datadir</span><span class="o">=</span><span class="s">&quot;outdir&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename a file located in datadir.</span>

<span class="sd">        src_basename and dest_basename are the basename of the source file</span>
<span class="sd">        and of the destination file, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">directory</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">&quot;indir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="p">,</span>
            <span class="s">&quot;outdir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">,</span>
            <span class="s">&quot;tmpdir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="p">,</span>
        <span class="p">}[</span><span class="n">datadir</span><span class="p">]</span>

        <span class="n">src</span> <span class="o">=</span> <span class="n">directory</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="n">src_basename</span><span class="p">)</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">directory</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="n">dest_basename</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the working directory and the input files of the `Task`.</span>
<span class="sd">        It does not overwrite files if they already exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Create dirs for input, output and tmp data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>

        <span class="c"># Write files file and input file.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filesfile_string</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_input</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">write_jobfile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_wildcard</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all files and directories in the working directory</span>

<span class="sd">        Args:</span>
<span class="sd">            exclude_wildcard:</span>
<span class="sd">                Optional string with regular expressions separated by |.</span>
<span class="sd">                Files matching one of the regular expressions will be preserved.</span>
<span class="sd">                example: exclude_wildcard=&quot;*.nc|*.txt&quot; preserves all the files</span>
<span class="sd">                whose extension is in [&quot;nc&quot;, &quot;txt&quot;].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_wildcard</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">WildCard</span><span class="p">(</span><span class="n">exclude_wildcards</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">dirnames</span><span class="p">,</span> <span class="n">filenames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">w</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">filenames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all the files listed in filenames.&quot;&quot;&quot;</span>
        <span class="n">filenames</span> <span class="o">=</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">dirnames</span><span class="p">,</span> <span class="n">fnames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Base class does not provide any hook.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starts the calculation by performing the following steps:</span>

<span class="sd">            - build dirs and files</span>
<span class="sd">            - call the _setup method</span>
<span class="sd">            - execute the job file by executing/submitting the job script.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;Task status: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup</span><span class="p">()</span>

        <span class="c"># Add the variables needed to connect the node.</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="nb">vars</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">connecting_vars</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Adding connecting vars </span><span class="si">%s</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">vars</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>

        <span class="c"># Automatic parallelization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">autoparal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># Start the calculation in a subprocess and return.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">start_and_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to start the task and wait.</span>

<span class="sd">        Mainly used when we are submitting the task via the shell</span>
<span class="sd">        without passing through a queue manager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">AbinitTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class defining an ABINIT calculation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#IN = &quot;in&quot;</span>
    <span class="c">#OUT = &quot;out&quot;</span>
    <span class="c">#TMP = &quot;tmp&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_input</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">abinit_input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of `AbinitTask` from an ABINIT input.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            abinit_input:</span>
<span class="sd">                `AbinitInput` object.</span>
<span class="sd">            workdir:</span>
<span class="sd">                Path to the working directory.</span>
<span class="sd">            manager:</span>
<span class="sd">                `TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># TODO: Find a better way to do this. I will likely need to refactor the Strategy object</span>
        <span class="n">strategy</span> <span class="o">=</span> <span class="n">StrategyWithInput</span><span class="p">(</span><span class="n">abinit_input</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abinit has the very *bad* habit of changing the file extension by appending the characters in [A,B ..., Z] </span>
<span class="sd">        to the output file, and this breaks a lot of code that relies of the use of a unique file extension.</span>
<span class="sd">        Here we fix this issue by renaming run.abo to run.abo_[number] if the output file &quot;run.abo&quot; already</span>
<span class="sd">        exists. A few lines of code in python, a lot of problems if you try to implement this trick in Fortran90. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># God rot the FORTRAN committee who was not able to give Fortran a decent standard library as well as $Windows$ OS!</span>
        <span class="c"># I don&#39;t really care if Fortran2003 provides support for OOP programming. </span>
        <span class="c"># What I need is a standardized interface to communicate with the OS!</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="c"># Find the index of the last file (if any) and push.</span>
            <span class="c"># TODO: Maybe it&#39;s better to use run.abo --&gt; run(1).abo</span>
            <span class="n">fnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">basename</span><span class="p">)]</span>
            <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">]</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="k">if</span> <span class="n">nums</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

            <span class="c"># Call os.rename and are done! It&#39;s really amazing the that I can write Fortran code that runs on 10**3 processors </span>
            <span class="c"># whereas a simple mv in F90 requires a lot of unportable tricks (where unportable means &quot;not supported by $windows$&quot;).</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Will rename </span><span class="si">%s</span><span class="s"> to </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">new_path</span><span class="p">))</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">new_path</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Path to the executable required for running the Task.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;abinit&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pseudos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of pseudos used in the calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">pseudos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isnc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if norm-conserving calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">isnc</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ispaw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if PAW calculation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ispaw</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filesfile_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the list of files and prefixex needed to execute ABINIT.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="n">pj</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span>

        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>                 <span class="c"># Path to the input file</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>                <span class="c"># Path to the output file</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">idata</span><span class="p">))</span>  <span class="c"># Prefix for input data</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">odata</span><span class="p">))</span>  <span class="c"># Prefix for output data</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">tdata</span><span class="p">))</span>  <span class="c"># Prefix for temporary data</span>

        <span class="c"># Paths to the pseudopotential files.</span>
        <span class="c"># Note that here the pseudos **must** be sorted according to znucl.</span>
        <span class="k">for</span> <span class="n">pseudo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="n">pseudo</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

<span class="c"># TODO</span>
<span class="c"># Enable restarting capabilites:</span>
<span class="c"># Before doing so I need:</span>
<span class="c">#   1) Preliminary standardization of the ABINT events and critical WARNINGS (YAML)</span>
<span class="c">#   2) Change the parser so that we can use strings in the input file.</span>
<span class="c">#      We need this change for restarting structural relaxations so that we can read </span>
<span class="c">#      the initial structure from file.</span>

<div class="viewcode-block" id="ScfTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.ScfTask">[docs]</a><span class="k">class</span> <span class="nc">ScfTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Self-consistent ground-state calculations.</span>
<span class="sd">    Provide support for in-place restart via (WFK|DEN) files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">ScfConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="ScfTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.ScfTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;SCF calculations can be restarted if we have either the WFK file or the DEN file.&quot;&quot;&quot;</span>
        <span class="c"># Prefer WFK over DEN files since we can reuse the wavefunctions.</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;WFK&quot;</span><span class="p">,</span> <span class="s">&quot;DEN&quot;</span><span class="p">]:</span>
            <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">restart_file</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">restart_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TaskRestartError</span><span class="p">(</span><span class="s">&quot;Cannot find WFK or DEN file to restart from.&quot;</span><span class="p">)</span>

        <span class="c"># Move out --&gt; in.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="ScfTask.inspect"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.ScfTask.inspect">[docs]</a>    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the SCF cycle results with matplotlib.</span>

<span class="sd">        Returns</span>
<span class="sd">            `matplotlib` figure, None is some error occurred. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scf_cycle</span> <span class="o">=</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">GroundStateScfCycle</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scf_cycle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scf_cycle</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="NscfTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.NscfTask">[docs]</a><span class="k">class</span> <span class="nc">NscfTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Non-Self-consistent GS calculation.</span>
<span class="sd">    Provide in-place restart via WFK files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">NscfConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="NscfTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.NscfTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NSCF calculations can be restarted only if we have the WFK file.&quot;&quot;&quot;</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s">&quot;WFK&quot;</span>
        <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">restart_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TaskRestartError</span><span class="p">(</span><span class="s">&quot;Cannot find the WFK file to restart from.&quot;</span><span class="p">)</span>

        <span class="c"># Move out --&gt; in.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>

</div></div>
<div class="viewcode-block" id="RelaxTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.RelaxTask">[docs]</a><span class="k">class</span> <span class="nc">RelaxTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Structural optimization.</span>

<span class="sd">    .. attributes:</span>

<span class="sd">        initial_structure:</span>
<span class="sd">        final_structure:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># What about a possible ScfConvergenceWarning?</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">RelaxConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="RelaxTask.change_structure"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.RelaxTask.change_structure">[docs]</a>    <span class="k">def</span> <span class="nf">change_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the input structure.&quot;&quot;&quot;</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;changing structure&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">abinit_input</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RelaxTask.read_final_structure"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.RelaxTask.read_final_structure">[docs]</a>    <span class="k">def</span> <span class="nf">read_final_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the final structure from the GSR file and save it in self.final_structure.&quot;&quot;&quot;</span>
        <span class="c"># We already have it in memory.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;final_structure&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span>
        
        <span class="c"># Read it from file and save it if save is True.</span>
        <span class="n">gsr_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;GSR&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">gsr_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TaskRestartError</span><span class="p">(</span><span class="s">&quot;Cannot find the GSR file with the final structure to restart from.&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">ETSF_Reader</span><span class="p">(</span><span class="n">gsr_file</span><span class="p">)</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">final_structure</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">read_structure</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span> <span class="o">=</span> <span class="n">final_structure</span>

        <span class="k">return</span> <span class="n">final_structure</span>
</div>
<div class="viewcode-block" id="RelaxTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.RelaxTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Structure relaxations can be restarted only if we have the WFK file or the DEN or the GSR file.</span>
        <span class="c"># from which we can read the last structure (mandatory) and the wavefunctions (not mandatory but useful).</span>
        <span class="c"># Prefer WFK over other files since we can reuse the wavefunctions.</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;WFK&quot;</span><span class="p">,</span> <span class="s">&quot;DEN&quot;</span><span class="p">]:</span>
            <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ofile</span><span class="p">:</span>

                <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
                <span class="n">infile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ofile</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TaskRestartError</span><span class="p">(</span><span class="s">&quot;Cannot find the WFK|DEN file to restart from.&quot;</span><span class="p">)</span>

        <span class="c"># Read the relaxed structure from the GSR file.</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_final_structure</span><span class="p">()</span>
                                                           
        <span class="c"># Change the structure.</span>
        <span class="c">#self.change_structure(structure)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="RelaxTask.inspect"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.RelaxTask.inspect">[docs]</a>    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the evolution of the structural relaxation with matplotlib.</span>

<span class="sd">        Returns</span>
<span class="sd">            `matplotlib` figure, None is some error occurred. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">relaxation</span> <span class="o">=</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">Relaxation</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">relaxation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">relaxation</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="DDK_Task"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.DDK_Task">[docs]</a><span class="k">class</span> <span class="nc">DDK_Task</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Task for DDK calculations.&quot;&quot;&quot;</span>

</div>
<div class="viewcode-block" id="PhononTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.PhononTask">[docs]</a><span class="k">class</span> <span class="nc">PhononTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DFPT calculations for a single atomic perturbation.</span>
<span class="sd">    Provide support for in-place restart via (1WF|1DEN) files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO: </span>
    <span class="c"># for the time being we don&#39;t discern between GS and PhononCalculations.</span>
    <span class="c"># Restarting Phonon calculation is more difficult due to the crazy rules employed in ABINIT </span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">ScfConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="PhononTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.PhononTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Phonon calculations can be restarted only if we have the 1WF file or the 1DEN file.</span>
        <span class="c"># from which we can read the first-order wavefunctions or the first order density.</span>
        <span class="c"># Prefer 1WF over 1DEN since we can reuse the wavefunctions.</span>
        <span class="c">#self.fix_ofiles()</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;1WF&quot;</span><span class="p">,</span> <span class="s">&quot;1DEN&quot;</span><span class="p">]:</span>
            <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">restart_file</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">restart_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TaskRestartError</span><span class="p">(</span><span class="s">&quot;Cannot find the 1WF|1DEN|file to restart from.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="PhononTask.inspect"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.PhononTask.inspect">[docs]</a>    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the Phonon SCF cycle results with matplotlib.</span>

<span class="sd">        Returns</span>
<span class="sd">            `matplotlib` figure, None is some error occurred. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scf_cycle</span> <span class="o">=</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">PhononScfCycle</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scf_cycle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scf_cycle</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="G_Task"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.G_Task">[docs]</a><span class="k">class</span> <span class="nc">G_Task</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tasks for SIGMA calculations employing the self-consistent G approximation </span>
<span class="sd">    Provide support for in-place restart via QPS files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">QPSConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="G_Task.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.G_Task.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># G calculations can be restarted only if we have the QPS file </span>
        <span class="c"># from which we can read the results of the previous step.</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s">&quot;QPS&quot;</span>
        <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">restart_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TaskRestartError</span><span class="p">(</span><span class="s">&quot;Cannot find the QPS file to restart from.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>

</div></div>
<span class="k">class</span> <span class="nc">BseTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Task for Bethe-Salpeter calculations.</span>

<span class="sd">    .. note:</span>

<span class="sd">        The BSE codes provides both iterative and direct schemes</span>
<span class="sd">        for the computation of the dielectric function. </span>
<span class="sd">        The direct diagonalization cannot be restarted whereas </span>
<span class="sd">        Haydock and CG support restarting.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="c">#class CgBseTask(BseTask):</span>
<span class="c">#    &quot;&quot;&quot;Bethe-Salpeter calculations with the conjugate-gradient method.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="HaydockBseTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.HaydockBseTask">[docs]</a><span class="k">class</span> <span class="nc">HaydockBseTask</span><span class="p">(</span><span class="n">BseTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bethe-Salpeter calculations with Haydock iterative scheme.</span>
<span class="sd">    Provide in-place restart via (BSR|BSC) files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">HaydockConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="HaydockBseTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.HaydockBseTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># BSE calculations with Haydock can be restarted only if we have the </span>
        <span class="c"># excitonic Hamiltonian and the HAYDR_SAVE file.</span>
        <span class="c"># TODO: This version seems to work but the main output file is truncated</span>
        <span class="c"># the log file is complete though.</span>
        <span class="n">irdvars</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># Move the BSE blocks to indata.</span>
        <span class="c"># This is done only once at the end of the first run.</span>
        <span class="c"># Successive restarts will use the BSR|BSC files in the indir directory</span>
        <span class="c"># to initialize the excitonic Hamiltonian</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;BSR&quot;</span><span class="p">,</span> <span class="s">&quot;BSC&quot;</span><span class="p">]:</span>
            <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ofile</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">irdvars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
            <span class="c"># outdir does not contain the BSR|BSC file.</span>
            <span class="c"># This means that num_restart &gt; 1 and the files should</span>
            <span class="c"># be in task.indir</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;BSR&quot;</span><span class="p">,</span> <span class="s">&quot;BSC&quot;</span><span class="p">]:</span>
                <span class="n">ifile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ifile</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TaskRestartError</span><span class="p">(</span><span class="s">&quot;Cannot find BSR|BSC files in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">sekf</span><span class="o">.</span><span class="n">indir</span><span class="p">)</span>

        <span class="c"># Rename HAYDR_SAVE files</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;HAYDR_SAVE&quot;</span><span class="p">,</span> <span class="s">&quot;HAYDC_SAVE&quot;</span><span class="p">]:</span>
            <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ofile</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">irdvars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TaskRestartError</span><span class="p">(</span><span class="s">&quot;Cannot find the HAYDR_SAVE file to restart from.&quot;</span><span class="p">)</span>

        <span class="c"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">add_extra_abivars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c"># Now we can resubmit the job.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>

</div></div>
<div class="viewcode-block" id="OpticTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask">[docs]</a><span class="k">class</span> <span class="nc">OpticTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="c"># TODO</span>
    <span class="c"># FIx the problem with report.is_completed</span>
    <span class="c"># all the executables in Abinit should signal the successful completion with the same format.</span>
    <span class="c"># possibly with YAML</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optic_input</span><span class="p">,</span> <span class="n">nscf_node</span><span class="p">,</span> <span class="n">ddk_nodes</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of `OpticTask` from an string containing the input.</span>
<span class="sd">    </span>
<span class="sd">        Args:</span>
<span class="sd">            optic_input:</span>
<span class="sd">                string with the optic variables (filepaths will be added at run time).</span>
<span class="sd">            nscf_node:</span>
<span class="sd">                The NSCF task that will produce thw WFK file.</span>
<span class="sd">            ddk_nodes:</span>
<span class="sd">                List of `DDK_Task` nodes that will produce the DDK files.</span>
<span class="sd">            workdir:</span>
<span class="sd">                Path to the working directory.</span>
<span class="sd">            manager:</span>
<span class="sd">                `TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">nscf_node</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_string</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ddk_nodes</span><span class="p">)</span>
            <span class="n">nscf_node</span> <span class="o">=</span> <span class="n">FileNode</span><span class="p">(</span><span class="n">nscf_node</span><span class="p">)</span>
            <span class="n">ddk_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">FileNode</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">ddk_nodes</span><span class="p">]</span>

        <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">task</span><span class="p">:</span> <span class="s">&quot;1WF&quot;</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">ddk_nodes</span><span class="p">}</span>
        <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">nscf_node</span><span class="p">:</span> <span class="s">&quot;WFK&quot;</span><span class="p">})</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;deps&quot;</span><span class="p">,</span><span class="n">deps</span><span class="p">)</span>

        <span class="n">strategy</span> <span class="o">=</span> <span class="n">OpticInput</span><span class="p">(</span><span class="n">optic_input</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OpticTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>

        <span class="c"># Keep a reference to the nscf_task and the ddk tasks</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ddk_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nscf_node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span> <span class="o">=</span> <span class="n">nscf_node</span><span class="p">,</span> <span class="n">ddk_nodes</span>

<div class="viewcode-block" id="OpticTask.set_workdir"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.set_workdir">[docs]</a>    <span class="k">def</span> <span class="nf">set_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OpticTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_workdir</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>
        <span class="c"># Small hack: the log file of optics is actually the main output file. </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="OpticTask.executable"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.executable">[docs]</a>    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Path to the executable required for running the `OpticTask`.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;optic&quot;</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="OpticTask.filesfile_string"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.filesfile_string">[docs]</a>    <span class="k">def</span> <span class="nf">filesfile_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the list of files and prefixes needed to execute ABINIT.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="n">pj</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span>

        <span class="c">#optic.in     ! Name of input file</span>
        <span class="c">#optic.out    ! Unused</span>
        <span class="c">#optic        ! Root name for all files that will be produced</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>                 <span class="c"># Path to the input file</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s">&quot;unused&quot;</span><span class="p">))</span>           <span class="c"># Path to the output file</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">odata</span><span class="p">))</span>  <span class="c"># Prefix for output data</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="OpticTask.wfk_filepath"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.wfk_filepath">[docs]</a>    <span class="k">def</span> <span class="nf">wfk_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the WFK file produced by the NSCF run.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nscf_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;WFK&quot;</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="OpticTask.ddk_filepaths"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.ddk_filepaths">[docs]</a>    <span class="k">def</span> <span class="nf">ddk_filepaths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the DDK files produced by the DDK runs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ddk_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;1WF&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ddk_task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="OpticTask.make_input"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.make_input">[docs]</a>    <span class="k">def</span> <span class="nf">make_input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct and write the input file of the calculation.&quot;&quot;&quot;</span>
        <span class="c"># Set the file paths.</span>
        <span class="n">files</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_filepaths</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">wfk_filepath</span><span class="p">])</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>

        <span class="c"># Get the input specified by the user</span>
        <span class="n">user_inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">.</span><span class="n">make_input</span><span class="p">()</span>

        <span class="c"># Join them.</span>
        <span class="k">return</span> <span class="n">files</span> <span class="o">+</span> <span class="n">user_inp</span>
</div>
<div class="viewcode-block" id="OpticTask.setup"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public method called before submitting the task.&quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="OpticTask.make_links"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.OpticTask.make_links">[docs]</a>    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optic allows the user to specify the paths of the input file.</span>
<span class="sd">        hence we don&#39;t need to create symbolic links.</span>
<span class="sd">        &quot;&quot;&quot;</span>
</div></div>
<div class="viewcode-block" id="AnaddbTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask">[docs]</a><span class="k">class</span> <span class="nc">AnaddbTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="c"># TODO</span>
    <span class="c"># FIx the problem with report.is_completed</span>
    <span class="c"># all the executables in Abinit should signal the successful completion with the same format.</span>
    <span class="c"># possibly with YAML</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anaddb_input</span><span class="p">,</span> <span class="n">ddb_node</span><span class="p">,</span> 
                 <span class="n">gkk_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">md_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ddk_node</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of `AnaddbTask` from an string containing the input.</span>

<span class="sd">        Args:</span>
<span class="sd">            anaddb_input:</span>
<span class="sd">                string with the anaddb variables.</span>
<span class="sd">            ddb_node:</span>
<span class="sd">                The node that will produce the DDB file (can be either `Task` or `Workflow` object)</span>
<span class="sd">            gkk_node:</span>
<span class="sd">                The node that will produce the GKK file (can be either `Task` or `Workflow` object)</span>
<span class="sd">                optional.</span>
<span class="sd">            md_node:</span>
<span class="sd">                The node that will produce the MD file (can be either `Task` or `Workflow` object)</span>
<span class="sd">                optional.</span>
<span class="sd">            gkk_node:</span>
<span class="sd">                The node that will produce the GKK file (can be either `Task` or `Workflow` object)</span>
<span class="sd">                optional.</span>
<span class="sd">            workdir:</span>
<span class="sd">                Path to the working directory.</span>
<span class="sd">            manager:</span>
<span class="sd">                `TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Keep a reference to the nodes.</span>
        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">ddb_node</span><span class="p">):</span> <span class="n">ddb_node</span> <span class="o">=</span> <span class="n">FileNode</span><span class="p">(</span><span class="n">ddb_node</span><span class="p">)</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">ddb_node</span><span class="p">:</span> <span class="s">&quot;DDB&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span> <span class="o">=</span> <span class="n">ddb_node</span>

        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">gkk_node</span><span class="p">):</span> <span class="n">gkk_node</span> <span class="o">=</span> <span class="n">FileNode</span><span class="p">(</span><span class="n">gkk_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gkk_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">gkk_node</span><span class="p">:</span> <span class="s">&quot;GKK&quot;</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span> <span class="o">=</span> <span class="n">gkk_node</span>

        <span class="c"># TODO: I never used it!</span>
        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">md_node</span><span class="p">):</span> <span class="n">md_node</span> <span class="o">=</span> <span class="n">FileNode</span><span class="p">(</span><span class="n">md_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">md_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">md_node</span><span class="p">:</span> <span class="s">&quot;MD&quot;</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span> <span class="o">=</span> <span class="n">md_node</span>

        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">ddk_node</span><span class="p">):</span> <span class="n">ddk_node</span> <span class="o">=</span> <span class="n">FileNode</span><span class="p">(</span><span class="n">ddk_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ddk_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">ddk_node</span><span class="p">:</span> <span class="s">&quot;DDK&quot;</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span> <span class="o">=</span> <span class="n">ddk_node</span>
                                                                                                        
        <span class="c"># TODO Refactor this code.</span>
        <span class="n">strategy</span> <span class="o">=</span> <span class="n">AnaddbInput</span><span class="p">(</span><span class="n">anaddb_input</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AnaddbTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="AnaddbTask.executable"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.executable">[docs]</a>    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Path to the executable required for running the `AnaddbTask`.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;anaddb&quot;</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AnaddbTask.filesfile_string"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.filesfile_string">[docs]</a>    <span class="k">def</span> <span class="nf">filesfile_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the list of files and prefixes needed to execute ABINIT.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>          <span class="c"># 1) Path of the input file</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>         <span class="c"># 2) Path of the output file</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddb_filepath</span><span class="p">)</span>             <span class="c"># 3) Input derivative database e.g. t13.ddb.in</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">md_filepath</span><span class="p">)</span>              <span class="c"># 4) Output molecular dynamics e.g. t13.md</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gkk_filepath</span><span class="p">)</span>             <span class="c"># 5) Input elphon matrix elements  (GKK file)</span>
        <span class="c"># FIXME check this one</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_join</span><span class="p">(</span><span class="s">&quot;out&quot;</span><span class="p">))</span>  <span class="c"># 6) Base name for elphon output files e.g. t13</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_filepath</span><span class="p">)</span>             <span class="c"># 7) File containing ddk filenames for elphon/transport.</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AnaddbTask.ddb_filepath"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.ddb_filepath">[docs]</a>    <span class="k">def</span> <span class="nf">ddb_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input DDB file.&quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDB&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s">&quot;DDB_FILE_DOES_NOT_EXIST&quot;</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AnaddbTask.md_filepath"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.md_filepath">[docs]</a>    <span class="k">def</span> <span class="nf">md_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input MD file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;MD_FILE_DOES_NOT_EXIST&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;MD&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s">&quot;MD_FILE_DOES_NOT_EXIST&quot;</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AnaddbTask.gkk_filepath"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.gkk_filepath">[docs]</a>    <span class="k">def</span> <span class="nf">gkk_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input GKK file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;GKK_FILE_DOES_NOT_EXIST&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;GKK&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s">&quot;GKK_FILE_DOES_NOT_EXIST&quot;</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AnaddbTask.ddk_filepath"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.ddk_filepath">[docs]</a>    <span class="k">def</span> <span class="nf">ddk_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input DKK file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;DDK_FILE_DOES_NOT_EXIST&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s">&quot;DDK&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s">&quot;DDK_FILE_DOES_NOT_EXIST&quot;</span>
</div>
<div class="viewcode-block" id="AnaddbTask.setup"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public method called before submitting the task.&quot;&quot;&quot;</span>
</div>
<div class="viewcode-block" id="AnaddbTask.make_links"><a class="viewcode-back" href="../../../../pymatgen.io.abinitio.html#pymatgen.io.abinitio.tasks.AnaddbTask.make_links">[docs]</a>    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Anaddb allows the user to specify the paths of the input file.</span>
<span class="sd">        hence we don&#39;t need to create symbolic links.</span>
<span class="sd">        &quot;&quot;&quot;</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">pymatgen 2.8.8 documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2011, Shyue Ping Ong, Anubhav Jain, Geoffroy Hautier, William Davidson Richard, Stephen Dacek, Sai Jayaraman, Michael Kocher, Dan Gunter, Shreyas Cholia, Vincent L Chevrier, Rickard Armiento.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>