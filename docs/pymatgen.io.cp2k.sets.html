<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pymatgen.io.cp2k.sets module &mdash; pymatgen 2023.1.20 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="canonical" href="https://pymatgen.orgpymatgen.io.cp2k.sets.html"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pymatgen.io.cp2k.utils module" href="pymatgen.io.cp2k.utils.html" />
    <link rel="prev" title="pymatgen.io.cp2k.outputs module" href="pymatgen.io.cp2k.outputs.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: linear-gradient(0deg, rgba(23,63,162,1) 0%, rgba(0,70,192,1) 100%)" >
            <a href="index.html" class="icon icon-home"> pymatgen
          </a>
              <div class="version">
                2023.1.20
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="change_log.html">Change log</a></li>
<li class="toctree-l1"><a class="reference internal" href="compatibility.html">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="team.html">Development Team</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">API Docs</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="pymatgen.html">pymatgen namespace</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="pymatgen.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="pymatgen.alchemy.html">pymatgen.alchemy package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.analysis.html">pymatgen.analysis namespace</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.apps.html">pymatgen.apps package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.cli.html">pymatgen.cli package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.command_line.html">pymatgen.command_line package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.core.html">pymatgen.core package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.electronic_structure.html">pymatgen.electronic_structure package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.entries.html">pymatgen.entries package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.ext.html">pymatgen.ext namespace</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="pymatgen.io.html">pymatgen.io namespace</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.optimization.html">pymatgen.optimization package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.phonon.html">pymatgen.phonon package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.symmetry.html">pymatgen.symmetry package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.transformations.html">pymatgen.transformations package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.util.html">pymatgen.util package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.vis.html">pymatgen.vis package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pymatgen.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: linear-gradient(0deg, rgba(23,63,162,1) 0%, rgba(0,70,192,1) 100%)" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pymatgen</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">pymatgen</a></li>
          <li class="breadcrumb-item"><a href="pymatgen.html">pymatgen namespace</a></li>
          <li class="breadcrumb-item"><a href="pymatgen.io.html">pymatgen.io namespace</a></li>
          <li class="breadcrumb-item"><a href="pymatgen.io.cp2k.html">pymatgen.io.cp2k package</a></li>
      <li class="breadcrumb-item active">pymatgen.io.cp2k.sets module</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/materialsproject/pymatgen/blob/master/docs_rst/pymatgen.io.cp2k.sets.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pymatgen.io.cp2k.sets">
<span id="pymatgen-io-cp2k-sets-module"></span><h1>pymatgen.io.cp2k.sets module<a class="headerlink" href="#module-pymatgen.io.cp2k.sets" title="Permalink to this heading"></a></h1>
<p>This module defines input sets for CP2K and is a work in progress. The structure/philosophy
of this module is based on the Vasp input sets in Pymatgen. These sets are meant to contain
tested parameters that will result in successful, reproducible, consistent calculations without
need for intervention 99% of the time. 99% of the time, you only need to provide a pymatgen
structure object and let the defaults take over from there.</p>
<p>The sets are intended to be very general, e.g. a set for geometry relaxation, and so most of the
time, if you have specific needs, you can simply specify them via the keyword argument
override_default_params (see Section.update() method). If you have the need to create a new input
set (say for a standardized high throughput calculation) then you can create a new child of the
Cp2kInputSet class.</p>
<dl class="simple">
<dt>In order to implement a new Set within the current code structure, follow this 3 step flow:</dt><dd><ol class="arabic simple">
<li><p>Inherit from Cp2kInputSet or one of its children and call the super() constructor</p></li>
<li><p>Create the new sections and insert them into self and its subsections as needed</p></li>
<li><p>Call self.update(override_default_params) in order to allow user settings.</p></li>
</ol>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.CellOptSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CellOptSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1376-L1381"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.CellOptSet" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.io.cp2k.sets.DftSet" title="pymatgen.io.cp2k.sets.DftSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">DftSet</span></code></a></p>
<p>Quick Constructor for cell optimization relaxation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> – Pymatgen structure or molecule object</p></li>
<li><p><strong>ot</strong> (<em>bool</em>) – Whether or not to use orbital transformation method for matrix
diagonalization. OT is the flagship scf solver of CP2K, and will provide
speed-ups for this part of the calculation, but the system must have a band gap
for OT to be used (higher band-gap –&gt; faster convergence).</p></li>
<li><p><strong>energy_gap</strong> (<em>float</em>) – Estimate of energy gap for pre-conditioner. Default is -1, leaving
it up to cp2k.</p></li>
<li><p><strong>eps_default</strong> (<em>float</em>) – Replaces all EPS_XX Keywords in the DFT section value, ensuring
an overall accuracy of at least this much.</p></li>
<li><p><strong>eps_scf</strong> (<em>float</em>) – <p>The convergence criteria for leaving the SCF loop. Default is 1e-6.
Should ensure reasonable results, but is not applicable to all situations.</p>
<blockquote>
<div><p>Note: eps_scf is <em>not</em> in units of energy, as in most DFT codes. For OT method,
it is the largest gradient of the energy with respect to changing any of the
molecular orbital coefficients. For diagonalization, it is the largest change
in the density matrix from the last step.</p>
</div></blockquote>
</p></li>
<li><p><strong>max_scf</strong> (<em>int</em>) – The max number of SCF cycles before terminating the solver. NOTE: With
the OT solver, this corresponds to the max number of INNER scf loops, and then
the outer loops are set with outer_max_scf, while with diagonalization it
corresponds to the overall (INNER*OUTER) number of SCF steps, with the
inner loop limit set by</p></li>
<li><p><strong>minimizer</strong> (<em>str</em>) – The minimization scheme. DIIS can be as much as 50% faster than the
more robust conjugate gradient method, and so it is chosen as default. Switch to CG
if dealing with a difficult system.</p></li>
<li><p><strong>preconditioner</strong> (<em>str</em>) – Pre-conditioner for the OT method. FULL_SINGLE_INVERSE is very
robust and compatible with non-integer occupations from IRAC+rotation. FULL_ALL is
considered “best” but needs algorithm to be set to STRICT. Only change from these
two when simulation cell gets to be VERY large, in which case FULL_KINETIC might be
preferred.</p></li>
<li><p><strong>algorithm</strong> (<em>str</em>) – Algorithm for the OT method. STRICT assumes that the orbitals are
strictly orthogonal to each other, which works well for wide gap ionic systems,
but can diverge for systems with small gaps, fractional occupations, and some
other cases. IRAC (iterative refinement of the approximate congruency)
transformation is not analytically correct and uses a truncated polynomial
expansion, but is robust to the problems with STRICT, and so is the default.</p></li>
<li><p><strong>linesearch</strong> (<em>str</em>) – Linesearch method for CG. 2PNT is the default, and is the fastest,
but is not as robust as 3PNT. 2PNT is required as of cp2k v9.1 for compatibility
with irac+rotation. This may be upgraded in the future. 3PNT can be good for wide
gapped transition metal systems as an alternative.</p></li>
<li><p><strong>rotation</strong> (<em>bool</em>) – Whether or not to allow for rotation of the orbitals in the OT method.
This equates to allowing for fractional occupations in the calculation.</p></li>
<li><p><strong>occupation_preconditioner</strong> (<em>bool</em>) – Whether or not to account for fractional occupations
in the preconditioner. This method is not fully integrated as of cp2k v9.1 and is
set to false by default.</p></li>
<li><p><strong>cutoff</strong> (<em>int</em>) – Cutoff energy (in Ry) for the finest level of the multigrid. A high
cutoff will allow you to have very accurate calculations PROVIDED that REL_CUTOFF
is appropriate. By default cutoff is set to 0, leaving it up to the set.</p></li>
<li><p><strong>rel_cutoff</strong> (<em>int</em>) – This cutoff decides how the Gaussians are mapped onto the different
levels of the multigrid. If REL_CUTOFF is too low, then even if you have a high
CUTOFF, all Gaussians will be mapped onto the coarsest level of the multi-grid,
and thus the effective integration grid for the calculation may still be too
coarse. By default 50Ry is chosen, which should be sufficient given the cutoff is
large enough.</p></li>
<li><p><strong>ngrids</strong> (<em>int</em>) – number of multi-grids to use. CP2K default is 4, but the molopt basis
files recommend 5.</p></li>
<li><p><strong>progression_factor</strong> (<em>int</em>) – Divisor of CUTOFF to get the cutoff for the next level of
the multigrid.</p></li>
<li><p><strong>wfn_restart_file_name</strong> (<em>str</em>) – RESTART file for the initial wavefunction guess.</p></li>
<li><p><strong>kpoints</strong> (<a class="reference internal" href="pymatgen.io.cp2k.inputs.html#pymatgen.io.cp2k.inputs.Kpoints" title="pymatgen.io.cp2k.inputs.Kpoints"><em>Kpoints</em></a>) – kpoints object from pymatgen.io.vasp.inputs.Kpoints. By default,
CP2K runs with gamma point only.</p></li>
<li><p><strong>smearing</strong> (<em>bool</em>) – whether or not to activate smearing (should be done for systems
containing no (or a very small) band gap.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.Cp2kValidationError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Cp2kValidationError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">message</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1408-L1419"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.Cp2kValidationError" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Cp2k Validation Exception. Not exhausted. May raise validation
errors for features which actually do work if using a newer version
of cp2k</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.Cp2kValidationError.CP2K_VERSION">
<span class="sig-name descname"><span class="pre">CP2K_VERSION</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'v2022.1'</span></em><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/io/cp2k/sets.py"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.Cp2kValidationError.CP2K_VERSION" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">DftSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">structure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pymatgen.core.structure.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><span class="pre">Structure</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="pymatgen.core.structure.html#pymatgen.core.structure.Molecule" title="pymatgen.core.structure.Molecule"><span class="pre">Molecule</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">project_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'CP2K'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_and_potential</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xc_functionals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiplicity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">energy_gap</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qs_method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'GPW'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps_default</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps_scf</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_scf</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimizer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'DIIS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preconditioner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'FULL_SINGLE_INVERSE'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'IRAC'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'2PNT'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occupation_preconditioner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rel_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ngrids</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progression_factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">override_default_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wfn_restart_file_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpoints</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">VaspKpoints</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smearing</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L77-L1358"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pymatgen.io.cp2k.inputs.html#pymatgen.io.cp2k.inputs.Cp2kInput" title="pymatgen.io.cp2k.inputs.Cp2kInput"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cp2kInput</span></code></a></p>
<p>Base for an input set using the Quickstep module (i.e. a DFT calculation). The DFT section is
pretty vast in CP2K, so this set hopes to make the DFT setup fairly simple. The provided
parameters are pretty conservative, and so they should not need to be changed very often.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> – Pymatgen structure or molecule object</p></li>
<li><p><strong>ot</strong> (<em>bool</em>) – Whether or not to use orbital transformation method for matrix
diagonalization. OT is the flagship scf solver of CP2K, and will provide
speed-ups for this part of the calculation, but the system must have a band gap
for OT to be used (higher band-gap –&gt; faster convergence).</p></li>
<li><p><strong>energy_gap</strong> (<em>float</em>) – Estimate of energy gap for pre-conditioner. Default is -1, leaving
it up to cp2k.</p></li>
<li><p><strong>eps_default</strong> (<em>float</em>) – Replaces all EPS_XX Keywords in the DFT section value, ensuring
an overall accuracy of at least this much.</p></li>
<li><p><strong>eps_scf</strong> (<em>float</em>) – <p>The convergence criteria for leaving the SCF loop. Default is 1e-6.
Should ensure reasonable results, but is not applicable to all situations.</p>
<blockquote>
<div><p>Note: eps_scf is <em>not</em> in units of energy, as in most DFT codes. For OT method,
it is the largest gradient of the energy with respect to changing any of the
molecular orbital coefficients. For diagonalization, it is the largest change
in the density matrix from the last step.</p>
</div></blockquote>
</p></li>
<li><p><strong>max_scf</strong> (<em>int</em>) – The max number of SCF cycles before terminating the solver. NOTE: With
the OT solver, this corresponds to the max number of INNER scf loops, and then
the outer loops are set with outer_max_scf, while with diagonalization it
corresponds to the overall (INNER*OUTER) number of SCF steps, with the
inner loop limit set by</p></li>
<li><p><strong>minimizer</strong> (<em>str</em>) – The minimization scheme. DIIS can be as much as 50% faster than the
more robust conjugate gradient method, and so it is chosen as default. Switch to CG
if dealing with a difficult system.</p></li>
<li><p><strong>preconditioner</strong> (<em>str</em>) – Pre-conditioner for the OT method. FULL_SINGLE_INVERSE is very
robust and compatible with non-integer occupations from IRAC+rotation. FULL_ALL is
considered “best” but needs algorithm to be set to STRICT. Only change from these
two when simulation cell gets to be VERY large, in which case FULL_KINETIC might be
preferred.</p></li>
<li><p><strong>algorithm</strong> (<em>str</em>) – Algorithm for the OT method. STRICT assumes that the orbitals are
strictly orthogonal to each other, which works well for wide gap ionic systems,
but can diverge for systems with small gaps, fractional occupations, and some
other cases. IRAC (iterative refinement of the approximate congruency)
transformation is not analytically correct and uses a truncated polynomial
expansion, but is robust to the problems with STRICT, and so is the default.</p></li>
<li><p><strong>linesearch</strong> (<em>str</em>) – Linesearch method for CG. 2PNT is the default, and is the fastest,
but is not as robust as 3PNT. 2PNT is required as of cp2k v9.1 for compatibility
with irac+rotation. This may be upgraded in the future. 3PNT can be good for wide
gapped transition metal systems as an alternative.</p></li>
<li><p><strong>rotation</strong> (<em>bool</em>) – Whether or not to allow for rotation of the orbitals in the OT method.
This equates to allowing for fractional occupations in the calculation.</p></li>
<li><p><strong>occupation_preconditioner</strong> (<em>bool</em>) – Whether or not to account for fractional occupations
in the preconditioner. This method is not fully integrated as of cp2k v9.1 and is
set to false by default.</p></li>
<li><p><strong>cutoff</strong> (<em>int</em>) – Cutoff energy (in Ry) for the finest level of the multigrid. A high
cutoff will allow you to have very accurate calculations PROVIDED that REL_CUTOFF
is appropriate. By default cutoff is set to 0, leaving it up to the set.</p></li>
<li><p><strong>rel_cutoff</strong> (<em>int</em>) – This cutoff decides how the Gaussians are mapped onto the different
levels of the multigrid. If REL_CUTOFF is too low, then even if you have a high
CUTOFF, all Gaussians will be mapped onto the coarsest level of the multi-grid,
and thus the effective integration grid for the calculation may still be too
coarse. By default 50Ry is chosen, which should be sufficient given the cutoff is
large enough.</p></li>
<li><p><strong>ngrids</strong> (<em>int</em>) – number of multi-grids to use. CP2K default is 4, but the molopt basis
files recommend 5.</p></li>
<li><p><strong>progression_factor</strong> (<em>int</em>) – Divisor of CUTOFF to get the cutoff for the next level of
the multigrid.</p></li>
<li><p><strong>wfn_restart_file_name</strong> (<em>str</em>) – RESTART file for the initial wavefunction guess.</p></li>
<li><p><strong>kpoints</strong> (<a class="reference internal" href="pymatgen.io.cp2k.inputs.html#pymatgen.io.cp2k.inputs.Kpoints" title="pymatgen.io.cp2k.inputs.Kpoints"><em>Kpoints</em></a>) – kpoints object from pymatgen.io.vasp.inputs.Kpoints. By default,
CP2K runs with gamma point only.</p></li>
<li><p><strong>smearing</strong> (<em>bool</em>) – whether or not to activate smearing (should be done for systems
containing no (or a very small) band gap.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_epr">
<span class="sig-name descname"><span class="pre">activate_epr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1110-L1115"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_epr" title="Permalink to this definition"></a></dt>
<dd><p>Calculate g-tensor. Requires localize. Suggested with GAPW</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_fast_minimization">
<span class="sig-name descname"><span class="pre">activate_fast_minimization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">on</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1194-L1205"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_fast_minimization" title="Permalink to this definition"></a></dt>
<dd><p>Method to modify the set to use fast SCF minimization.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_hybrid">
<span class="sig-name descname"><span class="pre">activate_hybrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hybrid_functional</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'PBE0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hf_fraction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gga_x_fraction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gga_c_fraction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff_radius</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">8.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.11</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_coulomb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_gaussian</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_longrange</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">admm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">admm_method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BASIS_PROJECTION'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">admm_purification_method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'NONE'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">admm_exch_correction_func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'DEFAULT'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps_schwarz</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-07</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps_schwarz_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_on_initial_p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_p_forces</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L716-L981"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_hybrid" title="Permalink to this definition"></a></dt>
<dd><p>Basic set for activating hybrid DFT calculation using Auxiliary Density Matrix Method.</p>
<p>Note 1: When running ADMM with cp2k, memory is very important. If the memory requirements
exceed what is available (see max_memory), then CP2K will have to calculate the 4-electron
integrals for HFX during each step of the SCF cycle. ADMM provides a huge speed up by
making the memory requirements <em>feasible</em> to fit into RAM, which means you only need to
calculate the integrals once each SCF cycle. But, this only works if it fits into memory.
When setting up ADMM calculations, we recommend doing whatever is possible to fit all the
4EI into memory.</p>
<p>Note 2: This set is designed for reliable high-throughput calculations, NOT for extreme
accuracy. Please review the in-line comments in this method if you want more control.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hybrid_functional</strong> (<em>str</em>) – Type of hybrid functional. This set supports HSE (screened)
and PBE0 (truncated). Default is PBE0, which converges easier in the GPW basis
used by cp2k.</p></li>
<li><p><strong>hf_fraction</strong> (<em>float</em>) – fraction of exact HF exchange energy to mix. Default: 0.25</p></li>
<li><p><strong>gga_x_fraction</strong> (<em>float</em>) – fraction of gga exchange energy to retain. Default: 0.75</p></li>
<li><p><strong>gga_c_fraction</strong> (<em>float</em>) – fraction of gga correlation energy to retain. Default: 1.0</p></li>
<li><p><strong>max_memory</strong> (<em>int</em>) – Maximum memory available to each MPI process (in Mb) in the
calculation. Most modern computing nodes will have ~2Gb per core, or 2048 Mb,
but check for your specific system. This value should be as large as possible
while still leaving some memory for the other parts of cp2k. Important: If
this value is set larger than the memory limits, CP2K will likely seg-fault.
Default: 2000</p></li>
<li><p><strong>cutoff_radius</strong> (<em>float</em>) – for truncated hybrid functional (i.e. PBE0), this is the cutoff
radius. The default is selected as that which generally gives convergence, but
maybe too low (if you want very high accuracy) or too high (if you want a quick
screening). Default: 8 angstroms</p></li>
<li><p><strong>potential_type</strong> (<em>str</em>) – what interaction potential to use for HFX. Available in CP2K are
COULOMB, GAUSSIAN, IDENTITY, LOGRANGE, MIX_CL, MIX_CL_TRUNC, MIX_LG, SHORTRANGE,
and TRUNCATED. Default is None, and it will be set automatically depending on the
named hybrid_functional that you use, but setting it to one of the acceptable
values will constitute a user-override.</p></li>
<li><p><strong>omega</strong> (<em>float</em>) – For HSE, this specifies the screening parameter. HSE06 sets this as
0.2, which is the default.</p></li>
<li><p><strong>scale_coulomb</strong> – Scale for the coulomb operator if using a range separated functional</p></li>
<li><p><strong>scale_gaussian</strong> – Scale for the gaussian operator (if applicable)</p></li>
<li><p><strong>scale_longrange</strong> – Scale for the coulomb operator if using a range separated functional</p></li>
<li><p><strong>admm</strong> – Whether or not to use the auxiliary density matrix method for the exact
HF exchange contribution. Highly recommended. Speed ups between 10x and 1000x are
possible when compared to non ADMM hybrid calculations.</p></li>
<li><p><strong>admm_method</strong> – Method for constructing the auxiliary basis</p></li>
<li><p><strong>admm_purification_method</strong> – Method for purifying the auxiliary density matrix so as to
preserve properties, such as idempotency. May lead to shifts in the
eigenvalues.</p></li>
<li><p><strong>admm_exch_correction_func</strong> – Which functional to use to calculate the exchange correction
E_x(primary) - E_x(aux)</p></li>
<li><p><strong>eps_schwarz</strong> – Screening threshold for HFX, in Ha. Contributions smaller than
this will be screened. The smaller the value, the more accurate, but also the more
costly. Default value is 1e-7. 1e-6 works in a large number of cases, but is
quite aggressive, which can lead to convergence issues.</p></li>
<li><p><strong>eps_schwarz_forces</strong> – Same as for eps_schwarz, but for screening contributions to
forces. Convergence is not as sensitive with respect to eps_schwarz forces as
compared to eps_schwarz, and so 1e-6 should be good default.</p></li>
<li><p><strong>screen_on_initial_p</strong> – If an initial density matrix is provided, in the form of a
CP2K wfn restart file, then this initial density will be used for screening. This
is generally very computationally efficient, but, as with eps_schwarz, can lead to
instabilities if the initial density matrix is poor.</p></li>
<li><p><strong>screen_p_forces</strong> – Same as screen_on_initial_p, but for screening of forces.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_hyperfine">
<span class="sig-name descname"><span class="pre">activate_hyperfine</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1138-L1140"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_hyperfine" title="Permalink to this definition"></a></dt>
<dd><p>Print the hyperfine coupling constants.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_localize">
<span class="sig-name descname"><span class="pre">activate_localize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'OCCUPIED'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preconditioner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'FULL_ALL'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1142-L1161"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_localize" title="Permalink to this definition"></a></dt>
<dd><p>Activate calculation of the maximally localized wannier functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>states</strong> – Which states to calculate. occupied, unoccupied, mixed states, or all states. At
present, unoccupied orbitals are only implemented for GPW.</p></li>
<li><p><strong>preconditioner</strong> – Preconditioner to use for optimize</p></li>
<li><p><strong>restart</strong> – Initialize from the localization restart file</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_motion">
<span class="sig-name descname"><span class="pre">activate_motion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_drift</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rms_drift</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0015</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_force</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.00045</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rms_force</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0003</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BFGS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trust_radius</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_search</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'2PNT'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensemble</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'NVE'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">300</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsteps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thermostat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'NOSE'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nproc_rep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L983-L1102"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_motion" title="Permalink to this definition"></a></dt>
<dd><p>Turns on the motion section for GEO_OPT, CELL_OPT, etc. calculations.
Will turn on the printing subsections and also bind any constraints
to their respective atoms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_nmr">
<span class="sig-name descname"><span class="pre">activate_nmr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1117-L1122"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_nmr" title="Permalink to this definition"></a></dt>
<dd><p>Calculate nmr shifts. Requires localize. Suggested with GAPW</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_nonperiodic">
<span class="sig-name descname"><span class="pre">activate_nonperiodic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANALYTIC'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1232-L1241"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_nonperiodic" title="Permalink to this definition"></a></dt>
<dd><p>Activates a calculation with non-periodic calculations by turning of PBC and
changing the poisson solver. Still requires a CELL to put the atoms</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_polar">
<span class="sig-name descname"><span class="pre">activate_polar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1130-L1136"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_polar" title="Permalink to this definition"></a></dt>
<dd><p>Calculate polarizations (including raman).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_robust_minimization">
<span class="sig-name descname"><span class="pre">activate_robust_minimization</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1207-L1217"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_robust_minimization" title="Permalink to this definition"></a></dt>
<dd><p>Method to modify the set to use more robust SCF minimization technique</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_spinspin">
<span class="sig-name descname"><span class="pre">activate_spinspin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1124-L1128"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_spinspin" title="Permalink to this definition"></a></dt>
<dd><p>Calculate spin-spin coupling tensor. Requires localize.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_tddfpt">
<span class="sig-name descname"><span class="pre">activate_tddfpt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1104-L1108"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_tddfpt" title="Permalink to this definition"></a></dt>
<dd><p>Activate TDDFPT for calculating excited states. Only works with GPW. Supports hfx.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_vdw_potential">
<span class="sig-name descname"><span class="pre">activate_vdw_potential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dispersion_functional</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">potential_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1163-L1192"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_vdw_potential" title="Permalink to this definition"></a></dt>
<dd><p>Activate van der Waals dispersion corrections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dispersion_functional</strong> – Type of dispersion functional.
Options: pair_potential or non_local</p></li>
<li><p><strong>potential_type</strong> – What type of potential to use, given a dispersion functional type
Options: DFTD2, DFTD3, DFTD3(BJ), DRSLL, LMKLL, RVV10</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.activate_very_strict_minimization">
<span class="sig-name descname"><span class="pre">activate_very_strict_minimization</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1219-L1230"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.activate_very_strict_minimization" title="Permalink to this definition"></a></dt>
<dd><p>Method to modify the set to use very strict SCF minimization scheme
:return:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.create_subsys">
<span class="sig-name descname"><span class="pre">create_subsys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">structure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pymatgen.core.structure.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><span class="pre">Structure</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="pymatgen.core.structure.html#pymatgen.core.structure.Molecule" title="pymatgen.core.structure.Molecule"><span class="pre">Molecule</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1243-L1313"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.create_subsys" title="Permalink to this definition"></a></dt>
<dd><p>Create the structure for the input</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.get_basis_and_potential">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_basis_and_potential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">structure</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_and_potential</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L347-L545"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.get_basis_and_potential" title="Permalink to this definition"></a></dt>
<dd><p>Get a dictionary of basis and potential info for constructing the input file.</p>
<p>data in basis_and_potential argument can be specified in several ways:</p>
<blockquote>
<div><p>Strategy 1: Element-specific info (takes precedence)</p>
<blockquote>
<div><ol class="arabic">
<li><p>Provide a basis and potential object:</p>
<blockquote>
<div><p>el: {‘basis’: obj, ‘potential’: obj}</p>
</div></blockquote>
</li>
<li><p>Provide a hash of the object that matches the keys in the pmg configured cp2k data files.</p>
<blockquote>
<div><p>el: {‘basis’: hash, ‘potential’: hash}</p>
</div></blockquote>
</li>
</ol>
<p>3. Provide the name of the basis and potential AND the basis_filenames and potential_filename
keywords specifying where to find these objects</p>
<blockquote>
<div><dl class="simple">
<dt>el: {</dt><dd><p>‘basis’: name, ‘potential’: name, ‘basis_filenames’: [filenames],
‘potential_filename’: filename</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</div></blockquote>
<p>Strategy 2: global descriptors</p>
<blockquote>
<div><p>In this case, any elements not present in the argument will be dealt with by searching the pmg
configured cp2k data files to find a objects matching your requirements.</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>functional: Find potential and basis that have been optimized for a specific functional like PBE.</dt><dd><p>Can be None if you do not require them to match.</p>
</dd>
</dl>
</li>
<li><p>basis_type: type of basis to search for (e.g. DZVP-MOLOPT).</p></li>
<li><dl class="simple">
<dt>aux_basis_type: type of basis to search for (e.g. pFIT). Some elements do not have all aux types</dt><dd><p>available. Use aux_basis_type that is universal to avoid issues, or avoid using this strategy.</p>
</dd>
</dl>
</li>
<li><p>potential_type: “Pseudopotential” or “All Electron”</p></li>
</ul>
</div></blockquote>
<p><strong>*BE WARNED*</strong> CP2K data objects can have the same name, this will sort those and choose the first one
that matches.</p>
</div></blockquote>
</div></blockquote>
<p>Will raise an error if no basis/potential info can be found according to the input.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.get_cutoff_from_basis">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_cutoff_from_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_sets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rel_cutoff</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L547-L567"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.get_cutoff_from_basis" title="Permalink to this definition"></a></dt>
<dd><p>Given a basis and a relative cutoff. Determine the ideal cutoff variable</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.get_xc_functionals">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_xc_functionals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc_functionals</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L569-L596"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.get_xc_functionals" title="Permalink to this definition"></a></dt>
<dd><p>Get XC functionals. If simplified names are provided in kwargs, they
will be expanded into their corresponding X and C names.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.modify_dft_print_iters">
<span class="sig-name descname"><span class="pre">modify_dft_print_iters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'no'</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1315-L1347"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.modify_dft_print_iters" title="Permalink to this definition"></a></dt>
<dd><p>Modify all DFT print iterations at once. Common use is to set iters to the max
number of iterations + 1 and then set add_last to numeric. This would have the
effect of printing only the first and last iteration, which might be useful for
speeding up/saving space on GEO_OPT or MD runs where you don’t need the intermediate
values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iters</strong> (<em>int</em>) – print each “iters” iterations.</p></li>
<li><p><strong>add_last</strong> (<em>str</em>) – Whether to explicitly include the last iteration, and how to mark it.
numeric: mark last iteration with the iteration number
symbolic: mark last iteration with the letter “l”
no: do not explicitly include the last iteration</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.print_bandstructure">
<span class="sig-name descname"><span class="pre">print_bandstructure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kpoints_line_density</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L684-L700"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.print_bandstructure" title="Permalink to this definition"></a></dt>
<dd><p>Attaches a non-scf band structure calc the end of an SCF loop.</p>
<p>This requires a kpoint calculation, which is not always default in cp2k.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>kpoints_line_density</strong> – number of kpoints along each branch in line-mode calc.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.print_dos">
<span class="sig-name descname"><span class="pre">print_dos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ndigits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L614-L622"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.print_dos" title="Permalink to this definition"></a></dt>
<dd><p>Activate printing of the overall DOS file.</p>
<p>Note: As of 2022.1, ndigits needs to be set to a sufficient value to ensure data is not lost.
Note: As of 2022.1, can only be used with a k-point calculation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.print_e_density">
<span class="sig-name descname"><span class="pre">print_e_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(2,</span> <span class="pre">2,</span> <span class="pre">2)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L677-L682"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.print_e_density" title="Permalink to this definition"></a></dt>
<dd><p>Controls the printing of cube files with electronic density and, for UKS, the spin density</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.print_forces">
<span class="sig-name descname"><span class="pre">print_forces</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L606-L612"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.print_forces" title="Permalink to this definition"></a></dt>
<dd><p>Print out the forces and stress during calculation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.print_hirshfeld">
<span class="sig-name descname"><span class="pre">print_hirshfeld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">on</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L702-L705"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.print_hirshfeld" title="Permalink to this definition"></a></dt>
<dd><p>Activate or deactivate printing of Hirshfeld charges</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.print_ldos">
<span class="sig-name descname"><span class="pre">print_ldos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nlumo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L636-L648"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.print_ldos" title="Permalink to this definition"></a></dt>
<dd><p>Activate the printing of LDOS files, printing one for each atom kind by default</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nlumo</strong> (<em>int</em>) – Number of virtual orbitals to be added to the MO set (-1=all).
CAUTION: Setting this value to be higher than the number of states present may
cause a Cholesky error.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.print_mo">
<span class="sig-name descname"><span class="pre">print_mo</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L662-L666"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.print_mo" title="Permalink to this definition"></a></dt>
<dd><p>Print molecular orbitals when running non-OT diagonalization</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.print_mo_cubes">
<span class="sig-name descname"><span class="pre">print_mo_cubes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">write_cube</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nlumo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nhomo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L650-L660"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.print_mo_cubes" title="Permalink to this definition"></a></dt>
<dd><p>Activate printing of molecular orbitals.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>write_cube</strong> (<em>bool</em>) – whether to write cube file for the MOs instead of out file</p></li>
<li><p><strong>nlumo</strong> (<em>int</em>) – Controls the number of lumos printed and dumped as a cube (-1=all)</p></li>
<li><p><strong>nhomo</strong> (<em>int</em>) – Controls the number of homos printed and dumped as a cube (-1=all)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.print_mulliken">
<span class="sig-name descname"><span class="pre">print_mulliken</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">on</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L707-L710"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.print_mulliken" title="Permalink to this definition"></a></dt>
<dd><p>Activate or deactivate printing of Mulliken charges</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.print_pdos">
<span class="sig-name descname"><span class="pre">print_pdos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nlumo</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L624-L634"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.print_pdos" title="Permalink to this definition"></a></dt>
<dd><p>Activate creation of the PDOS file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nlumo</strong> (<em>int</em>) – Number of virtual orbitals to be added to the MO set (-1=all).
CAUTION: Setting this value to be higher than the number of states present may
cause a Cholesky error.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.print_v_hartree">
<span class="sig-name descname"><span class="pre">print_v_hartree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(2,</span> <span class="pre">2,</span> <span class="pre">2)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L668-L675"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.print_v_hartree" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Controls the printing of a cube file with eletrostatic potential generated by the</dt><dd><p>total density (electrons+ions). It is valid only for QS with GPW formalism.</p>
</dd>
</dl>
<p>Note that by convention the potential has opposite sign than the expected physical one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.set_charge">
<span class="sig-name descname"><span class="pre">set_charge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">charge</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L712-L714"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.set_charge" title="Permalink to this definition"></a></dt>
<dd><p>Set the overall charge of the simulation cell</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.validate">
<span class="sig-name descname"><span class="pre">validate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1349-L1358"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.validate" title="Permalink to this definition"></a></dt>
<dd><p>Implements a few checks for a valid input set</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.write_basis_set_file">
<span class="sig-name descname"><span class="pre">write_basis_set_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_sets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BASIS'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L598-L600"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.write_basis_set_file" title="Permalink to this definition"></a></dt>
<dd><p>Write the basis sets to a file</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.DftSet.write_potential_file">
<span class="sig-name descname"><span class="pre">write_potential_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">potentials</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'POTENTIAL'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L602-L604"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.DftSet.write_potential_file" title="Permalink to this definition"></a></dt>
<dd><p>Write the potentials to a file</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.HybridCellOptSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HybridCellOptSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1400-L1405"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.HybridCellOptSet" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.io.cp2k.sets.DftSet" title="pymatgen.io.cp2k.sets.DftSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">DftSet</span></code></a></p>
<p>Quick Constructor for hybrid cell optimization relaxation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> – Pymatgen structure or molecule object</p></li>
<li><p><strong>ot</strong> (<em>bool</em>) – Whether or not to use orbital transformation method for matrix
diagonalization. OT is the flagship scf solver of CP2K, and will provide
speed-ups for this part of the calculation, but the system must have a band gap
for OT to be used (higher band-gap –&gt; faster convergence).</p></li>
<li><p><strong>energy_gap</strong> (<em>float</em>) – Estimate of energy gap for pre-conditioner. Default is -1, leaving
it up to cp2k.</p></li>
<li><p><strong>eps_default</strong> (<em>float</em>) – Replaces all EPS_XX Keywords in the DFT section value, ensuring
an overall accuracy of at least this much.</p></li>
<li><p><strong>eps_scf</strong> (<em>float</em>) – <p>The convergence criteria for leaving the SCF loop. Default is 1e-6.
Should ensure reasonable results, but is not applicable to all situations.</p>
<blockquote>
<div><p>Note: eps_scf is <em>not</em> in units of energy, as in most DFT codes. For OT method,
it is the largest gradient of the energy with respect to changing any of the
molecular orbital coefficients. For diagonalization, it is the largest change
in the density matrix from the last step.</p>
</div></blockquote>
</p></li>
<li><p><strong>max_scf</strong> (<em>int</em>) – The max number of SCF cycles before terminating the solver. NOTE: With
the OT solver, this corresponds to the max number of INNER scf loops, and then
the outer loops are set with outer_max_scf, while with diagonalization it
corresponds to the overall (INNER*OUTER) number of SCF steps, with the
inner loop limit set by</p></li>
<li><p><strong>minimizer</strong> (<em>str</em>) – The minimization scheme. DIIS can be as much as 50% faster than the
more robust conjugate gradient method, and so it is chosen as default. Switch to CG
if dealing with a difficult system.</p></li>
<li><p><strong>preconditioner</strong> (<em>str</em>) – Pre-conditioner for the OT method. FULL_SINGLE_INVERSE is very
robust and compatible with non-integer occupations from IRAC+rotation. FULL_ALL is
considered “best” but needs algorithm to be set to STRICT. Only change from these
two when simulation cell gets to be VERY large, in which case FULL_KINETIC might be
preferred.</p></li>
<li><p><strong>algorithm</strong> (<em>str</em>) – Algorithm for the OT method. STRICT assumes that the orbitals are
strictly orthogonal to each other, which works well for wide gap ionic systems,
but can diverge for systems with small gaps, fractional occupations, and some
other cases. IRAC (iterative refinement of the approximate congruency)
transformation is not analytically correct and uses a truncated polynomial
expansion, but is robust to the problems with STRICT, and so is the default.</p></li>
<li><p><strong>linesearch</strong> (<em>str</em>) – Linesearch method for CG. 2PNT is the default, and is the fastest,
but is not as robust as 3PNT. 2PNT is required as of cp2k v9.1 for compatibility
with irac+rotation. This may be upgraded in the future. 3PNT can be good for wide
gapped transition metal systems as an alternative.</p></li>
<li><p><strong>rotation</strong> (<em>bool</em>) – Whether or not to allow for rotation of the orbitals in the OT method.
This equates to allowing for fractional occupations in the calculation.</p></li>
<li><p><strong>occupation_preconditioner</strong> (<em>bool</em>) – Whether or not to account for fractional occupations
in the preconditioner. This method is not fully integrated as of cp2k v9.1 and is
set to false by default.</p></li>
<li><p><strong>cutoff</strong> (<em>int</em>) – Cutoff energy (in Ry) for the finest level of the multigrid. A high
cutoff will allow you to have very accurate calculations PROVIDED that REL_CUTOFF
is appropriate. By default cutoff is set to 0, leaving it up to the set.</p></li>
<li><p><strong>rel_cutoff</strong> (<em>int</em>) – This cutoff decides how the Gaussians are mapped onto the different
levels of the multigrid. If REL_CUTOFF is too low, then even if you have a high
CUTOFF, all Gaussians will be mapped onto the coarsest level of the multi-grid,
and thus the effective integration grid for the calculation may still be too
coarse. By default 50Ry is chosen, which should be sufficient given the cutoff is
large enough.</p></li>
<li><p><strong>ngrids</strong> (<em>int</em>) – number of multi-grids to use. CP2K default is 4, but the molopt basis
files recommend 5.</p></li>
<li><p><strong>progression_factor</strong> (<em>int</em>) – Divisor of CUTOFF to get the cutoff for the next level of
the multigrid.</p></li>
<li><p><strong>wfn_restart_file_name</strong> (<em>str</em>) – RESTART file for the initial wavefunction guess.</p></li>
<li><p><strong>kpoints</strong> (<a class="reference internal" href="pymatgen.io.cp2k.inputs.html#pymatgen.io.cp2k.inputs.Kpoints" title="pymatgen.io.cp2k.inputs.Kpoints"><em>Kpoints</em></a>) – kpoints object from pymatgen.io.vasp.inputs.Kpoints. By default,
CP2K runs with gamma point only.</p></li>
<li><p><strong>smearing</strong> (<em>bool</em>) – whether or not to activate smearing (should be done for systems
containing no (or a very small) band gap.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.HybridRelaxSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HybridRelaxSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1392-L1397"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.HybridRelaxSet" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.io.cp2k.sets.DftSet" title="pymatgen.io.cp2k.sets.DftSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">DftSet</span></code></a></p>
<p>Quick Constructor for hybrid geometry relaxation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> – Pymatgen structure or molecule object</p></li>
<li><p><strong>ot</strong> (<em>bool</em>) – Whether or not to use orbital transformation method for matrix
diagonalization. OT is the flagship scf solver of CP2K, and will provide
speed-ups for this part of the calculation, but the system must have a band gap
for OT to be used (higher band-gap –&gt; faster convergence).</p></li>
<li><p><strong>energy_gap</strong> (<em>float</em>) – Estimate of energy gap for pre-conditioner. Default is -1, leaving
it up to cp2k.</p></li>
<li><p><strong>eps_default</strong> (<em>float</em>) – Replaces all EPS_XX Keywords in the DFT section value, ensuring
an overall accuracy of at least this much.</p></li>
<li><p><strong>eps_scf</strong> (<em>float</em>) – <p>The convergence criteria for leaving the SCF loop. Default is 1e-6.
Should ensure reasonable results, but is not applicable to all situations.</p>
<blockquote>
<div><p>Note: eps_scf is <em>not</em> in units of energy, as in most DFT codes. For OT method,
it is the largest gradient of the energy with respect to changing any of the
molecular orbital coefficients. For diagonalization, it is the largest change
in the density matrix from the last step.</p>
</div></blockquote>
</p></li>
<li><p><strong>max_scf</strong> (<em>int</em>) – The max number of SCF cycles before terminating the solver. NOTE: With
the OT solver, this corresponds to the max number of INNER scf loops, and then
the outer loops are set with outer_max_scf, while with diagonalization it
corresponds to the overall (INNER*OUTER) number of SCF steps, with the
inner loop limit set by</p></li>
<li><p><strong>minimizer</strong> (<em>str</em>) – The minimization scheme. DIIS can be as much as 50% faster than the
more robust conjugate gradient method, and so it is chosen as default. Switch to CG
if dealing with a difficult system.</p></li>
<li><p><strong>preconditioner</strong> (<em>str</em>) – Pre-conditioner for the OT method. FULL_SINGLE_INVERSE is very
robust and compatible with non-integer occupations from IRAC+rotation. FULL_ALL is
considered “best” but needs algorithm to be set to STRICT. Only change from these
two when simulation cell gets to be VERY large, in which case FULL_KINETIC might be
preferred.</p></li>
<li><p><strong>algorithm</strong> (<em>str</em>) – Algorithm for the OT method. STRICT assumes that the orbitals are
strictly orthogonal to each other, which works well for wide gap ionic systems,
but can diverge for systems with small gaps, fractional occupations, and some
other cases. IRAC (iterative refinement of the approximate congruency)
transformation is not analytically correct and uses a truncated polynomial
expansion, but is robust to the problems with STRICT, and so is the default.</p></li>
<li><p><strong>linesearch</strong> (<em>str</em>) – Linesearch method for CG. 2PNT is the default, and is the fastest,
but is not as robust as 3PNT. 2PNT is required as of cp2k v9.1 for compatibility
with irac+rotation. This may be upgraded in the future. 3PNT can be good for wide
gapped transition metal systems as an alternative.</p></li>
<li><p><strong>rotation</strong> (<em>bool</em>) – Whether or not to allow for rotation of the orbitals in the OT method.
This equates to allowing for fractional occupations in the calculation.</p></li>
<li><p><strong>occupation_preconditioner</strong> (<em>bool</em>) – Whether or not to account for fractional occupations
in the preconditioner. This method is not fully integrated as of cp2k v9.1 and is
set to false by default.</p></li>
<li><p><strong>cutoff</strong> (<em>int</em>) – Cutoff energy (in Ry) for the finest level of the multigrid. A high
cutoff will allow you to have very accurate calculations PROVIDED that REL_CUTOFF
is appropriate. By default cutoff is set to 0, leaving it up to the set.</p></li>
<li><p><strong>rel_cutoff</strong> (<em>int</em>) – This cutoff decides how the Gaussians are mapped onto the different
levels of the multigrid. If REL_CUTOFF is too low, then even if you have a high
CUTOFF, all Gaussians will be mapped onto the coarsest level of the multi-grid,
and thus the effective integration grid for the calculation may still be too
coarse. By default 50Ry is chosen, which should be sufficient given the cutoff is
large enough.</p></li>
<li><p><strong>ngrids</strong> (<em>int</em>) – number of multi-grids to use. CP2K default is 4, but the molopt basis
files recommend 5.</p></li>
<li><p><strong>progression_factor</strong> (<em>int</em>) – Divisor of CUTOFF to get the cutoff for the next level of
the multigrid.</p></li>
<li><p><strong>wfn_restart_file_name</strong> (<em>str</em>) – RESTART file for the initial wavefunction guess.</p></li>
<li><p><strong>kpoints</strong> (<a class="reference internal" href="pymatgen.io.cp2k.inputs.html#pymatgen.io.cp2k.inputs.Kpoints" title="pymatgen.io.cp2k.inputs.Kpoints"><em>Kpoints</em></a>) – kpoints object from pymatgen.io.vasp.inputs.Kpoints. By default,
CP2K runs with gamma point only.</p></li>
<li><p><strong>smearing</strong> (<em>bool</em>) – whether or not to activate smearing (should be done for systems
containing no (or a very small) band gap.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.HybridStaticSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HybridStaticSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1384-L1389"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.HybridStaticSet" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.io.cp2k.sets.DftSet" title="pymatgen.io.cp2k.sets.DftSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">DftSet</span></code></a></p>
<p>Quick Constructor for static calculations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> – Pymatgen structure or molecule object</p></li>
<li><p><strong>ot</strong> (<em>bool</em>) – Whether or not to use orbital transformation method for matrix
diagonalization. OT is the flagship scf solver of CP2K, and will provide
speed-ups for this part of the calculation, but the system must have a band gap
for OT to be used (higher band-gap –&gt; faster convergence).</p></li>
<li><p><strong>energy_gap</strong> (<em>float</em>) – Estimate of energy gap for pre-conditioner. Default is -1, leaving
it up to cp2k.</p></li>
<li><p><strong>eps_default</strong> (<em>float</em>) – Replaces all EPS_XX Keywords in the DFT section value, ensuring
an overall accuracy of at least this much.</p></li>
<li><p><strong>eps_scf</strong> (<em>float</em>) – <p>The convergence criteria for leaving the SCF loop. Default is 1e-6.
Should ensure reasonable results, but is not applicable to all situations.</p>
<blockquote>
<div><p>Note: eps_scf is <em>not</em> in units of energy, as in most DFT codes. For OT method,
it is the largest gradient of the energy with respect to changing any of the
molecular orbital coefficients. For diagonalization, it is the largest change
in the density matrix from the last step.</p>
</div></blockquote>
</p></li>
<li><p><strong>max_scf</strong> (<em>int</em>) – The max number of SCF cycles before terminating the solver. NOTE: With
the OT solver, this corresponds to the max number of INNER scf loops, and then
the outer loops are set with outer_max_scf, while with diagonalization it
corresponds to the overall (INNER*OUTER) number of SCF steps, with the
inner loop limit set by</p></li>
<li><p><strong>minimizer</strong> (<em>str</em>) – The minimization scheme. DIIS can be as much as 50% faster than the
more robust conjugate gradient method, and so it is chosen as default. Switch to CG
if dealing with a difficult system.</p></li>
<li><p><strong>preconditioner</strong> (<em>str</em>) – Pre-conditioner for the OT method. FULL_SINGLE_INVERSE is very
robust and compatible with non-integer occupations from IRAC+rotation. FULL_ALL is
considered “best” but needs algorithm to be set to STRICT. Only change from these
two when simulation cell gets to be VERY large, in which case FULL_KINETIC might be
preferred.</p></li>
<li><p><strong>algorithm</strong> (<em>str</em>) – Algorithm for the OT method. STRICT assumes that the orbitals are
strictly orthogonal to each other, which works well for wide gap ionic systems,
but can diverge for systems with small gaps, fractional occupations, and some
other cases. IRAC (iterative refinement of the approximate congruency)
transformation is not analytically correct and uses a truncated polynomial
expansion, but is robust to the problems with STRICT, and so is the default.</p></li>
<li><p><strong>linesearch</strong> (<em>str</em>) – Linesearch method for CG. 2PNT is the default, and is the fastest,
but is not as robust as 3PNT. 2PNT is required as of cp2k v9.1 for compatibility
with irac+rotation. This may be upgraded in the future. 3PNT can be good for wide
gapped transition metal systems as an alternative.</p></li>
<li><p><strong>rotation</strong> (<em>bool</em>) – Whether or not to allow for rotation of the orbitals in the OT method.
This equates to allowing for fractional occupations in the calculation.</p></li>
<li><p><strong>occupation_preconditioner</strong> (<em>bool</em>) – Whether or not to account for fractional occupations
in the preconditioner. This method is not fully integrated as of cp2k v9.1 and is
set to false by default.</p></li>
<li><p><strong>cutoff</strong> (<em>int</em>) – Cutoff energy (in Ry) for the finest level of the multigrid. A high
cutoff will allow you to have very accurate calculations PROVIDED that REL_CUTOFF
is appropriate. By default cutoff is set to 0, leaving it up to the set.</p></li>
<li><p><strong>rel_cutoff</strong> (<em>int</em>) – This cutoff decides how the Gaussians are mapped onto the different
levels of the multigrid. If REL_CUTOFF is too low, then even if you have a high
CUTOFF, all Gaussians will be mapped onto the coarsest level of the multi-grid,
and thus the effective integration grid for the calculation may still be too
coarse. By default 50Ry is chosen, which should be sufficient given the cutoff is
large enough.</p></li>
<li><p><strong>ngrids</strong> (<em>int</em>) – number of multi-grids to use. CP2K default is 4, but the molopt basis
files recommend 5.</p></li>
<li><p><strong>progression_factor</strong> (<em>int</em>) – Divisor of CUTOFF to get the cutoff for the next level of
the multigrid.</p></li>
<li><p><strong>wfn_restart_file_name</strong> (<em>str</em>) – RESTART file for the initial wavefunction guess.</p></li>
<li><p><strong>kpoints</strong> (<a class="reference internal" href="pymatgen.io.cp2k.inputs.html#pymatgen.io.cp2k.inputs.Kpoints" title="pymatgen.io.cp2k.inputs.Kpoints"><em>Kpoints</em></a>) – kpoints object from pymatgen.io.vasp.inputs.Kpoints. By default,
CP2K runs with gamma point only.</p></li>
<li><p><strong>smearing</strong> (<em>bool</em>) – whether or not to activate smearing (should be done for systems
containing no (or a very small) band gap.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.RelaxSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RelaxSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1368-L1373"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.RelaxSet" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.io.cp2k.sets.DftSet" title="pymatgen.io.cp2k.sets.DftSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">DftSet</span></code></a></p>
<p>Quick Constructor for geometry relaxation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> – Pymatgen structure or molecule object</p></li>
<li><p><strong>ot</strong> (<em>bool</em>) – Whether or not to use orbital transformation method for matrix
diagonalization. OT is the flagship scf solver of CP2K, and will provide
speed-ups for this part of the calculation, but the system must have a band gap
for OT to be used (higher band-gap –&gt; faster convergence).</p></li>
<li><p><strong>energy_gap</strong> (<em>float</em>) – Estimate of energy gap for pre-conditioner. Default is -1, leaving
it up to cp2k.</p></li>
<li><p><strong>eps_default</strong> (<em>float</em>) – Replaces all EPS_XX Keywords in the DFT section value, ensuring
an overall accuracy of at least this much.</p></li>
<li><p><strong>eps_scf</strong> (<em>float</em>) – <p>The convergence criteria for leaving the SCF loop. Default is 1e-6.
Should ensure reasonable results, but is not applicable to all situations.</p>
<blockquote>
<div><p>Note: eps_scf is <em>not</em> in units of energy, as in most DFT codes. For OT method,
it is the largest gradient of the energy with respect to changing any of the
molecular orbital coefficients. For diagonalization, it is the largest change
in the density matrix from the last step.</p>
</div></blockquote>
</p></li>
<li><p><strong>max_scf</strong> (<em>int</em>) – The max number of SCF cycles before terminating the solver. NOTE: With
the OT solver, this corresponds to the max number of INNER scf loops, and then
the outer loops are set with outer_max_scf, while with diagonalization it
corresponds to the overall (INNER*OUTER) number of SCF steps, with the
inner loop limit set by</p></li>
<li><p><strong>minimizer</strong> (<em>str</em>) – The minimization scheme. DIIS can be as much as 50% faster than the
more robust conjugate gradient method, and so it is chosen as default. Switch to CG
if dealing with a difficult system.</p></li>
<li><p><strong>preconditioner</strong> (<em>str</em>) – Pre-conditioner for the OT method. FULL_SINGLE_INVERSE is very
robust and compatible with non-integer occupations from IRAC+rotation. FULL_ALL is
considered “best” but needs algorithm to be set to STRICT. Only change from these
two when simulation cell gets to be VERY large, in which case FULL_KINETIC might be
preferred.</p></li>
<li><p><strong>algorithm</strong> (<em>str</em>) – Algorithm for the OT method. STRICT assumes that the orbitals are
strictly orthogonal to each other, which works well for wide gap ionic systems,
but can diverge for systems with small gaps, fractional occupations, and some
other cases. IRAC (iterative refinement of the approximate congruency)
transformation is not analytically correct and uses a truncated polynomial
expansion, but is robust to the problems with STRICT, and so is the default.</p></li>
<li><p><strong>linesearch</strong> (<em>str</em>) – Linesearch method for CG. 2PNT is the default, and is the fastest,
but is not as robust as 3PNT. 2PNT is required as of cp2k v9.1 for compatibility
with irac+rotation. This may be upgraded in the future. 3PNT can be good for wide
gapped transition metal systems as an alternative.</p></li>
<li><p><strong>rotation</strong> (<em>bool</em>) – Whether or not to allow for rotation of the orbitals in the OT method.
This equates to allowing for fractional occupations in the calculation.</p></li>
<li><p><strong>occupation_preconditioner</strong> (<em>bool</em>) – Whether or not to account for fractional occupations
in the preconditioner. This method is not fully integrated as of cp2k v9.1 and is
set to false by default.</p></li>
<li><p><strong>cutoff</strong> (<em>int</em>) – Cutoff energy (in Ry) for the finest level of the multigrid. A high
cutoff will allow you to have very accurate calculations PROVIDED that REL_CUTOFF
is appropriate. By default cutoff is set to 0, leaving it up to the set.</p></li>
<li><p><strong>rel_cutoff</strong> (<em>int</em>) – This cutoff decides how the Gaussians are mapped onto the different
levels of the multigrid. If REL_CUTOFF is too low, then even if you have a high
CUTOFF, all Gaussians will be mapped onto the coarsest level of the multi-grid,
and thus the effective integration grid for the calculation may still be too
coarse. By default 50Ry is chosen, which should be sufficient given the cutoff is
large enough.</p></li>
<li><p><strong>ngrids</strong> (<em>int</em>) – number of multi-grids to use. CP2K default is 4, but the molopt basis
files recommend 5.</p></li>
<li><p><strong>progression_factor</strong> (<em>int</em>) – Divisor of CUTOFF to get the cutoff for the next level of
the multigrid.</p></li>
<li><p><strong>wfn_restart_file_name</strong> (<em>str</em>) – RESTART file for the initial wavefunction guess.</p></li>
<li><p><strong>kpoints</strong> (<a class="reference internal" href="pymatgen.io.cp2k.inputs.html#pymatgen.io.cp2k.inputs.Kpoints" title="pymatgen.io.cp2k.inputs.Kpoints"><em>Kpoints</em></a>) – kpoints object from pymatgen.io.vasp.inputs.Kpoints. By default,
CP2K runs with gamma point only.</p></li>
<li><p><strong>smearing</strong> (<em>bool</em>) – whether or not to activate smearing (should be done for systems
containing no (or a very small) band gap.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymatgen.io.cp2k.sets.StaticSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">StaticSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2023.1.20/pymatgen/core/../io/cp2k/sets.py#L1361-L1365"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.io.cp2k.sets.StaticSet" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pymatgen.io.cp2k.sets.DftSet" title="pymatgen.io.cp2k.sets.DftSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">DftSet</span></code></a></p>
<p>Quick Constructor for static calculations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> – Pymatgen structure or molecule object</p></li>
<li><p><strong>ot</strong> (<em>bool</em>) – Whether or not to use orbital transformation method for matrix
diagonalization. OT is the flagship scf solver of CP2K, and will provide
speed-ups for this part of the calculation, but the system must have a band gap
for OT to be used (higher band-gap –&gt; faster convergence).</p></li>
<li><p><strong>energy_gap</strong> (<em>float</em>) – Estimate of energy gap for pre-conditioner. Default is -1, leaving
it up to cp2k.</p></li>
<li><p><strong>eps_default</strong> (<em>float</em>) – Replaces all EPS_XX Keywords in the DFT section value, ensuring
an overall accuracy of at least this much.</p></li>
<li><p><strong>eps_scf</strong> (<em>float</em>) – <p>The convergence criteria for leaving the SCF loop. Default is 1e-6.
Should ensure reasonable results, but is not applicable to all situations.</p>
<blockquote>
<div><p>Note: eps_scf is <em>not</em> in units of energy, as in most DFT codes. For OT method,
it is the largest gradient of the energy with respect to changing any of the
molecular orbital coefficients. For diagonalization, it is the largest change
in the density matrix from the last step.</p>
</div></blockquote>
</p></li>
<li><p><strong>max_scf</strong> (<em>int</em>) – The max number of SCF cycles before terminating the solver. NOTE: With
the OT solver, this corresponds to the max number of INNER scf loops, and then
the outer loops are set with outer_max_scf, while with diagonalization it
corresponds to the overall (INNER*OUTER) number of SCF steps, with the
inner loop limit set by</p></li>
<li><p><strong>minimizer</strong> (<em>str</em>) – The minimization scheme. DIIS can be as much as 50% faster than the
more robust conjugate gradient method, and so it is chosen as default. Switch to CG
if dealing with a difficult system.</p></li>
<li><p><strong>preconditioner</strong> (<em>str</em>) – Pre-conditioner for the OT method. FULL_SINGLE_INVERSE is very
robust and compatible with non-integer occupations from IRAC+rotation. FULL_ALL is
considered “best” but needs algorithm to be set to STRICT. Only change from these
two when simulation cell gets to be VERY large, in which case FULL_KINETIC might be
preferred.</p></li>
<li><p><strong>algorithm</strong> (<em>str</em>) – Algorithm for the OT method. STRICT assumes that the orbitals are
strictly orthogonal to each other, which works well for wide gap ionic systems,
but can diverge for systems with small gaps, fractional occupations, and some
other cases. IRAC (iterative refinement of the approximate congruency)
transformation is not analytically correct and uses a truncated polynomial
expansion, but is robust to the problems with STRICT, and so is the default.</p></li>
<li><p><strong>linesearch</strong> (<em>str</em>) – Linesearch method for CG. 2PNT is the default, and is the fastest,
but is not as robust as 3PNT. 2PNT is required as of cp2k v9.1 for compatibility
with irac+rotation. This may be upgraded in the future. 3PNT can be good for wide
gapped transition metal systems as an alternative.</p></li>
<li><p><strong>rotation</strong> (<em>bool</em>) – Whether or not to allow for rotation of the orbitals in the OT method.
This equates to allowing for fractional occupations in the calculation.</p></li>
<li><p><strong>occupation_preconditioner</strong> (<em>bool</em>) – Whether or not to account for fractional occupations
in the preconditioner. This method is not fully integrated as of cp2k v9.1 and is
set to false by default.</p></li>
<li><p><strong>cutoff</strong> (<em>int</em>) – Cutoff energy (in Ry) for the finest level of the multigrid. A high
cutoff will allow you to have very accurate calculations PROVIDED that REL_CUTOFF
is appropriate. By default cutoff is set to 0, leaving it up to the set.</p></li>
<li><p><strong>rel_cutoff</strong> (<em>int</em>) – This cutoff decides how the Gaussians are mapped onto the different
levels of the multigrid. If REL_CUTOFF is too low, then even if you have a high
CUTOFF, all Gaussians will be mapped onto the coarsest level of the multi-grid,
and thus the effective integration grid for the calculation may still be too
coarse. By default 50Ry is chosen, which should be sufficient given the cutoff is
large enough.</p></li>
<li><p><strong>ngrids</strong> (<em>int</em>) – number of multi-grids to use. CP2K default is 4, but the molopt basis
files recommend 5.</p></li>
<li><p><strong>progression_factor</strong> (<em>int</em>) – Divisor of CUTOFF to get the cutoff for the next level of
the multigrid.</p></li>
<li><p><strong>wfn_restart_file_name</strong> (<em>str</em>) – RESTART file for the initial wavefunction guess.</p></li>
<li><p><strong>kpoints</strong> (<a class="reference internal" href="pymatgen.io.cp2k.inputs.html#pymatgen.io.cp2k.inputs.Kpoints" title="pymatgen.io.cp2k.inputs.Kpoints"><em>Kpoints</em></a>) – kpoints object from pymatgen.io.vasp.inputs.Kpoints. By default,
CP2K runs with gamma point only.</p></li>
<li><p><strong>smearing</strong> (<em>bool</em>) – whether or not to activate smearing (should be done for systems
containing no (or a very small) band gap.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2011, Pymatgen Development Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>


</body>
</html>