

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pymatgen.analysis.gb.grain module &mdash; pymatgen 2022.0.8 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  
  
  
    <link rel="canonical" href="https://pymatgen.orgpymatgen.analysis.gb.grain.html"/>
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pymatgen.analysis.magnetism package" href="pymatgen.analysis.magnetism.html" />
    <link rel="prev" title="pymatgen.analysis.gb package" href="pymatgen.analysis.gb.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: linear-gradient(0deg, rgba(23,63,162,1) 0%, rgba(0,70,192,1) 100%)" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> pymatgen
          

          
          </a>

          
            
            
              <div class="version">
                2022.0.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="change_log.html">Change log</a></li>
<li class="toctree-l1"><a class="reference internal" href="compatibility.html">Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="team.html">Development Team</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">API Docs</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="pymatgen.html">pymatgen namespace</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="pymatgen.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="pymatgen.alchemy.html">pymatgen.alchemy package</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="pymatgen.analysis.html">pymatgen.analysis namespace</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.apps.html">pymatgen.apps package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.cli.html">pymatgen.cli package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.command_line.html">pymatgen.command_line package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.core.html">pymatgen.core package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.electronic_structure.html">pymatgen.electronic_structure package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.entries.html">pymatgen.entries package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.ext.html">pymatgen.ext namespace</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.io.html">pymatgen.io namespace</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.optimization.html">pymatgen.optimization package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.phonon.html">pymatgen.phonon package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.symmetry.html">pymatgen.symmetry package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.transformations.html">pymatgen.transformations package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.util.html">pymatgen.util package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pymatgen.vis.html">pymatgen.vis package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pymatgen.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pymatgen</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="modules.html">pymatgen</a> &raquo;</li>
        
          <li><a href="pymatgen.html">pymatgen namespace</a> &raquo;</li>
        
          <li><a href="pymatgen.analysis.html">pymatgen.analysis namespace</a> &raquo;</li>
        
          <li><a href="pymatgen.analysis.gb.html">pymatgen.analysis.gb package</a> &raquo;</li>
        
      <li>pymatgen.analysis.gb.grain module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/materialsproject/pymatgen/blob/master/docs_rst/pymatgen.analysis.gb.grain.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pymatgen.analysis.gb.grain">
<span id="pymatgen-analysis-gb-grain-module"></span><h1>pymatgen.analysis.gb.grain module<a class="headerlink" href="#module-pymatgen.analysis.gb.grain" title="Permalink to this headline">Â¶</a></h1>
<p>Module containing classes to generate grain boundaries.</p>
<dl class="py class">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundary">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">GrainBoundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lattice</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">species</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gb_plane</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">join_plane</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vacuum_thickness</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ab_shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">site_properties</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oriented_unit_cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_proximity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords_are_cartesian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L37-L320"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundary" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pymatgen.core.structure.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymatgen.core.structure.Structure</span></code></a></p>
<p>Subclass of Structure representing a GrainBoundary (gb) object.
Implements additional attributes pertaining to gbs, but the
init method does not actually implement any algorithm that
creates a gb. This is a DUMMY class whoâs init method only holds
information about the gb. Also has additional methods that returns
other information about a gb such as sigma value.</p>
<p>Note that all gbs have the gb surface normal oriented in the c-direction.
This means the lattice vectors a and b are in the gb surface plane (at</p>
<blockquote>
<div><p>least for one grain) and the c vector is out of the surface plane
(though not necessary perpendicular to the surface.)</p>
</div></blockquote>
<p>Makes a gb structure, a structure object with additional information
and methods pertaining to gbs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lattice</strong> (<em>Lattice/3x3 array</em>) â The lattice, either as a
<a class="reference internal" href="pymatgen.core.lattice.html#pymatgen.core.lattice.Lattice" title="pymatgen.core.lattice.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">pymatgen.core.lattice.Lattice</span></code></a> or
simply as any 2D array. Each row should correspond to a lattice
vector. E.g., [[10,0,0], [20,10,0], [0,0,30]] specifies a
lattice with lattice vectors [10,0,0], [20,10,0] and [0,0,30].</p></li>
<li><p><strong>species</strong> (<em>[</em><a class="reference internal" href="pymatgen.core.periodic_table.html#pymatgen.core.periodic_table.Species" title="pymatgen.core.periodic_table.Species"><em>Species</em></a><em>]</em>) â <p>Sequence of species on each site. Can take in
flexible input, including:</p>
<ol class="lowerroman simple">
<li><p>A sequence of element / species specified either as string
symbols, e.g. [âLiâ, âFe2+â, âPâ, â¦] or atomic numbers,
e.g., (3, 56, â¦) or actual Element or Species objects.</p></li>
<li><p>List of dict of elements/species and occupancies, e.g.,
[{âFeâ : 0.5, âMnâ:0.5}, â¦]. This allows the setup of
disordered structures.</p></li>
</ol>
</p></li>
<li><p><strong>coords</strong> (<em>Nx3 array</em>) â list of fractional/cartesian coordinates of
each species.</p></li>
<li><p><strong>rotation_axis</strong> (<em>list</em>) â Rotation axis of GB in the form of a list of
integers, e.g. [1, 1, 0].</p></li>
<li><p><strong>rotation_angle</strong> (<em>float</em><em>, </em><em>in unit of degree</em>) â rotation angle of GB.</p></li>
<li><p><strong>gb_plane</strong> (<em>list</em>) â Grain boundary plane in the form of a list of integers
e.g.: [1, 2, 3].</p></li>
<li><p><strong>join_plane</strong> (<em>list</em>) â Joining plane of the second grain in the form of a list of
integers. e.g.: [1, 2, 3].</p></li>
<li><p><strong>init_cell</strong> (<a class="reference internal" href="pymatgen.core.structure.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) â initial bulk structure to form the GB.</p></li>
<li><p><strong>site_properties</strong> (<em>dict</em>) â Properties associated with the sites as a
dict of sequences, The sequences have to be the same length as
the atomic species and fractional_coords. For gb, you should
have the âgrain_labelâ properties to classify the sites as âtopâ,
âbottomâ, âtop_incidentâ, or âbottom_incidentâ.</p></li>
<li><p><strong>vacuum_thickness</strong> (<em>float in angstrom</em>) â The thickness of vacuum inserted
between two grains of the GB.</p></li>
<li><p><strong>ab_shift</strong> (<em>list of float</em><em>, </em><em>in unit of crystal vector a</em><em>, </em><em>b</em>) â The relative
shift along a, b vectors.</p></li>
<li><p><strong>oriented_unit_cell</strong> (<a class="reference internal" href="pymatgen.core.structure.html#pymatgen.core.structure.Structure" title="pymatgen.core.structure.Structure"><em>Structure</em></a>) â oriented unit cell of the bulk init_cell.
Help to accurate calculate the bulk properties that are consistent
with gb calculations.</p></li>
<li><p><strong>validate_proximity</strong> (<em>bool</em>) â Whether to check if there are sites
that are less than 0.01 Ang apart. Defaults to False.</p></li>
<li><p><strong>coords_are_cartesian</strong> (<em>bool</em>) â Set to True if you are providing
coordinates in cartesian coordinates. Defaults to False.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundary.as_dict">
<span class="sig-name descname"><span class="pre">as_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L274-L290"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundary.as_dict" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Dictionary representation of GrainBoundary object</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundary.bottom_grain">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">bottom_grain</span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/analysis/gb/grain.py"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundary.bottom_grain" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return the bottom grain (Structure) of the GB.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundary.coincidents">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">coincidents</span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/analysis/gb/grain.py"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundary.coincidents" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return the a list of coincident sites.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundary.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L133-L155"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundary.copy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convenience method to get a copy of the structure, with options to add
site properties.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A copy of the Structure, with optionally new site_properties and
optionally sanitized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundary.from_dict">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">from_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L292-L320"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundary.from_dict" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Generates a GrainBoundary object from a dictionary created by as_dict().</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>d</strong> â dict</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>GrainBoundary object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundary.get_sorted_structure">
<span class="sig-name descname"><span class="pre">get_sorted_structure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L157-L185"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundary.get_sorted_structure" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get a sorted copy of the structure. The parameters have the same
meaning as in list.sort. By default, sites are sorted by the
electronegativity of the species. Note that Slab has to override this
because of the different __init__ args.
:param key: Specifies a function of one argument that is used to extract</p>
<blockquote>
<div><p>a comparison key from each list element: key=str.lower. The
default value is None (compare the elements directly).</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>reverse</strong> (<em>bool</em>) â If set to True, then the list elements are sorted
as if each comparison were reversed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundary.sigma">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">sigma</span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/analysis/gb/grain.py"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundary.sigma" title="Permalink to this definition">Â¶</a></dt>
<dd><p>This method returns the sigma value of the gb.
If using âquick_genâ to generate GB, this value is not valid.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundary.sigma_from_site_prop">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">sigma_from_site_prop</span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/analysis/gb/grain.py"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundary.sigma_from_site_prop" title="Permalink to this definition">Â¶</a></dt>
<dd><p>This method returns the sigma value of the gb from site properties.
If the GB structure merge some atoms due to the atoms too closer with
each other, this property will not work.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundary.top_grain">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">top_grain</span></span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/analysis/gb/grain.py"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundary.top_grain" title="Permalink to this definition">Â¶</a></dt>
<dd><p>return the top grain (Structure) of the GB.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">GrainBoundaryGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_structure</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symprec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L323-L2370"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class is to generate grain boundaries (GBs) from bulk
conventional cell (fcc, bcc can from the primitive cell), and works for Cubic,
Tetragonal, Orthorhombic, Rhombohedral, and Hexagonal systems.
It generate GBs from given parameters, which includes
GB plane, rotation axis, rotation angle.</p>
<p>This class works for any general GB, including twist, tilt and mixed GBs.
The three parameters, rotation axis, GB plane and rotation angle, are
sufficient to identify one unique GB. While sometimes, users may not be able
to tell what exactly rotation angle is but prefer to use sigma as an parameter,
this class also provides the function that is able to return all possible
rotation angles for a specific sigma value.
The same sigma value (with rotation axis fixed) can correspond to
multiple rotation angles.
Users can use structure matcher in pymatgen to get rid of the redundant structures.</p>
<dl class="simple">
<dt>initial_structure (Structure): Initial input structure. It can</dt><dd><p>be conventional or primitive cell (primitive cell works for bcc and fcc).
For fcc and bcc, using conventional cell can lead to a non-primitive
grain boundary structure.
This code supplies Cubic, Tetragonal, Orthorhombic, Rhombohedral, and
Hexagonal systems.</p>
</dd>
<dt>symprec (float): Tolerance for symmetry finding. Defaults to 0.1 (the value used</dt><dd><p>in Materials Project), which is for structures with slight deviations
from their proper atomic positions (e.g., structures relaxed with
electronic structure codes).
A smaller value of 0.01 is often used for properly refined
structures with atoms in the proper symmetry coordinates.
User should make sure the symmetry is what you want.</p>
</dd>
</dl>
<p>angle_tolerance (float): Angle tolerance for symmetry finding.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.enum_possible_plane_cubic">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">enum_possible_plane_cubic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plane_cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_angle</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L1929-L1994"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.enum_possible_plane_cubic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Find all possible plane combinations for GBs given a rotaion axis and angle for
cubic system, and classify them to different categories, including âTwistâ,
âSymmetric tiltâ, âNormal tiltâ, âMixedâ GBs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plane_cutoff</strong> (<em>integer</em>) â the cutoff of plane miller index.</p></li>
<li><p><strong>r_axis</strong> (<em>list of three integers</em><em>, </em><em>e.g. u</em><em>, </em><em>v</em><em>, </em><em>w</em>) â the rotation axis of the grain boundary, with the format of [u,v,w].</p></li>
<li><p><strong>r_angle</strong> (<em>float</em>) â rotation angle of the GBs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>dictionary with keys as GB type, e.g. âTwistâ,âSymmetric tiltâ,etc.
and values as the combination of the two plane miller index</p>
<blockquote>
<div><p>(GB plane and joining plane).</p>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>all_combinations (dict)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.enum_sigma_cubic">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">enum_sigma_cubic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_axis</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L1333-L1407"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.enum_sigma_cubic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Find all possible sigma values and corresponding rotation angles
within a sigma value cutoff with known rotation axis in cubic system.
The algorithm for this code is from reference, Acta Cryst, A40,108(1984)
:param cutoff: the cutoff of sigma values.
:type cutoff: integer
:param r_axis: the rotation axis of the grain boundary, with the format of [u,v,w].
:type r_axis: list of three integers, e.g. u, v, w</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>dictionary with keys as the possible integer sigma values
and values as list of the possible rotation angles to the
corresponding sigma values.
e.g. the format as
{sigma1: [angle11,angle12,â¦], sigma2: [angle21, angle22,â¦],â¦}
Note: the angles are the rotation angles of one grain respect to
the other grain.
When generate the microstructures of the grain boundary using these angles,
you need to analyze the symmetry of the structure. Different angles may
result in equivalent microstructures.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>sigmas (dict)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.enum_sigma_hex">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">enum_sigma_hex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c2_a2_ratio</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L1409-L1528"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.enum_sigma_hex" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Find all possible sigma values and corresponding rotation angles
within a sigma value cutoff with known rotation axis in hexagonal system.
The algorithm for this code is from reference, Acta Cryst, A38,550(1982)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cutoff</strong> (<em>integer</em>) â the cutoff of sigma values.</p></li>
<li><p><strong>(</strong><strong>list of three integers</strong> (<em>r_axis</em>) â or four integers, e.g. u, v, t, w):
the rotation axis of the grain boundary.</p></li>
<li><p><strong>u</strong> (<em>e.g.</em>) â or four integers, e.g. u, v, t, w):
the rotation axis of the grain boundary.</p></li>
<li><p><strong>v</strong> â or four integers, e.g. u, v, t, w):
the rotation axis of the grain boundary.</p></li>
<li><p><strong>w</strong> â or four integers, e.g. u, v, t, w):
the rotation axis of the grain boundary.</p></li>
<li><p><strong>c2_a2_ratio</strong> (<em>list of two integers</em><em>, </em><em>e.g. mu</em><em>, </em><em>mv</em>) â mu/mv is the square of the hexagonal axial ratio, which is rational
number. If irrational, set c2_a2_ratio = None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dictionary with keys as the possible integer sigma values
and values as list of the possible rotation angles to the
corresponding sigma values.
e.g. the format as
{sigma1: [angle11,angle12,â¦], sigma2: [angle21, angle22,â¦],â¦}
Note: the angles are the rotation angle of one grain respect to the
other grain.
When generate the microstructure of the grain boundary using these
angles, you need to analyze the symmetry of the structure. Different
angles may result in equivalent microstructures.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sigmas (dict)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.enum_sigma_ort">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">enum_sigma_ort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c2_b2_a2_ratio</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L1783-L1927"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.enum_sigma_ort" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Find all possible sigma values and corresponding rotation angles
within a sigma value cutoff with known rotation axis in orthorhombic system.
The algorithm for this code is from reference, Scipta Metallurgica 27, 291(1992)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cutoff</strong> (<em>integer</em>) â the cutoff of sigma values.</p></li>
<li><p><strong>r_axis</strong> (<em>list of three integers</em><em>, </em><em>e.g. u</em><em>, </em><em>v</em><em>, </em><em>w</em>) â the rotation axis of the grain boundary, with the format of [u,v,w].</p></li>
<li><p><strong>c2_b2_a2_ratio</strong> (<em>list of three integers</em><em>, </em><em>e.g. mu</em><em>,</em><em>lamda</em><em>, </em><em>mv</em>) â mu:lam:mv is the square of the orthorhombic axial ratio with rational
numbers. If irrational for one axis, set it to None.
e.g. mu:lam:mv = c2,None,a2, means b2 is irrational.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dictionary with keys as the possible integer sigma values
and values as list of the possible rotation angles to the
corresponding sigma values.
e.g. the format as
{sigma1: [angle11,angle12,â¦], sigma2: [angle21, angle22,â¦],â¦}
Note: the angles are the rotation angle of one grain respect to the
other grain.
When generate the microstructure of the grain boundary using these
angles, you need to analyze the symmetry of the structure. Different
angles may result in equivalent microstructures.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sigmas (dict)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.enum_sigma_rho">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">enum_sigma_rho</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio_alpha</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L1530-L1668"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.enum_sigma_rho" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Find all possible sigma values and corresponding rotation angles
within a sigma value cutoff with known rotation axis in rhombohedral system.
The algorithm for this code is from reference, Acta Cryst, A45,505(1989).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cutoff</strong> (<em>integer</em>) â the cutoff of sigma values.</p></li>
<li><p><strong>(</strong><strong>list of three integers</strong> (<em>r_axis</em>) â or four integers, e.g. u, v, t, w):
the rotation axis of the grain boundary, with the format of [u,v,w]
or Weber indices [u, v, t, w].</p></li>
<li><p><strong>u</strong> (<em>e.g.</em>) â or four integers, e.g. u, v, t, w):
the rotation axis of the grain boundary, with the format of [u,v,w]
or Weber indices [u, v, t, w].</p></li>
<li><p><strong>v</strong> â or four integers, e.g. u, v, t, w):
the rotation axis of the grain boundary, with the format of [u,v,w]
or Weber indices [u, v, t, w].</p></li>
<li><p><strong>w</strong> â or four integers, e.g. u, v, t, w):
the rotation axis of the grain boundary, with the format of [u,v,w]
or Weber indices [u, v, t, w].</p></li>
<li><p><strong>ratio_alpha</strong> (<em>list of two integers</em><em>, </em><em>e.g. mu</em><em>, </em><em>mv</em>) â mu/mv is the ratio of (1+2*cos(alpha))/cos(alpha) with rational number.
If irrational, set ratio_alpha = None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dictionary with keys as the possible integer sigma values
and values as list of the possible rotation angles to the
corresponding sigma values.
e.g. the format as
{sigma1: [angle11,angle12,â¦], sigma2: [angle21, angle22,â¦],â¦}
Note: the angles are the rotation angle of one grain respect to the
other grain.
When generate the microstructure of the grain boundary using these
angles, you need to analyze the symmetry of the structure. Different
angles may result in equivalent microstructures.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sigmas (dict)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.enum_sigma_tet">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">enum_sigma_tet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cutoff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c2_a2_ratio</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L1670-L1781"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.enum_sigma_tet" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Find all possible sigma values and corresponding rotation angles
within a sigma value cutoff with known rotation axis in tetragonal system.
The algorithm for this code is from reference, Acta Cryst, B46,117(1990)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cutoff</strong> (<em>integer</em>) â the cutoff of sigma values.</p></li>
<li><p><strong>r_axis</strong> (<em>list of three integers</em><em>, </em><em>e.g. u</em><em>, </em><em>v</em><em>, </em><em>w</em>) â the rotation axis of the grain boundary, with the format of [u,v,w].</p></li>
<li><p><strong>c2_a2_ratio</strong> (<em>list of two integers</em><em>, </em><em>e.g. mu</em><em>, </em><em>mv</em>) â mu/mv is the square of the tetragonal axial ratio with rational number.
if irrational, set c2_a2_ratio = None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>dictionary with keys as the possible integer sigma values
and values as list of the possible rotation angles to the
corresponding sigma values.
e.g. the format as
{sigma1: [angle11,angle12,â¦], sigma2: [angle21, angle22,â¦],â¦}
Note: the angles are the rotation angle of one grain respect to the
other grain.
When generate the microstructure of the grain boundary using these
angles, you need to analyze the symmetry of the structure. Different
angles may result in equivalent microstructures.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sigmas (dict)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.gb_from_parameters">
<span class="sig-name descname"><span class="pre">gb_from_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotation_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vacuum_thickness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ab_shift</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0,</span> <span class="pre">0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_search</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_coi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rm_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quick_gen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L391-L809"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.gb_from_parameters" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rotation_axis</strong> (<em>list</em>) â Rotation axis of GB in the form of a list of integer
e.g.: [1, 1, 0]</p></li>
<li><p><strong>rotation_angle</strong> (<em>float</em><em>, </em><em>in unit of degree</em>) â rotation angle used to generate GB.
Make sure the angle is accurate enough. You can use the enum* functions
in this class to extract the accurate angle.
e.g.: The rotation angle of sigma 3 twist GB with the rotation axis
[1, 1, 1] and GB plane (1, 1, 1) can be 60.000000000 degree.
If you do not know the rotation angle, but know the sigma value, we have
provide the function get_rotation_angle_from_sigma which is able to return
all the rotation angles of sigma value you provided.</p></li>
<li><p><strong>expand_times</strong> (<em>int</em>) â The multiple times used to expand one unit grain to larger grain.
This is used to tune the grain length of GB to warrant that the two GBs in one
cell do not interact with each other. Default set to 4.</p></li>
<li><p><strong>vacuum_thickness</strong> (<em>float</em><em>, </em><em>in angstrom</em>) â The thickness of vacuum that you want to insert
between two grains of the GB. Default to 0.</p></li>
<li><p><strong>ab_shift</strong> (<em>list of float</em><em>, </em><em>in unit of a</em><em>, </em><em>b vectors of Gb</em>) â in plane shift of two grains</p></li>
<li><p><strong>normal</strong> (<em>logic</em>) â determine if need to require the c axis of top grain (first transformation matrix)
perperdicular to the surface or not.
default to false.</p></li>
<li><p><strong>ratio</strong> (<em>list of integers</em>) â lattice axial ratio.
For cubic system, ratio is not needed.
For tetragonal system, ratio = [mu, mv], list of two integers,
that is, mu/mv = c2/a2. If it is irrational, set it to none.
For orthorhombic system, ratio = [mu, lam, mv], list of three integers,
that is, mu:lam:mv = c2:b2:a2. If irrational for one axis, set it to None.
e.g. mu:lam:mv = c2,None,a2, means b2 is irrational.
For rhombohedral system, ratio = [mu, mv], list of two integers,
that is, mu/mv is the ratio of (1+2*cos(alpha))/cos(alpha).
If irrational, set it to None.
For hexagonal system, ratio = [mu, mv], list of two integers,
that is, mu/mv = c2/a2. If it is irrational, set it to none.
This code also supplies a class method to generate the ratio from the
structure (get_ratio). User can also make their own approximation and
input the ratio directly.</p></li>
<li><p><strong>plane</strong> (<em>list</em>) â Grain boundary plane in the form of a list of integers
e.g.: [1, 2, 3]. If none, we set it as twist GB. The plane will be perpendicular
to the rotation axis.</p></li>
<li><p><strong>max_search</strong> (<em>int</em>) â max search for the GB lattice vectors that give the smallest GB
lattice. If normal is true, also max search the GB c vector that perpendicular
to the plane. For complex GB, if you want to speed up, you can reduce this value.
But too small of this value may lead to error.</p></li>
<li><p><strong>tol_coi</strong> (<em>float</em>) â tolerance to find the coincidence sites. When making approximations to
the ratio needed to generate the GB, you probably need to increase this tolerance to
obtain the correct number of coincidence sites. To check the number of coincidence
sites are correct or not, you can compare the generated Gb objectâs sigma_from_site_prop
with enum* sigma values (what user expected by input).</p></li>
<li><p><strong>rm_ratio</strong> (<em>float</em>) â the criteria to remove the atoms which are too close with each other.
rm_ratio*bond_length of bulk system is the criteria of bond length, below which the atom
will be removed. Default to 0.7.</p></li>
<li><p><strong>quick_gen</strong> (<em>bool</em>) â whether to quickly generate a supercell, if set to true, no need to
find the smallest cell.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Grain boundary structure (gb object).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.get_ratio">
<span class="sig-name descname"><span class="pre">get_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_denominator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_none</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L811-L868"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.get_ratio" title="Permalink to this definition">Â¶</a></dt>
<dd><p>find the axial ratio needed for GB generator input.
:param max_denominator: the maximum denominator for</p>
<blockquote>
<div><p>the computed ratio, default to be 5.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>index_none</strong> (<em>int</em>) â specify the irrational axis.
0-a, 1-b, 2-c. Only may be needed for orthorhombic system.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>axial ratio needed for GB generator (list of integers).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.get_rotation_angle_from_sigma">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">get_rotation_angle_from_sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L1996-L2078"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.get_rotation_angle_from_sigma" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Find all possible rotation angle for the given sigma value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma</strong> (<em>integer</em>) â sigma value provided</p></li>
<li><p><strong>(</strong><strong>list of three integers</strong> (<em>r_axis</em>) â or four integers, e.g. u, v, t, w for hex/rho system only):
the rotation axis of the grain boundary.</p></li>
<li><p><strong>u</strong> (<em>e.g.</em>) â or four integers, e.g. u, v, t, w for hex/rho system only):
the rotation axis of the grain boundary.</p></li>
<li><p><strong>v</strong> â or four integers, e.g. u, v, t, w for hex/rho system only):
the rotation axis of the grain boundary.</p></li>
<li><p><strong>w</strong> â or four integers, e.g. u, v, t, w for hex/rho system only):
the rotation axis of the grain boundary.</p></li>
<li><p><strong>lat_type</strong> (<em>one character</em>) â <dl class="simple">
<dt>âcâ or âCâ: cubic system</dt><dd><p>âtâ or âTâ: tetragonal system
âoâ or âOâ: orthorhombic system
âhâ or âHâ: hexagonal system
ârâ or âRâ: rhombohedral system
default to cubic system</p>
</dd>
</dl>
</p></li>
<li><p><strong>ratio</strong> (<em>list of integers</em>) â lattice axial ratio.
For cubic system, ratio is not needed.
For tetragonal system, ratio = [mu, mv], list of two integers,
that is, mu/mv = c2/a2. If it is irrational, set it to none.
For orthorhombic system, ratio = [mu, lam, mv], list of three integers,
that is, mu:lam:mv = c2:b2:a2. If irrational for one axis, set it to None.
e.g. mu:lam:mv = c2,None,a2, means b2 is irrational.
For rhombohedral system, ratio = [mu, mv], list of two integers,
that is, mu/mv is the ratio of (1+2*cos(alpha)/cos(alpha).
If irrational, set it to None.
For hexagonal system, ratio = [mu, mv], list of two integers,
that is, mu/mv = c2/a2. If it is irrational, set it to none.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>rotation_angles corresponding to the provided sigma value.
If the sigma value is not correct, return the rotation angle corresponding
to the correct possible sigma value right smaller than the wrong sigma value provided.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.get_trans_mat">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">get_trans_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trans_cry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([[1.,</span> <span class="pre">0.,</span> <span class="pre">0.],</span> <span class="pre">[0.,</span> <span class="pre">1.,</span> <span class="pre">0.],</span> <span class="pre">[0.,</span> <span class="pre">0.,</span> <span class="pre">1.]])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'c'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_search</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quick_gen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L870-L1331"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.get_trans_mat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Find the two transformation matrix for each grain from given rotation axis,
GB plane, rotation angle and corresponding ratio (see explanation for ratio
below).
The structure of each grain can be obtained by applying the corresponding
transformation matrix to the conventional cell.
The algorithm for this code is from reference, Acta Cryst, A32,783(1976).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>(</strong><strong>list of three integers</strong> (<em>surface</em>) â or four integers, e.g. u, v, t, w for hex/rho system only):
the rotation axis of the grain boundary.</p></li>
<li><p><strong>u</strong> (<em>e.g.</em>) â or four integers, e.g. u, v, t, w for hex/rho system only):
the rotation axis of the grain boundary.</p></li>
<li><p><strong>v</strong> â or four integers, e.g. u, v, t, w for hex/rho system only):
the rotation axis of the grain boundary.</p></li>
<li><p><strong>w</strong> â or four integers, e.g. u, v, t, w for hex/rho system only):
the rotation axis of the grain boundary.</p></li>
<li><p><strong>angle</strong> (<em>float</em><em>, </em><em>in unit of degree</em>) â the rotation angle of the grain boundary</p></li>
<li><p><strong>normal</strong> (<em>logic</em>) â determine if need to require the c axis of one grain associated with
the first transformation matrix perperdicular to the surface or not.
default to false.</p></li>
<li><p><strong>trans_cry</strong> (<em>3 by 3 array</em>) â if the structure given are primitive cell in cubic system, e.g.
bcc or fcc system, trans_cry is the transformation matrix from its
conventional cell to the primitive cell.</p></li>
<li><p><strong>lat_type</strong> (<em>one character</em>) â <dl class="simple">
<dt>âcâ or âCâ: cubic system</dt><dd><p>âtâ or âTâ: tetragonal system
âoâ or âOâ: orthorhombic system
âhâ or âHâ: hexagonal system
ârâ or âRâ: rhombohedral system
default to cubic system</p>
</dd>
</dl>
</p></li>
<li><p><strong>ratio</strong> (<em>list of integers</em>) â lattice axial ratio.
For cubic system, ratio is not needed.
For tetragonal system, ratio = [mu, mv], list of two integers,
that is, mu/mv = c2/a2. If it is irrational, set it to none.
For orthorhombic system, ratio = [mu, lam, mv], list of three integers,
that is, mu:lam:mv = c2:b2:a2. If irrational for one axis, set it to None.
e.g. mu:lam:mv = c2,None,a2, means b2 is irrational.
For rhombohedral system, ratio = [mu, mv], list of two integers,
that is, mu/mv is the ratio of (1+2*cos(alpha)/cos(alpha).
If irrational, set it to None.
For hexagonal system, ratio = [mu, mv], list of two integers,
that is, mu/mv = c2/a2. If it is irrational, set it to none.</p></li>
<li><p><strong>(</strong><strong>list of three integers</strong> â or four integers, e.g. h, k, i, l for hex/rho system only):
the miller index of grain boundary plane, with the format of [h,k,l]
if surface is not given, the default is perpendicular to r_axis, which is
a twist grain boundary.</p></li>
<li><p><strong>h</strong> (<em>e.g.</em>) â or four integers, e.g. h, k, i, l for hex/rho system only):
the miller index of grain boundary plane, with the format of [h,k,l]
if surface is not given, the default is perpendicular to r_axis, which is
a twist grain boundary.</p></li>
<li><p><strong>k</strong> â or four integers, e.g. h, k, i, l for hex/rho system only):
the miller index of grain boundary plane, with the format of [h,k,l]
if surface is not given, the default is perpendicular to r_axis, which is
a twist grain boundary.</p></li>
<li><p><strong>l</strong> â or four integers, e.g. h, k, i, l for hex/rho system only):
the miller index of grain boundary plane, with the format of [h,k,l]
if surface is not given, the default is perpendicular to r_axis, which is
a twist grain boundary.</p></li>
<li><p><strong>max_search</strong> (<em>int</em>) â max search for the GB lattice vectors that give the smallest GB
lattice. If normal is true, also max search the GB c vector that perpendicular
to the plane.</p></li>
<li><p><strong>quick_gen</strong> (<em>bool</em>) â whether to quickly generate a supercell, if set to true, no need to
find the smallest cell.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>The transformation array for one grain.
t2 (3 by 3 integer array):</p>
<blockquote>
<div><p>The transformation array for the other grain</p>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>t1 (3 by 3 integer array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.reduce_mat">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">reduce_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_matrix</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L2299-L2334"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.reduce_mat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Reduce integer array matâs determinant mag times by linear combination
of its row vectors, so that the new array after rotation (r_matrix) is
still an integer array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mat</strong> (<em>3 by 3 array</em>) â input matrix</p></li>
<li><p><strong>mag</strong> (<em>integer</em>) â reduce times for the determinant</p></li>
<li><p><strong>r_matrix</strong> (<em>3 by 3 array</em>) â rotation matrix</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the reduced integer array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.slab_from_csl">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">slab_from_csl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">csl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trans_cry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_search</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quick_gen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L2080-L2297"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.slab_from_csl" title="Permalink to this definition">Â¶</a></dt>
<dd><p>By linear operation of csl lattice vectors to get the best corresponding
slab lattice. That is the area of a,b vectors (within the surface plane)
is the smallest, the c vector first, has shortest length perpendicular
to surface [h,k,l], second, has shortest length itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>csl</strong> (<em>3 by 3 integer array</em>) â input csl lattice.</p></li>
<li><p><strong>surface</strong> (<em>list of three integers</em><em>, </em><em>e.g. h</em><em>, </em><em>k</em><em>, </em><em>l</em>) â the miller index of the surface, with the format of [h,k,l]</p></li>
<li><p><strong>normal</strong> (<em>logic</em>) â determine if the c vector needs to perpendicular to surface</p></li>
<li><p><strong>trans_cry</strong> (<em>3 by 3 array</em>) â transform matrix from crystal system to orthogonal system</p></li>
<li><p><strong>max_search</strong> (<em>int</em>) â max search for the GB lattice vectors that give the smallest GB
lattice. If normal is true, also max search the GB c vector that perpendicular
to the plane.</p></li>
<li><p><strong>quick_gen</strong> (<em>bool</em>) â whether to quickly generate a supercell, no need to find the smallest
cell if set to true.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a slab lattice ( 3 by 3 integer array):</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>t_matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.GrainBoundaryGenerator.vec_to_surface">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">vec_to_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L2336-L2370"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.GrainBoundaryGenerator.vec_to_surface" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Transform a float vector to a surface miller index with integers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vec</strong> (<em>1 by 3 array float vector</em>) â input float vector</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the surface miller index of the input vector.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.factors">
<span class="sig-name descname"><span class="pre">factors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L2373-L2387"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.factors" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Compute the factors of a integer.
:param n: the input integer</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a set of integers that are the factors of the input integer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.fix_pbc">
<span class="sig-name descname"><span class="pre">fix_pbc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">structure</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L2390-L2425"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.fix_pbc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set all frac_coords of the input structure within [0,1].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>structure</strong> (<em>pymatgen structure object</em>) â input structure</p></li>
<li><p><strong>matrix</strong> (<em>lattice matrix</em><em>, </em><em>3 by 3 array/matrix</em>) â new structureâs lattice matrix, if none, use
input structureâs matrix</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>new structure with fixed frac_coords and lattice matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pymatgen.analysis.gb.grain.symm_group_cubic">
<span class="sig-name descname"><span class="pre">symm_group_cubic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/materialsproject/pymatgen/blob/v2022.0.8/pymatgen/core/../analysis/gb/grain.py#L2428-L2469"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#pymatgen.analysis.gb.grain.symm_group_cubic" title="Permalink to this definition">Â¶</a></dt>
<dd><blockquote>
<div><p>obtain cubic symmetric eqivalents of the list of vectors.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> (<em>lattice matrix</em><em>, </em><em>n by 3 array/matrix</em>) â </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>cubic symmetric eqivalents of the list of vectors.</p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2011, Pymatgen Development Team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>


</body>
</html>