
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pymatgen.transformations.advanced_transformations &#8212; pymatgen 2018.9.12 documentation</title>
    <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pymatgen 2018.9.12 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../pymatgen.html" accesskey="U">pymatgen</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.transformations.advanced_transformations</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="c1"># Copyright (c) Pymatgen Development Team.</span>
<span class="c1"># Distributed under the terms of the MIT License.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">Fraction</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">gcd</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">gcd</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">string</span> <span class="k">import</span> <span class="n">ascii_lowercase</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">warn</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">monty.fractions</span> <span class="k">import</span> <span class="n">lcm</span>
<span class="kn">from</span> <span class="nn">monty.json</span> <span class="k">import</span> <span class="n">MSONable</span>

<span class="kn">from</span> <span class="nn">pymatgen.core.periodic_table</span> <span class="k">import</span> <span class="n">Element</span><span class="p">,</span> <span class="n">Specie</span><span class="p">,</span> <span class="n">get_el_sp</span><span class="p">,</span> <span class="n">DummySpecie</span>
<span class="kn">from</span> <span class="nn">pymatgen.transformations.transformation_abc</span> <span class="k">import</span> <span class="n">AbstractTransformation</span>
<span class="kn">from</span> <span class="nn">pymatgen.transformations.standard_transformations</span> <span class="k">import</span> \
    <span class="n">SubstitutionTransformation</span><span class="p">,</span> <span class="n">OrderDisorderedStructureTransformation</span>
<span class="kn">from</span> <span class="nn">pymatgen.command_line.enumlib_caller</span> <span class="k">import</span> <span class="n">EnumlibAdaptor</span><span class="p">,</span> <span class="n">EnumError</span>
<span class="kn">from</span> <span class="nn">pymatgen.analysis.ewald</span> <span class="k">import</span> <span class="n">EwaldSummation</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="k">import</span> <span class="n">Structure</span>
<span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="k">import</span> <span class="n">SpacegroupAnalyzer</span>
<span class="kn">from</span> <span class="nn">pymatgen.analysis.structure_prediction.substitution_probability</span> <span class="k">import</span> \
    <span class="n">SubstitutionPredictor</span>
<span class="kn">from</span> <span class="nn">pymatgen.analysis.structure_matcher</span> <span class="k">import</span> <span class="n">StructureMatcher</span><span class="p">,</span> \
    <span class="n">SpinComparator</span>
<span class="kn">from</span> <span class="nn">pymatgen.analysis.energy_models</span> <span class="k">import</span> <span class="n">SymmetryModel</span>
<span class="kn">from</span> <span class="nn">pymatgen.analysis.bond_valence</span> <span class="k">import</span> <span class="n">BVAnalyzer</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.surface</span> <span class="k">import</span> <span class="n">SlabGenerator</span>
<span class="kn">from</span> <span class="nn">pymatgen.electronic_structure.core</span> <span class="k">import</span> <span class="n">Spin</span>
<span class="kn">from</span> <span class="nn">pymatgen.analysis.gb.gb</span> <span class="k">import</span> <span class="n">GBGenerator</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module implements more advanced transformations.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Shyue Ping Ong, Stephen Dacek, Anubhav Jain, Matthew Horton&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2012, The Materials Project&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Shyue Ping Ong&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;shyuep@gmail.com&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;Jul 24, 2012&quot;</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="ChargeBalanceTransformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.ChargeBalanceTransformation">[docs]</a><span class="k">class</span> <span class="nc">ChargeBalanceTransformation</span><span class="p">(</span><span class="n">AbstractTransformation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a transformation that disorders a structure to make it charge</span>
<span class="sd">    balanced, given an oxidation state-decorated structure.</span>

<span class="sd">    Args:</span>
<span class="sd">        charge_balance_sp: specie to add or remove. Currently only removal</span>
<span class="sd">            is supported</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">charge_balance_sp</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge_balance_sp</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">charge_balance_sp</span><span class="p">)</span>

<div class="viewcode-block" id="ChargeBalanceTransformation.apply_transformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.ChargeBalanceTransformation.apply_transformation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="n">charge</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">charge</span>
        <span class="n">specie</span> <span class="o">=</span> <span class="n">get_el_sp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_balance_sp</span><span class="p">)</span>
        <span class="n">num_to_remove</span> <span class="o">=</span> <span class="n">charge</span> <span class="o">/</span> <span class="n">specie</span><span class="o">.</span><span class="n">oxi_state</span>
        <span class="n">num_in_structure</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="p">[</span><span class="n">specie</span><span class="p">]</span>
        <span class="n">removal_fraction</span> <span class="o">=</span> <span class="n">num_to_remove</span> <span class="o">/</span> <span class="n">num_in_structure</span>
        <span class="k">if</span> <span class="n">removal_fraction</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;addition of specie not yet supported by &quot;</span>
                             <span class="s2">&quot;ChargeBalanceTransformation&quot;</span><span class="p">)</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="n">SubstitutionTransformation</span><span class="p">(</span>
            <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_balance_sp</span><span class="p">:</span> <span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">charge_balance_sp</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">removal_fraction</span><span class="p">}})</span>
        <span class="k">return</span> <span class="n">trans</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Charge Balance Transformation : &quot;</span> <span class="o">+</span> \
               <span class="s2">&quot;Species to remove = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_balance_sp</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_one_to_many</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="SuperTransformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.SuperTransformation">[docs]</a><span class="k">class</span> <span class="nc">SuperTransformation</span><span class="p">(</span><span class="n">AbstractTransformation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a transformation that is inherently one-to-many. It is constructed</span>
<span class="sd">    from a list of transformations and returns one structure for each</span>
<span class="sd">    transformation. The primary use for this class is extending a transmuter</span>
<span class="sd">    object.</span>

<span class="sd">    Args:</span>
<span class="sd">        transformations ([transformations]): List of transformations to apply</span>
<span class="sd">            to a structure. One transformation is applied to each output</span>
<span class="sd">            structure.</span>
<span class="sd">        nstructures_per_trans (int): If the transformations are one-to-many and,</span>
<span class="sd">            nstructures_per_trans structures from each transformation are</span>
<span class="sd">            added to the full list. Defaults to 1, i.e., only best structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformations</span><span class="p">,</span> <span class="n">nstructures_per_trans</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformations</span> <span class="o">=</span> <span class="n">transformations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nstructures_per_trans</span> <span class="o">=</span> <span class="n">nstructures_per_trans</span>

<div class="viewcode-block" id="SuperTransformation.apply_transformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.SuperTransformation.apply_transformation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">return_ranked_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_ranked_list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;SuperTransformation has no single best structure&quot;</span>
                             <span class="s2">&quot; output. Must use return_ranked_list&quot;</span><span class="p">)</span>
        <span class="n">structures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">is_one_to_many</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span>
                        <span class="n">structure</span><span class="p">,</span>
                        <span class="n">return_ranked_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nstructures_per_trans</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="s2">&quot;transformation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
                    <span class="n">structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span><span class="s2">&quot;transformation&quot;</span><span class="p">:</span> <span class="n">t</span><span class="p">,</span>
                     <span class="s2">&quot;structure&quot;</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span><span class="n">structure</span><span class="p">)})</span>
        <span class="k">return</span> <span class="n">structures</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Super Transformation : Transformations = &quot;</span> <span class="o">+</span> \
               <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformations</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_one_to_many</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="MultipleSubstitutionTransformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.MultipleSubstitutionTransformation">[docs]</a><span class="k">class</span> <span class="nc">MultipleSubstitutionTransformation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs multiple substitutions on a structure. For example, can do a</span>
<span class="sd">    fractional replacement of Ge in LiGePS with a list of species, creating one</span>
<span class="sd">    structure for each substitution. Ordering is done using a dummy element so</span>
<span class="sd">    only one ordering must be done per substitution oxidation state. Charge</span>
<span class="sd">    balancing of the structure is optionally performed.</span>

<span class="sd">    .. note::</span>
<span class="sd">        There are no checks to make sure that removal fractions are possible</span>
<span class="sd">        and rounding may occur. Currently charge balancing only works for</span>
<span class="sd">        removal of species.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sp_to_replace</span><span class="p">,</span> <span class="n">r_fraction</span><span class="p">,</span> <span class="n">substitution_dict</span><span class="p">,</span>
                 <span class="n">charge_balance_species</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs multiple fractional substitutions on a transmuter.</span>

<span class="sd">        Args:</span>
<span class="sd">            sp_to_replace: species to be replaced</span>
<span class="sd">            r_fraction: fraction of that specie to replace</span>
<span class="sd">            substitution_dict: dictionary of the format</span>
<span class="sd">                {2: [&quot;Mg&quot;, &quot;Ti&quot;, &quot;V&quot;, &quot;As&quot;, &quot;Cr&quot;, &quot;Ta&quot;, &quot;N&quot;, &quot;Nb&quot;],</span>
<span class="sd">                3: [&quot;Ru&quot;, &quot;Fe&quot;, &quot;Co&quot;, &quot;Ce&quot;, &quot;As&quot;, &quot;Cr&quot;, &quot;Ta&quot;, &quot;N&quot;, &quot;Nb&quot;],</span>
<span class="sd">                4: [&quot;Ru&quot;, &quot;V&quot;, &quot;Cr&quot;, &quot;Ta&quot;, &quot;N&quot;, &quot;Nb&quot;],</span>
<span class="sd">                5: [&quot;Ru&quot;, &quot;W&quot;, &quot;Mn&quot;]</span>
<span class="sd">                }</span>
<span class="sd">                The number is the charge used for each of the list of elements</span>
<span class="sd">                (an element can be present in multiple lists)</span>
<span class="sd">            charge_balance_species: If specified, will balance the charge on</span>
<span class="sd">                the structure using that specie.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sp_to_replace</span> <span class="o">=</span> <span class="n">sp_to_replace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_fraction</span> <span class="o">=</span> <span class="n">r_fraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substitution_dict</span> <span class="o">=</span> <span class="n">substitution_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge_balance_species</span> <span class="o">=</span> <span class="n">charge_balance_species</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>

<div class="viewcode-block" id="MultipleSubstitutionTransformation.apply_transformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.MultipleSubstitutionTransformation.apply_transformation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">return_ranked_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_ranked_list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;MultipleSubstitutionTransformation has no single&quot;</span>
                             <span class="s2">&quot; best structure output. Must use&quot;</span>
                             <span class="s2">&quot; return_ranked_list.&quot;</span><span class="p">)</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">charge</span><span class="p">,</span> <span class="n">el_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">substitution_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
            <span class="n">dummy_sp</span> <span class="o">=</span> <span class="s2">&quot;X</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">charge</span><span class="p">),</span> <span class="n">sign</span><span class="p">)</span>
            <span class="n">mapping</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_to_replace</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sp_to_replace</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_fraction</span><span class="p">,</span>
                <span class="n">dummy_sp</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_fraction</span><span class="p">}</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">SubstitutionTransformation</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
            <span class="n">dummy_structure</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_balance_species</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cbt</span> <span class="o">=</span> <span class="n">ChargeBalanceTransformation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_balance_species</span><span class="p">)</span>
                <span class="n">dummy_structure</span> <span class="o">=</span> <span class="n">cbt</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span><span class="n">dummy_structure</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">:</span>
                <span class="n">trans</span> <span class="o">=</span> <span class="n">OrderDisorderedStructureTransformation</span><span class="p">()</span>
                <span class="n">dummy_structure</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span><span class="n">dummy_structure</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">el_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
                <span class="n">st</span> <span class="o">=</span> <span class="n">SubstitutionTransformation</span><span class="p">(</span>
                    <span class="p">{</span><span class="s2">&quot;X</span><span class="si">{}</span><span class="s2">+&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">charge</span><span class="p">)):</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">charge</span><span class="p">,</span>
                                                                 <span class="n">sign</span><span class="p">)})</span>
                <span class="n">new_structure</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span><span class="n">dummy_structure</span><span class="p">)</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;structure&quot;</span><span class="p">:</span> <span class="n">new_structure</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">outputs</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Multiple Substitution Transformation : Substitution on &quot;</span> <span class="o">+</span> \
               <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sp_to_replace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_one_to_many</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="EnumerateStructureTransformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.EnumerateStructureTransformation">[docs]</a><span class="k">class</span> <span class="nc">EnumerateStructureTransformation</span><span class="p">(</span><span class="n">AbstractTransformation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Order a disordered structure using enumlib. For complete orderings, this</span>
<span class="sd">    generally produces fewer structures that the OrderDisorderedStructure</span>
<span class="sd">    transformation, and at a much faster speed.</span>

<span class="sd">    Args:</span>
<span class="sd">        min_cell_size:</span>
<span class="sd">            The minimum cell size wanted. Must be an int. Defaults to 1.</span>
<span class="sd">        max_cell_size:</span>
<span class="sd">            The maximum cell size wanted. Must be an int. Defaults to 1.</span>
<span class="sd">        symm_prec:</span>
<span class="sd">            Tolerance to use for symmetry.</span>
<span class="sd">        refine_structure:</span>
<span class="sd">            This parameter has the same meaning as in enumlib_caller.</span>
<span class="sd">            If you are starting from a structure that has been relaxed via</span>
<span class="sd">            some electronic structure code, it is usually much better to</span>
<span class="sd">            start with symmetry determination and then obtain a refined</span>
<span class="sd">            structure. The refined structure have cell parameters and</span>
<span class="sd">            atomic positions shifted to the expected symmetry positions,</span>
<span class="sd">            which makes it much less sensitive precision issues in enumlib.</span>
<span class="sd">            If you are already starting from an experimental cif, refinment</span>
<span class="sd">            should have already been done and it is not necessary. Defaults</span>
<span class="sd">            to False.</span>
<span class="sd">        enum_precision_parameter (float): Finite precision parameter for</span>
<span class="sd">            enumlib. Default of 0.001 is usually ok, but you might need to</span>
<span class="sd">            tweak it for certain cells.</span>
<span class="sd">        check_ordered_symmetry (bool): Whether to check the symmetry of</span>
<span class="sd">            the ordered sites. If the symmetry of the ordered sites is</span>
<span class="sd">            lower, the lowest symmetry ordered sites is included in the</span>
<span class="sd">            enumeration. This is important if the ordered sites break</span>
<span class="sd">            symmetry in a way that is important getting possible</span>
<span class="sd">            structures. But sometimes including ordered sites</span>
<span class="sd">            slows down enumeration to the point that it cannot be</span>
<span class="sd">            completed. Switch to False in those cases. Defaults to True.</span>
<span class="sd">        max_disordered_sites (int):</span>
<span class="sd">            An alternate parameter to max_cell size. Will sequentially try</span>
<span class="sd">            larger and larger cell sizes until (i) getting a result or (ii)</span>
<span class="sd">            the number of disordered sites in the cell exceeds</span>
<span class="sd">            max_disordered_sites. Must set max_cell_size to None when using</span>
<span class="sd">            this parameter.</span>
<span class="sd">        sort_criteria (str): Sort by Ewald energy (&quot;ewald&quot;, must have oxidation</span>
<span class="sd">            states and slow) or by number of sites (&quot;nsites&quot;, much faster).</span>
<span class="sd">        timeout (float): timeout in minutes to pass to EnumlibAdaptor</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_cell_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_cell_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">symm_prec</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                 <span class="n">refine_structure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">enum_precision_parameter</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
                 <span class="n">check_ordered_symmetry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_disordered_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sort_criteria</span><span class="o">=</span><span class="s2">&quot;ewald&quot;</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symm_prec</span> <span class="o">=</span> <span class="n">symm_prec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_cell_size</span> <span class="o">=</span> <span class="n">min_cell_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_cell_size</span> <span class="o">=</span> <span class="n">max_cell_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refine_structure</span> <span class="o">=</span> <span class="n">refine_structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enum_precision_parameter</span> <span class="o">=</span> <span class="n">enum_precision_parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_ordered_symmetry</span> <span class="o">=</span> <span class="n">check_ordered_symmetry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_disordered_sites</span> <span class="o">=</span> <span class="n">max_disordered_sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sort_criteria</span> <span class="o">=</span> <span class="n">sort_criteria</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>

        <span class="k">if</span> <span class="n">max_cell_size</span> <span class="ow">and</span> <span class="n">max_disordered_sites</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set both max_cell_size and &quot;</span>
                             <span class="s2">&quot;max_disordered_sites!&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="EnumerateStructureTransformation.apply_transformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.EnumerateStructureTransformation.apply_transformation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">return_ranked_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return either a single ordered structure or a sequence of all ordered</span>
<span class="sd">        structures.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure: Structure to order.</span>
<span class="sd">            return_ranked_list (bool): Whether or not multiple structures are</span>
<span class="sd">                returned. If return_ranked_list is a number, that number of</span>
<span class="sd">                structures is returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Depending on returned_ranked list, either a transformed structure</span>
<span class="sd">            or a list of dictionaries, where each dictionary is of the form</span>
<span class="sd">            {&quot;structure&quot; = .... , &quot;other_arguments&quot;}</span>

<span class="sd">            The list of ordered structures is ranked by ewald energy / atom, if</span>
<span class="sd">            the input structure is an oxidation state decorated structure.</span>
<span class="sd">            Otherwise, it is ranked by number of sites, with smallest number of</span>
<span class="sd">            sites first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">num_to_return</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">return_ranked_list</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">num_to_return</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">refine_structure</span><span class="p">:</span>
            <span class="n">finder</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_prec</span><span class="p">)</span>
            <span class="n">structure</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">get_refined_structure</span><span class="p">()</span>

        <span class="n">contains_oxidation_state</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="s2">&quot;oxi_state&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span>
             <span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">elements</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">structures</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">structure</span><span class="o">.</span><span class="n">is_ordered</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Enumeration skipped for structure with composition </span><span class="si">{}</span><span class="s2"> &quot;</span>
                 <span class="s2">&quot;because it is ordered&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="p">))</span>
            <span class="n">structures</span> <span class="o">=</span> <span class="p">[</span><span class="n">structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_disordered_sites</span><span class="p">:</span>
            <span class="n">ndisordered</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">site</span><span class="o">.</span><span class="n">is_ordered</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ndisordered</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_disordered_sites</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Too many disordered sites! (</span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">ndisordered</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_disordered_sites</span><span class="p">))</span>
            <span class="n">max_cell_sizes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_cell_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span>
                <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_disordered_sites</span> <span class="o">/</span> <span class="n">ndisordered</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_cell_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">max_cell_size</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">max_cell_size</span> <span class="ow">in</span> <span class="n">max_cell_sizes</span><span class="p">:</span>
            <span class="n">adaptor</span> <span class="o">=</span> <span class="n">EnumlibAdaptor</span><span class="p">(</span>
                <span class="n">structure</span><span class="p">,</span> <span class="n">min_cell_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_cell_size</span><span class="p">,</span>
                <span class="n">max_cell_size</span><span class="o">=</span><span class="n">max_cell_size</span><span class="p">,</span>
                <span class="n">symm_prec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symm_prec</span><span class="p">,</span> <span class="n">refine_structure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">enum_precision_parameter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">enum_precision_parameter</span><span class="p">,</span>
                <span class="n">check_ordered_symmetry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">check_ordered_symmetry</span><span class="p">,</span>
                <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">adaptor</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">EnumError</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Unable to enumerate for max_cell_size = </span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">max_cell_size</span><span class="p">))</span>
            <span class="n">structures</span> <span class="o">=</span> <span class="n">adaptor</span><span class="o">.</span><span class="n">structures</span>
            <span class="k">if</span> <span class="n">structures</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">structures</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to enumerate&quot;</span><span class="p">)</span>

        <span class="n">original_latt</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">lattice</span>
        <span class="n">inv_latt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">original_latt</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
        <span class="n">ewald_matrices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">all_structures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">structures</span><span class="p">:</span>
            <span class="n">new_latt</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">lattice</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">new_latt</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">inv_latt</span><span class="p">)</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">row</span><span class="p">])</span>
                                    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">transformation</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">contains_oxidation_state</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_criteria</span> <span class="o">==</span> <span class="s2">&quot;ewald&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">transformation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ewald_matrices</span><span class="p">:</span>
                    <span class="n">s_supercell</span> <span class="o">=</span> <span class="n">structure</span> <span class="o">*</span> <span class="n">transformation</span>
                    <span class="n">ewald</span> <span class="o">=</span> <span class="n">EwaldSummation</span><span class="p">(</span><span class="n">s_supercell</span><span class="p">)</span>
                    <span class="n">ewald_matrices</span><span class="p">[</span><span class="n">transformation</span><span class="p">]</span> <span class="o">=</span> <span class="n">ewald</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ewald</span> <span class="o">=</span> <span class="n">ewald_matrices</span><span class="p">[</span><span class="n">transformation</span><span class="p">]</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="n">ewald</span><span class="o">.</span><span class="n">compute_sub_structure</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">all_structures</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;num_sites&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span> <span class="n">energy</span><span class="p">,</span>
                                       <span class="s2">&quot;structure&quot;</span><span class="p">:</span> <span class="n">s</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_structures</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;num_sites&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s2">&quot;structure&quot;</span><span class="p">:</span> <span class="n">s</span><span class="p">})</span>

        <span class="k">def</span> <span class="nf">sort_func</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;num_sites&quot;</span><span class="p">]</span> \
                <span class="k">if</span> <span class="n">contains_oxidation_state</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_criteria</span> <span class="o">==</span> <span class="s2">&quot;ewald&quot;</span> \
                <span class="k">else</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;num_sites&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_all_structures</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_structures</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sort_func</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_ranked_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_structures</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">num_to_return</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_structures</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;EnumerateStructureTransformation&quot;</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_one_to_many</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SubstitutionPredictorTransformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.SubstitutionPredictorTransformation">[docs]</a><span class="k">class</span> <span class="nc">SubstitutionPredictorTransformation</span><span class="p">(</span><span class="n">AbstractTransformation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This transformation takes a structure and uses the structure</span>
<span class="sd">    prediction module to find likely site substitutions.</span>

<span class="sd">    Args:</span>
<span class="sd">        threshold: Threshold for substitution.</span>
<span class="sd">        **kwargs: Args for SubstitutionProbability class lambda_table, alpha</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">scale_volumes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_volumes</span> <span class="o">=</span> <span class="n">scale_volumes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_substitutor</span> <span class="o">=</span> <span class="n">SubstitutionPredictor</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="SubstitutionPredictorTransformation.apply_transformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.SubstitutionPredictorTransformation.apply_transformation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">return_ranked_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_ranked_list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;SubstitutionPredictorTransformation doesn&#39;t&quot;</span>
                             <span class="s2">&quot; support returning 1 structure&quot;</span><span class="p">)</span>

        <span class="n">preds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutor</span><span class="o">.</span><span class="n">composition_prediction</span><span class="p">(</span>
            <span class="n">structure</span><span class="o">.</span><span class="n">composition</span><span class="p">,</span> <span class="n">to_this_composition</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">preds</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;probability&#39;</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">preds</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">SubstitutionTransformation</span><span class="p">(</span><span class="n">pred</span><span class="p">[</span><span class="s1">&#39;substitutions&#39;</span><span class="p">])</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;structure&#39;</span><span class="p">:</span> <span class="n">st</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span><span class="n">structure</span><span class="p">),</span>
                      <span class="s1">&#39;probability&#39;</span><span class="p">:</span> <span class="n">pred</span><span class="p">[</span><span class="s1">&#39;probability&#39;</span><span class="p">],</span>
                      <span class="s1">&#39;threshold&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> <span class="s1">&#39;substitutions&#39;</span><span class="p">:</span> <span class="p">{}}</span>

            <span class="c1"># dictionary keys have to be converted to strings for JSON</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">pred</span><span class="p">[</span><span class="s1">&#39;substitutions&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">output</span><span class="p">[</span><span class="s1">&#39;substitutions&#39;</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outputs</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;SubstitutionPredictorTransformation&quot;</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_one_to_many</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="MagOrderParameterConstraint"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.MagOrderParameterConstraint">[docs]</a><span class="k">class</span> <span class="nc">MagOrderParameterConstraint</span><span class="p">(</span><span class="n">MSONable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order_parameter</span><span class="p">,</span>
                 <span class="n">species_constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">site_constraint_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">site_constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class can be used to supply MagOrderingTransformation</span>
<span class="sd">        to just a specific subset of species or sites that satisfy the</span>
<span class="sd">        provided constraints. This can be useful for setting an order</span>
<span class="sd">        parameters for, for example, ferrimagnetic structures which</span>
<span class="sd">        might order on certain motifs, with the global order parameter</span>
<span class="sd">        dependent on how many sites satisfy that motif.</span>

<span class="sd">        :param order_parameter (float): any number from 0.0 to 1.0,</span>
<span class="sd">        typically 0.5 (antiferromagnetic) or 1.0 (ferromagnetic)</span>
<span class="sd">        :param species_constraint (list): str or list of strings</span>
<span class="sd">        of Specie symbols that the constraint should apply to</span>
<span class="sd">        :param site_constraint_name (str): name of the site property</span>
<span class="sd">        that the constraint should apply to, e.g. &quot;coordination_no&quot;</span>
<span class="sd">        :param site_constraints (list): list of values of the site</span>
<span class="sd">        property that the constraints should apply to</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># validation</span>
        <span class="k">if</span> <span class="n">site_constraints</span> <span class="ow">and</span> <span class="n">site_constraints</span> <span class="o">!=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">site_constraint_name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specify the name of the site constraint.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">site_constraints</span> <span class="ow">and</span> <span class="n">site_constraint_name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Please specify some site constraints.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">species_constraints</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">species_constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">species_constraints</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">site_constraints</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">site_constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">site_constraints</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">order_parameter</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">order_parameter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Order parameter must lie between 0 and 1&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">order_parameter</span> <span class="o">!=</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Use care when using a non-standard order parameter, &quot;</span>
                          <span class="s2">&quot;though it can be useful in some cases it can also &quot;</span>
                          <span class="s2">&quot;lead to unintended behavior. Consult documentation.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">order_parameter</span> <span class="o">=</span> <span class="n">order_parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">species_constraints</span> <span class="o">=</span> <span class="n">species_constraints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">site_constraint_name</span> <span class="o">=</span> <span class="n">site_constraint_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">site_constraints</span> <span class="o">=</span> <span class="n">site_constraints</span>

<div class="viewcode-block" id="MagOrderParameterConstraint.satisfies_constraint"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.MagOrderParameterConstraint.satisfies_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">satisfies_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a periodic site satisfies the constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">site</span><span class="o">.</span><span class="n">is_ordered</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">species_constraints</span> \
                <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">species_constraints</span><span class="p">:</span>
            <span class="n">satisfies_constraints</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">satisfies_constraints</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_constraint_name</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_constraint_name</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="n">prop</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">site_constraint_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">prop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_constraints</span><span class="p">:</span>
                <span class="n">satisfies_constraints</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">satisfies_constraints</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">satisfies_constraints</span></div></div>


<div class="viewcode-block" id="MagOrderingTransformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.MagOrderingTransformation">[docs]</a><span class="k">class</span> <span class="nc">MagOrderingTransformation</span><span class="p">(</span><span class="n">AbstractTransformation</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mag_species_spin</span><span class="p">,</span> <span class="n">order_parameter</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">energy_model</span><span class="o">=</span><span class="n">SymmetryModel</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This transformation takes a structure and returns a list of collinear</span>
<span class="sd">        magnetic orderings. For disordered structures, make an ordered</span>
<span class="sd">        approximation first.</span>

<span class="sd">        :param mag_species_spin: A mapping of elements/species to their</span>
<span class="sd">        spin magnitudes, e.g. {&quot;Fe3+&quot;: 5, &quot;Mn3+&quot;: 4}</span>
<span class="sd">        :param order_parameter (float or list): if float, a specifies a</span>
<span class="sd">        global order parameter and can take values from 0.0 to 1.0</span>
<span class="sd">        (e.g. 0.5 for antiferromagnetic or 1.0 for ferromagnetic), if</span>
<span class="sd">        list has to be a list of</span>
<span class="sd">        :class: `pymatgen.transformations.advanced_transformations.MagOrderParameterConstraint`</span>
<span class="sd">        to specify more complicated orderings, see documentation for</span>
<span class="sd">        MagOrderParameterConstraint more details on usage</span>
<span class="sd">        :param energy_model: Energy model to rank the returned structures,</span>
<span class="sd">        see :mod: `pymatgen.analysis.energy_models` for more information (note</span>
<span class="sd">        that this is not necessarily a physical energy). By default, returned</span>
<span class="sd">        structures use SymmetryModel() which ranks structures from most</span>
<span class="sd">        symmetric to least.</span>
<span class="sd">        :param kwargs: Additional kwargs that are passed to</span>
<span class="sd">        :class:`EnumerateStructureTransformation` such as min_cell_size etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># checking for sensible order_parameter values</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order_parameter</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="c1"># convert to constraint format</span>
            <span class="n">order_parameter</span> <span class="o">=</span> <span class="p">[</span><span class="n">MagOrderParameterConstraint</span><span class="p">(</span><span class="n">order_parameter</span><span class="o">=</span><span class="n">order_parameter</span><span class="p">,</span>
                                                           <span class="n">species_constraints</span><span class="o">=</span>
                                                           <span class="nb">list</span><span class="p">(</span><span class="n">mag_species_spin</span><span class="o">.</span><span class="n">keys</span><span class="p">()))]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order_parameter</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">MagOrderParameterConstraint</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">order_parameter</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">ops</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Order parameter not correctly defined.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Order parameter not correctly defined.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mag_species_spin</span> <span class="o">=</span> <span class="n">mag_species_spin</span>
        <span class="c1"># store order parameter constraints as dicts to save implementing</span>
        <span class="c1"># to/from dict methods for MSONable compatibility</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_parameter</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">order_parameter</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energy_model</span> <span class="o">=</span> <span class="n">energy_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enum_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="MagOrderingTransformation.determine_min_cell"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.MagOrderingTransformation.determine_min_cell">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">determine_min_cell</span><span class="p">(</span><span class="n">disordered_structure</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the smallest supercell that is able to enumerate</span>
<span class="sd">        the provided structure with the given order parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">lcm</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Find least common multiple of two numbers</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">/</span> <span class="n">gcd</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>

        <span class="c1"># assumes all order parameters for a given species are the same</span>
        <span class="n">mag_species_order_parameter</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">mag_species_occurrences</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">disordered_structure</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">site</span><span class="o">.</span><span class="n">is_ordered</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="c1"># this very hacky bit of code only works because we know</span>
                <span class="c1"># that on disordered sites in this class, all species are the same</span>
                <span class="c1"># but have different spins, and this is comma-delimited</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">mag_species_order_parameter</span><span class="p">:</span>
                    <span class="n">mag_species_occurrences</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mag_species_order_parameter</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span>
                    <span class="n">mag_species_occurrences</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">smallest_n</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">sp</span><span class="p">,</span> <span class="n">order_parameter</span> <span class="ow">in</span> <span class="n">mag_species_order_parameter</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">order_parameter</span><span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">denominator</span>
            <span class="n">num_atom_per_specie</span> <span class="o">=</span> <span class="n">mag_species_occurrences</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span>
            <span class="n">n_gcd</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">num_atom_per_specie</span><span class="p">)</span>
            <span class="n">smallest_n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lcm</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_gcd</span><span class="p">),</span> <span class="n">denom</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_gcd</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">smallest_n</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_add_dummy_species</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">order_parameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param structure: ordered Structure</span>
<span class="sd">        :param order_parameters: list of MagOrderParameterConstraints</span>
<span class="sd">        :return: A structure decorated with disordered</span>
<span class="sd">        DummySpecies on which to perform the enumeration.</span>
<span class="sd">        Note that the DummySpecies are super-imposed on</span>
<span class="sd">        to the original sites, to make it easier to</span>
<span class="sd">        retrieve the original site after enumeration is</span>
<span class="sd">        performed (this approach is preferred over a simple</span>
<span class="sd">        mapping since multiple species may have the same</span>
<span class="sd">        DummySpecie, depending on the constraints specified).</span>
<span class="sd">        This approach can also preserve site properties even after</span>
<span class="sd">        enumeration.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dummy_struct</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">generate_dummy_specie</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Generator which returns DummySpecie symbols Mma, Mmb, etc.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">subscript_length</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">subscript</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">ascii_lowercase</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">subscript_length</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="s2">&quot;Mm&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subscript</span><span class="p">)</span>
                <span class="n">subscript_length</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">dummy_species_gen</span> <span class="o">=</span> <span class="n">generate_dummy_specie</span><span class="p">()</span>

        <span class="c1"># one dummy species for each order parameter constraint</span>
        <span class="n">dummy_species_symbols</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">dummy_species_gen</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order_parameters</span><span class="p">))]</span>
        <span class="n">dummy_species</span> <span class="o">=</span> <span class="p">[{</span>
                             <span class="n">DummySpecie</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;spin&#39;</span><span class="p">:</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">}):</span> <span class="n">constraint</span><span class="o">.</span><span class="n">order_parameter</span><span class="p">,</span>
                             <span class="n">DummySpecie</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;spin&#39;</span><span class="p">:</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">}):</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">constraint</span><span class="o">.</span><span class="n">order_parameter</span>
                         <span class="p">}</span> <span class="k">for</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dummy_species_symbols</span><span class="p">,</span> <span class="n">order_parameters</span><span class="p">)]</span>

        <span class="n">sites_to_add</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dummy_struct</span><span class="p">):</span>
            <span class="n">satisfies_constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">satisfies_constraint</span><span class="p">(</span><span class="n">site</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">order_parameters</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">satisfies_constraints</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># site should either not satisfy any constraints, or satisfy</span>
                <span class="c1"># one constraint</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Order parameter constraints conflict for site: </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">&quot;</span>
                                 <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">),</span> <span class="n">site</span><span class="o">.</span><span class="n">properties</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">satisfies_constraints</span><span class="p">):</span>
                <span class="n">dummy_specie_idx</span> <span class="o">=</span> <span class="n">satisfies_constraints</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">dummy_struct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">dummy_species</span><span class="p">[</span><span class="n">dummy_specie_idx</span><span class="p">],</span>
                    <span class="n">site</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
                    <span class="n">site</span><span class="o">.</span><span class="n">lattice</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">dummy_struct</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_remove_dummy_species</span><span class="p">(</span><span class="n">structure</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Structure with dummy species removed, but</span>
<span class="sd">        their corresponding spin properties merged with the</span>
<span class="sd">        original sites. Used after performing enumeration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">structure</span><span class="o">.</span><span class="n">is_ordered</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Something went wrong with enumeration.&quot;</span><span class="p">)</span>

        <span class="n">sites_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Dummy species structure:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">structure</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">structure</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="n">DummySpecie</span><span class="p">):</span>
                <span class="n">sites_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">spin</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span>
                    <span class="n">site</span><span class="p">,</span>
                    <span class="mf">0.05</span><span class="p">,</span>  <span class="c1"># arbitrary threshold, needs to be &lt;&lt; any bond length</span>
                    <span class="c1"># but &gt;&gt; floating point precision issues</span>
                    <span class="n">include_index</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This shouldn&#39;t happen, found neighbors: </span><span class="si">{}</span><span class="s2">&quot;</span>
                                    <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>
                <span class="n">orig_site_idx</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">orig_specie</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="n">orig_site_idx</span><span class="p">]</span><span class="o">.</span><span class="n">specie</span>
                <span class="n">new_specie</span> <span class="o">=</span> <span class="n">Specie</span><span class="p">(</span><span class="n">orig_specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span>
                                    <span class="nb">getattr</span><span class="p">(</span><span class="n">orig_specie</span><span class="p">,</span> <span class="s1">&#39;oxi_state&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                    <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;spin&#39;</span><span class="p">:</span> <span class="n">spin</span><span class="p">})</span>
                <span class="n">structure</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">orig_site_idx</span><span class="p">,</span>
                                  <span class="n">new_specie</span><span class="p">,</span>
                                  <span class="n">properties</span><span class="o">=</span><span class="n">structure</span><span class="p">[</span><span class="n">orig_site_idx</span><span class="p">]</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>
        <span class="n">structure</span><span class="o">.</span><span class="n">remove_sites</span><span class="p">(</span><span class="n">sites_to_remove</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Structure with dummy species removed:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">structure</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">structure</span>

    <span class="k">def</span> <span class="nf">_add_spin_magnitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces Spin.up/Spin.down with spin magnitudes specified</span>
<span class="sd">        by mag_species_spin.</span>
<span class="sd">        :param structure:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">structure</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="s1">&#39;_properties&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">spin</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">spin</span><span class="p">)</span> <span class="k">if</span> <span class="n">spin</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">spin</span><span class="p">:</span>
                    <span class="n">new_properties</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="c1"># this very hacky bit of code only works because we know</span>
                    <span class="c1"># that on disordered sites in this class, all species are the same</span>
                    <span class="c1"># but have different spins, and this is comma-delimited</span>
                    <span class="n">sp</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">new_properties</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                        <span class="s1">&#39;spin&#39;</span><span class="p">:</span> <span class="n">sign</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mag_species_spin</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="p">})</span>
                    <span class="n">new_specie</span> <span class="o">=</span> <span class="n">Specie</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span>
                                        <span class="nb">getattr</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="s1">&#39;oxi_state&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                        <span class="n">new_properties</span><span class="p">)</span>
                    <span class="n">structure</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">new_specie</span><span class="p">,</span>
                                      <span class="n">properties</span><span class="o">=</span><span class="n">site</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Structure with spin magnitudes:</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">structure</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">structure</span>

<div class="viewcode-block" id="MagOrderingTransformation.apply_transformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.MagOrderingTransformation.apply_transformation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">return_ranked_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply MagOrderTransformation to an input structure.</span>
<span class="sd">        :param structure: Any ordered structure.</span>
<span class="sd">        :param return_ranked_list: As in other Transformations.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">structure</span><span class="o">.</span><span class="n">is_ordered</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Create an ordered approximation of &quot;</span>
                             <span class="s2">&quot;your  input structure first.&quot;</span><span class="p">)</span>

        <span class="c1"># retrieve order parameters</span>
        <span class="n">order_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="n">MagOrderParameterConstraint</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">op_dict</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">op_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_parameter</span><span class="p">]</span>
        <span class="c1"># add dummy species on which to perform enumeration</span>
        <span class="n">structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_dummy_species</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">order_parameters</span><span class="p">)</span>

        <span class="c1"># trivial case</span>
        <span class="k">if</span> <span class="n">structure</span><span class="o">.</span><span class="n">is_ordered</span><span class="p">:</span>
            <span class="n">structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_dummy_species</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">structure</span><span class="p">]</span> <span class="k">if</span> <span class="n">return_ranked_list</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">structure</span>

        <span class="n">enum_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enum_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">enum_kwargs</span><span class="p">[</span><span class="s2">&quot;min_cell_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_min_cell</span><span class="p">(</span><span class="n">structure</span><span class="p">)),</span>
            <span class="n">enum_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;min_cell_size&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">enum_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_cell_size&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">enum_kwargs</span><span class="p">[</span><span class="s2">&quot;min_cell_size&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">enum_kwargs</span><span class="p">[</span><span class="s2">&quot;max_cell_size&quot;</span><span class="p">]:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Specified max cell size (</span><span class="si">{}</span><span class="s2">) is smaller &quot;</span>
                              <span class="s2">&quot;than the minimum enumerable cell size (</span><span class="si">{}</span><span class="s2">), &quot;</span>
                              <span class="s2">&quot;changing max cell size to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">enum_kwargs</span><span class="p">[</span><span class="s2">&quot;max_cell_size&quot;</span><span class="p">],</span>
                                                                    <span class="n">enum_kwargs</span><span class="p">[</span><span class="s2">&quot;min_cell_size&quot;</span><span class="p">],</span>
                                                                    <span class="n">enum_kwargs</span><span class="p">[</span><span class="s2">&quot;min_cell_size&quot;</span><span class="p">]))</span>
                <span class="n">enum_kwargs</span><span class="p">[</span><span class="s2">&quot;max_cell_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">enum_kwargs</span><span class="p">[</span><span class="s2">&quot;min_cell_size&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">enum_kwargs</span><span class="p">[</span><span class="s2">&quot;max_cell_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">enum_kwargs</span><span class="p">[</span><span class="s2">&quot;min_cell_size&quot;</span><span class="p">]</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">EnumerateStructureTransformation</span><span class="p">(</span><span class="o">**</span><span class="n">enum_kwargs</span><span class="p">)</span>

        <span class="n">alls</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span>
                                      <span class="n">return_ranked_list</span><span class="o">=</span><span class="n">return_ranked_list</span><span class="p">)</span>

        <span class="c1"># handle the fact that EnumerateStructureTransformation can either</span>
        <span class="c1"># return a single Structure or a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alls</span><span class="p">,</span> <span class="n">Structure</span><span class="p">):</span>
            <span class="c1"># remove dummy species and replace Spin.up or Spin.down</span>
            <span class="c1"># with spin magnitudes given in mag_species_spin arg</span>
            <span class="n">alls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_dummy_species</span><span class="p">(</span><span class="n">alls</span><span class="p">)</span>
            <span class="n">alls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_spin_magnitudes</span><span class="p">(</span><span class="n">alls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alls</span><span class="p">):</span>
                <span class="n">alls</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_dummy_species</span><span class="p">(</span><span class="n">alls</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s2">&quot;structure&quot;</span><span class="p">])</span>
                <span class="n">alls</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_spin_magnitudes</span><span class="p">(</span><span class="n">alls</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s2">&quot;structure&quot;</span><span class="p">])</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">num_to_return</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">return_ranked_list</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">num_to_return</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">num_to_return</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">return_ranked_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">alls</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">num_to_return</span> <span class="k">else</span> <span class="n">alls</span>

        <span class="c1"># remove duplicate structures and group according to energy model</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">StructureMatcher</span><span class="p">(</span><span class="n">comparator</span><span class="o">=</span><span class="n">SpinComparator</span><span class="p">())</span>
        <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">get_space_group_number</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">alls</span><span class="p">],</span>
                                   <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">),</span> <span class="n">key</span><span class="p">):</span>
            <span class="n">g</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="n">grouped</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group_structures</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">([{</span><span class="s2">&quot;structure&quot;</span><span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                         <span class="s2">&quot;energy&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_model</span><span class="o">.</span><span class="n">get_energy</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">])}</span>
                        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_all_structures</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_structures</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">num_to_return</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;MagOrderingTransformation&quot;</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_one_to_many</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<span class="k">def</span> <span class="nf">_find_codopant</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">oxidation_state</span><span class="p">,</span> <span class="n">allowed_elements</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the element from &quot;allowed elements&quot; that (i) possesses the desired</span>
<span class="sd">    &quot;oxidation state&quot; and (ii) is closest in ionic radius to the target specie</span>

<span class="sd">    Args:</span>
<span class="sd">        target: (Specie) provides target ionic radius.</span>
<span class="sd">        oxidation_state: (float) codopant oxidation state.</span>
<span class="sd">        allowed_elements: ([str]) List of allowed elements. If None,</span>
<span class="sd">            all elements are tried.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (Specie) with oxidation_state that has ionic radius closest to</span>
<span class="sd">        target.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref_radius</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">ionic_radius</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">symbols</span> <span class="o">=</span> <span class="n">allowed_elements</span> <span class="ow">or</span> <span class="p">[</span><span class="n">el</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">Element</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="n">sp</span> <span class="o">=</span> <span class="n">Specie</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">oxidation_state</span><span class="p">)</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">ionic_radius</span>
                <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">sp</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">ref_radius</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>


<div class="viewcode-block" id="DopingTransformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.DopingTransformation">[docs]</a><span class="k">class</span> <span class="nc">DopingTransformation</span><span class="p">(</span><span class="n">AbstractTransformation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A transformation that performs doping of a structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dopant</span><span class="p">,</span> <span class="n">ionic_radius_tol</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">alio_tol</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">codopant</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_structures_per_enum</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                 <span class="n">allowed_doping_species</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            dopant (Specie-like): E.g., Al3+. Must have oxidation state.</span>
<span class="sd">            ionic_radius_tol (float): E.g., Fractional allowable ionic radii</span>
<span class="sd">                mismatch for dopant to fit into a site. Default of inf means</span>
<span class="sd">                that any dopant with the right oxidation state is allowed.</span>
<span class="sd">            min_Length (float): Min. lattice parameter between periodic</span>
<span class="sd">                images of dopant. Defaults to 10A for now.</span>
<span class="sd">            alio_tol (int): If this is not 0, attempt will be made to dope</span>
<span class="sd">                sites with oxidation_states +- alio_tol of the dopant. E.g.,</span>
<span class="sd">                1 means that the ions like Ca2+ and Ti4+ are considered as</span>
<span class="sd">                potential doping sites for Al3+.</span>
<span class="sd">            codopant (bool): If True, doping will be carried out with a</span>
<span class="sd">                codopant to maintain charge neutrality. Otherwise, vacancies</span>
<span class="sd">                will be used.</span>
<span class="sd">            max_structures_per_enum (float): Maximum number of structures to</span>
<span class="sd">                return per enumeration. Note that there can be more than one</span>
<span class="sd">                candidate doping site, and each site enumeration will return at</span>
<span class="sd">                max max_structures_per_enum structures. Defaults to 100.</span>
<span class="sd">            allowed_doping_species (list): Species that are allowed to be</span>
<span class="sd">                doping sites. This is an inclusionary list. If specified,</span>
<span class="sd">                any sites which are not</span>
<span class="sd">            \\*\\*kwargs:</span>
<span class="sd">                Same keyword args as :class:`EnumerateStructureTransformation`,</span>
<span class="sd">                i.e., min_cell_size, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span> <span class="o">=</span> <span class="n">get_el_sp</span><span class="p">(</span><span class="n">dopant</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ionic_radius_tol</span> <span class="o">=</span> <span class="n">ionic_radius_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_length</span> <span class="o">=</span> <span class="n">min_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alio_tol</span> <span class="o">=</span> <span class="n">alio_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">codopant</span> <span class="o">=</span> <span class="n">codopant</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_structures_per_enum</span> <span class="o">=</span> <span class="n">max_structures_per_enum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allowed_doping_species</span> <span class="o">=</span> <span class="n">allowed_doping_species</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="DopingTransformation.apply_transformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.DopingTransformation.apply_transformation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">return_ranked_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            structure (Structure): Input structure to dope</span>

<span class="sd">        Returns:</span>
<span class="sd">            [{&quot;structure&quot;: Structure, &quot;energy&quot;: float}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Composition: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">comp</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">analyzer</span> <span class="o">=</span> <span class="n">BVAnalyzer</span><span class="p">()</span>
                <span class="n">structure</span> <span class="o">=</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">get_oxi_state_decorated_structure</span><span class="p">(</span>
                    <span class="n">structure</span><span class="p">)</span>
                <span class="n">comp</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">composition</span>
                <span class="k">break</span>

        <span class="n">ox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span><span class="o">.</span><span class="n">oxi_state</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span><span class="o">.</span><span class="n">ionic_radius</span>

        <span class="n">compatible_species</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">sp</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">comp</span> <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span> <span class="o">==</span> <span class="n">ox</span> <span class="ow">and</span>
            <span class="nb">abs</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">ionic_radius</span> <span class="o">/</span> <span class="n">radius</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionic_radius_tol</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">compatible_species</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">alio_tol</span><span class="p">:</span>
            <span class="c1"># We only consider aliovalent doping if there are no compatible</span>
            <span class="c1"># isovalent species.</span>
            <span class="n">compatible_species</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">sp</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">comp</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span> <span class="o">-</span> <span class="n">ox</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alio_tol</span> <span class="ow">and</span>
                <span class="nb">abs</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">ionic_radius</span> <span class="o">/</span> <span class="n">radius</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionic_radius_tol</span> <span class="ow">and</span>
                <span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span> <span class="o">*</span> <span class="n">ox</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_doping_species</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Only keep allowed doping species.</span>
            <span class="n">compatible_species</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">sp</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">compatible_species</span>
                <span class="k">if</span> <span class="n">sp</span> <span class="ow">in</span> <span class="p">[</span><span class="n">get_el_sp</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_doping_species</span><span class="p">]]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Compatible species: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">compatible_species</span><span class="p">)</span>

        <span class="n">lengths</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">abc</span>
        <span class="n">scaling</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_length</span> <span class="o">/</span> <span class="n">x</span><span class="p">))))</span>
                   <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lengths</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Lengths are </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">lengths</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Scaling = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">scaling</span><span class="p">))</span>

        <span class="n">all_structures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">EnumerateStructureTransformation</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">compatible_species</span><span class="p">:</span>
            <span class="n">supercell</span> <span class="o">=</span> <span class="n">structure</span> <span class="o">*</span> <span class="n">scaling</span>
            <span class="n">nsp</span> <span class="o">=</span> <span class="n">supercell</span><span class="o">.</span><span class="n">composition</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span> <span class="o">==</span> <span class="n">ox</span><span class="p">:</span>
                <span class="n">supercell</span><span class="o">.</span><span class="n">replace_species</span><span class="p">({</span><span class="n">sp</span><span class="p">:</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="p">(</span><span class="n">nsp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">}})</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Doping </span><span class="si">%s</span><span class="s2"> for </span><span class="si">%s</span><span class="s2"> at level </span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">sp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">codopant</span><span class="p">:</span>
                <span class="n">codopant</span> <span class="o">=</span> <span class="n">_find_codopant</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span> <span class="o">-</span> <span class="n">ox</span><span class="p">)</span>
                <span class="n">supercell</span><span class="o">.</span><span class="n">replace_species</span><span class="p">({</span><span class="n">sp</span><span class="p">:</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="p">(</span><span class="n">nsp</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">,</span>
                                                <span class="n">codopant</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">}})</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Doping </span><span class="si">%s</span><span class="s2"> for </span><span class="si">%s</span><span class="s2"> + </span><span class="si">%s</span><span class="s2"> at level </span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">sp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span><span class="p">,</span> <span class="n">codopant</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ox</span><span class="p">):</span>
                <span class="c1"># Strategy: replace the target species with a</span>
                <span class="c1"># combination of dopant and vacancy.</span>
                <span class="c1"># We will choose the lowest oxidation state species as a</span>
                <span class="c1"># vacancy compensation species as it is likely to be lower in</span>
                <span class="c1"># energy</span>
                <span class="n">sp_to_remove</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">comp</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">oxi_state</span> <span class="o">*</span> <span class="n">ox</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">],</span>
                                   <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">ss</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">oxi_state</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">sp_to_remove</span> <span class="o">==</span> <span class="n">sp</span><span class="p">:</span>
                    <span class="n">common_charge</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ox</span><span class="p">)))</span>
                    <span class="n">ndopant</span> <span class="o">=</span> <span class="n">common_charge</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ox</span><span class="p">)</span>
                    <span class="n">nsp_to_remove</span> <span class="o">=</span> <span class="n">common_charge</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Doping </span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> with </span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">nsp_to_remove</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">ndopant</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span><span class="p">))</span>
                    <span class="n">supercell</span><span class="o">.</span><span class="n">replace_species</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="p">(</span><span class="n">nsp</span> <span class="o">-</span> <span class="n">nsp_to_remove</span><span class="p">)</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span><span class="p">:</span> <span class="n">ndopant</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">}})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ox_diff</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span> <span class="o">-</span> <span class="n">ox</span><span class="p">)))</span>
                    <span class="n">vac_ox</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sp_to_remove</span><span class="o">.</span><span class="n">oxi_state</span><span class="p">))</span>
                    <span class="n">common_charge</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="n">vac_ox</span><span class="p">,</span> <span class="n">ox_diff</span><span class="p">)</span>
                    <span class="n">ndopant</span> <span class="o">=</span> <span class="n">common_charge</span> <span class="o">/</span> <span class="n">ox_diff</span>
                    <span class="n">nx_to_remove</span> <span class="o">=</span> <span class="n">common_charge</span> <span class="o">/</span> <span class="n">vac_ox</span>
                    <span class="n">nx</span> <span class="o">=</span> <span class="n">supercell</span><span class="o">.</span><span class="n">composition</span><span class="p">[</span><span class="n">sp_to_remove</span><span class="p">]</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Doping </span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> with </span><span class="si">%s</span><span class="s2"> and removing </span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">ndopant</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span><span class="p">,</span>
                                 <span class="n">nx_to_remove</span><span class="p">,</span> <span class="n">sp_to_remove</span><span class="p">))</span>
                    <span class="n">supercell</span><span class="o">.</span><span class="n">replace_species</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="p">(</span><span class="n">nsp</span> <span class="o">-</span> <span class="n">ndopant</span><span class="p">)</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span><span class="p">:</span> <span class="n">ndopant</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">},</span>
                         <span class="n">sp_to_remove</span><span class="p">:</span> <span class="p">{</span>
                             <span class="n">sp_to_remove</span><span class="p">:</span> <span class="p">(</span><span class="n">nx</span> <span class="o">-</span> <span class="n">nx_to_remove</span><span class="p">)</span> <span class="o">/</span> <span class="n">nx</span><span class="p">}})</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ox</span><span class="p">):</span>
                <span class="c1"># Strategy: replace the target species with dopant and also</span>
                <span class="c1"># remove some opposite charged species for charge neutrality</span>
                <span class="k">if</span> <span class="n">ox</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sp_to_remove</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">supercell</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
                                       <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">el</span><span class="p">:</span> <span class="n">el</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sp_to_remove</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">supercell</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
                                       <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">el</span><span class="p">:</span> <span class="n">el</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
                <span class="c1"># Confirm species are of opposite oxidation states.</span>
                <span class="k">assert</span> <span class="n">sp_to_remove</span><span class="o">.</span><span class="n">oxi_state</span> <span class="o">*</span> <span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span> <span class="o">&lt;</span> <span class="mi">0</span>

                <span class="n">ox_diff</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">oxi_state</span> <span class="o">-</span> <span class="n">ox</span><span class="p">)))</span>
                <span class="n">anion_ox</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sp_to_remove</span><span class="o">.</span><span class="n">oxi_state</span><span class="p">))</span>
                <span class="n">nx</span> <span class="o">=</span> <span class="n">supercell</span><span class="o">.</span><span class="n">composition</span><span class="p">[</span><span class="n">sp_to_remove</span><span class="p">]</span>
                <span class="n">common_charge</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="n">anion_ox</span><span class="p">,</span> <span class="n">ox_diff</span><span class="p">)</span>
                <span class="n">ndopant</span> <span class="o">=</span> <span class="n">common_charge</span> <span class="o">/</span> <span class="n">ox_diff</span>
                <span class="n">nx_to_remove</span> <span class="o">=</span> <span class="n">common_charge</span> <span class="o">/</span> <span class="n">anion_ox</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Doping </span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> with </span><span class="si">%s</span><span class="s2"> and removing </span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">ndopant</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span><span class="p">,</span>
                             <span class="n">nx_to_remove</span><span class="p">,</span> <span class="n">sp_to_remove</span><span class="p">))</span>
                <span class="n">supercell</span><span class="o">.</span><span class="n">replace_species</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="p">(</span><span class="n">nsp</span> <span class="o">-</span> <span class="n">ndopant</span><span class="p">)</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">dopant</span><span class="p">:</span> <span class="n">ndopant</span> <span class="o">/</span> <span class="n">nsp</span><span class="p">},</span>
                     <span class="n">sp_to_remove</span><span class="p">:</span> <span class="p">{</span><span class="n">sp_to_remove</span><span class="p">:</span> <span class="p">(</span><span class="n">nx</span> <span class="o">-</span> <span class="n">nx_to_remove</span><span class="p">)</span> <span class="o">/</span> <span class="n">nx</span><span class="p">}})</span>

            <span class="n">ss</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">apply_transformation</span><span class="p">(</span>
                <span class="n">supercell</span><span class="p">,</span> <span class="n">return_ranked_list</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_structures_per_enum</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> distinct structures&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="p">))</span>
            <span class="n">all_structures</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Total </span><span class="si">%s</span><span class="s2"> doped structures&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_structures</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">return_ranked_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">all_structures</span><span class="p">[:</span><span class="n">return_ranked_list</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">all_structures</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_one_to_many</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="SlabTransformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.SlabTransformation">[docs]</a><span class="k">class</span> <span class="nc">SlabTransformation</span><span class="p">(</span><span class="n">AbstractTransformation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A transformation that creates a slab from a structure.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">min_slab_size</span><span class="p">,</span> <span class="n">min_vacuum_size</span><span class="p">,</span>
                 <span class="n">lll_reduce</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">center_slab</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">in_unit_planes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">primitive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">max_normal_search</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            miller_index (3-tuple or list): miller index of slab</span>
<span class="sd">            min_slab_size (float): minimum slab size in angstroms</span>
<span class="sd">            min_vacuum_size (float): minimum size of vacuum</span>
<span class="sd">            lll_reduce (bool): whether to apply LLL reduction</span>
<span class="sd">            center_slab (bool): whether to center the slab</span>
<span class="sd">            primitive (bool): whether to reduce slabs to most primitive cell</span>
<span class="sd">            max_normal_search (int): maximum index to include in linear</span>
<span class="sd">                combinations of indices to find c lattice vector orthogonal</span>
<span class="sd">                to slab surface</span>
<span class="sd">            shift (float): shift to get termination</span>
<span class="sd">            tol (float): tolerance for primitive cell finding</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span> <span class="o">=</span> <span class="n">miller_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_slab_size</span> <span class="o">=</span> <span class="n">min_slab_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_vacuum_size</span> <span class="o">=</span> <span class="n">min_vacuum_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lll_reduce</span> <span class="o">=</span> <span class="n">lll_reduce</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_slab</span> <span class="o">=</span> <span class="n">center_slab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_unit_planes</span> <span class="o">=</span> <span class="n">in_unit_planes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primitive</span> <span class="o">=</span> <span class="n">primitive</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_normal_search</span> <span class="o">=</span> <span class="n">max_normal_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>

<div class="viewcode-block" id="SlabTransformation.apply_transformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.SlabTransformation.apply_transformation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="n">SlabGenerator</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_slab_size</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">min_vacuum_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lll_reduce</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">center_slab</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_unit_planes</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">primitive</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_normal_search</span><span class="p">)</span>
        <span class="n">slab</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">get_slab</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">slab</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_one_to_many</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="GrainBoundaryTransformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.GrainBoundaryTransformation">[docs]</a><span class="k">class</span> <span class="nc">GrainBoundaryTransformation</span><span class="p">(</span><span class="n">AbstractTransformation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A transformation that creates a gb from a bulk structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotation_axis</span><span class="p">,</span> <span class="n">rotation_angle</span><span class="p">,</span> <span class="n">expand_times</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">vacuum_thickness</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">ab_shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">normal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plane</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_search</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                 <span class="n">tol_coi</span><span class="o">=</span><span class="mf">1.e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            rotation_axis (list): Rotation axis of GB in the form of a list of integer</span>
<span class="sd">                e.g.: [1, 1, 0]</span>
<span class="sd">            rotation_angle (float, in unit of degree): rotation angle used to generate GB.</span>
<span class="sd">                Make sure the angle is accurate enough. You can use the enum* functions</span>
<span class="sd">                in this class to extract the accurate angle.</span>
<span class="sd">                e.g.: The rotation angle of sigma 3 twist GB with the rotation axis</span>
<span class="sd">                [1, 1, 1] and GB plane (1, 1, 1) can be 60.000000000 degree.</span>
<span class="sd">                If you do not know the rotation angle, but know the sigma value, we have</span>
<span class="sd">                provide the function get_rotation_angle_from_sigma which is able to return</span>
<span class="sd">                all the rotation angles of sigma value you provided.</span>
<span class="sd">            expand_times (int): The multiple times used to expand one unit grain to larger grain.</span>
<span class="sd">                This is used to tune the grain length of GB to warrant that the two GBs in one</span>
<span class="sd">                cell do not interact with each other. Default set to 4.</span>
<span class="sd">            vacuum_thickness (float): The thickness of vacuum that you want to insert between</span>
<span class="sd">                two grains of the GB. Default to 0.</span>
<span class="sd">            ab_shift (list of float, in unit of a, b vectors of Gb): in plane shift of two grains</span>
<span class="sd">            normal (logic):</span>
<span class="sd">                determine if need to require the c axis of top grain (first transformation matrix)</span>
<span class="sd">                perperdicular to the surface or not.</span>
<span class="sd">                default to false.</span>
<span class="sd">            ratio (list of integers):</span>
<span class="sd">                    lattice axial ratio.</span>
<span class="sd">                    For cubic system, ratio is not needed.</span>
<span class="sd">                    For tetragonal system, ratio = [mu, mv], list of two integers,</span>
<span class="sd">                    that is, mu/mv = c2/a2. If it is irrational, set it to none.</span>
<span class="sd">                    For orthorhombic system, ratio = [mu, lam, mv], list of three integers,</span>
<span class="sd">                    that is, mu:lam:mv = c2:b2:a2. If irrational for one axis, set it to None.</span>
<span class="sd">                    e.g. mu:lam:mv = c2,None,a2, means b2 is irrational.</span>
<span class="sd">                    For rhombohedral system, ratio = [mu, mv], list of two integers,</span>
<span class="sd">                    that is, mu/mv is the ratio of (1+2*cos(alpha))/cos(alpha).</span>
<span class="sd">                    If irrational, set it to None.</span>
<span class="sd">                    For hexagonal system, ratio = [mu, mv], list of two integers,</span>
<span class="sd">                    that is, mu/mv = c2/a2. If it is irrational, set it to none.</span>
<span class="sd">            plane (list): Grain boundary plane in the form of a list of integers</span>
<span class="sd">                e.g.: [1, 2, 3]. If none, we set it as twist GB. The plane will be perpendicular</span>
<span class="sd">                to the rotation axis.</span>
<span class="sd">            max_search (int): max search for the GB lattice vectors that give the smallest GB</span>
<span class="sd">                lattice. If normal is true, also max search the GB c vector that perpendicular</span>
<span class="sd">                to the plane. For complex GB, if you want to speed up, you can reduce this value.</span>
<span class="sd">                But too small of this value may lead to error.</span>
<span class="sd">            tol_coi (float): tolerance to find the coincidence sites. When making approximations to</span>
<span class="sd">                the ratio needed to generate the GB, you probably need to increase this tolerance to</span>
<span class="sd">                obtain the correct number of coincidence sites. To check the number of coincidence</span>
<span class="sd">                sites are correct or not, you can compare the generated Gb object&#39;s sigma with enum*</span>
<span class="sd">                sigma values (what user expected by input).</span>
<span class="sd">        Returns:</span>
<span class="sd">           Grain boundary structure (Gb (Structure) object).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotation_axis</span> <span class="o">=</span> <span class="n">rotation_axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span> <span class="o">=</span> <span class="n">rotation_angle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expand_times</span> <span class="o">=</span> <span class="n">expand_times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vacuum_thickness</span> <span class="o">=</span> <span class="n">vacuum_thickness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ab_shift</span> <span class="o">=</span> <span class="n">ab_shift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plane</span> <span class="o">=</span> <span class="n">plane</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_search</span> <span class="o">=</span> <span class="n">max_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol_coi</span> <span class="o">=</span> <span class="n">tol_coi</span>

<div class="viewcode-block" id="GrainBoundaryTransformation.apply_transformation"><a class="viewcode-back" href="../../../pymatgen.transformations.advanced_transformations.html#pymatgen.transformations.advanced_transformations.GrainBoundaryTransformation.apply_transformation">[docs]</a>    <span class="k">def</span> <span class="nf">apply_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="n">gbg</span> <span class="o">=</span> <span class="n">GBGenerator</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
        <span class="n">gb_struct</span> <span class="o">=</span> <span class="n">gbg</span><span class="o">.</span><span class="n">gb_from_parameters</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_axis</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotation_angle</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expand_times</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vacuum_thickness</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ab_shift</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_search</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tol_coi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gb_struct</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_one_to_many</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>
</pre></div>

          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pymatgen 2018.9.12 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../pymatgen.html" >pymatgen</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2011, Pymatgen Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.9.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>