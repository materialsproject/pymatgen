
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pymatgen.analysis.surface_analysis &#8212; pymatgen 2018.9.12 documentation</title>
    <link rel="stylesheet" href="../../../_static/proBlue.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pymatgen 2018.9.12 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../pymatgen.html" accesskey="U">pymatgen</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.analysis.surface_analysis</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="c1"># Copyright (c) Pymatgen Development Team.</span>
<span class="c1"># Distributed under the terms of the MIT License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">TODO:</span>
<span class="sd">    -Still assumes individual elements have their own chempots</span>
<span class="sd">        in a molecular adsorbate instead of considering a single</span>
<span class="sd">        chempot for a single molecular adsorbate. E.g. for an OH</span>
<span class="sd">        adsorbate, the surface energy is a function of delu_O and</span>
<span class="sd">        delu_H instead of delu_OH</span>
<span class="sd">    -Need a method to automatically get chempot range when</span>
<span class="sd">        dealing with non-stoichiometric slabs</span>
<span class="sd">    -Simplify the input for SurfaceEnergyPlotter such that the</span>
<span class="sd">        user does not need to generate a dict</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">sympy.solvers</span> <span class="k">import</span> <span class="n">linsolve</span><span class="p">,</span> <span class="n">solve</span>

<span class="kn">from</span> <span class="nn">pymatgen.core.composition</span> <span class="k">import</span> <span class="n">Composition</span>
<span class="kn">from</span> <span class="nn">pymatgen</span> <span class="k">import</span> <span class="n">Structure</span>
<span class="kn">from</span> <span class="nn">pymatgen.entries.computed_entries</span> <span class="k">import</span> <span class="n">ComputedStructureEntry</span>
<span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="k">import</span> <span class="n">SpacegroupAnalyzer</span>
<span class="kn">from</span> <span class="nn">pymatgen.analysis.wulff</span> <span class="k">import</span> <span class="n">WulffShape</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.plotting</span> <span class="k">import</span> <span class="n">pretty_plot</span>
<span class="kn">from</span> <span class="nn">pymatgen.io.vasp.outputs</span> <span class="k">import</span> <span class="n">Outcar</span><span class="p">,</span> <span class="n">Locpot</span><span class="p">,</span> <span class="n">Poscar</span>

<span class="n">EV_PER_ANG2_TO_JOULES_PER_M2</span> <span class="o">=</span> <span class="mf">16.0217656</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Richard Tran&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2017, The Materials Virtual Lab&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.2&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Richard Tran&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="s2">&quot;Joseph Montoya, Xianguo Li&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;rit001@eng.ucsd.edu&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;8/24/17&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines tools to analyze surface and adsorption related</span>
<span class="sd">quantities as well as related plots. If you use this module, please</span>
<span class="sd">consider citing the following works::</span>

<span class="sd">    R. Tran, Z. Xu, B. Radhakrishnan, D. Winston, W. Sun, K. A. Persson,</span>
<span class="sd">        S. P. Ong, &quot;Surface Energies of Elemental Crystals&quot;, Scientific</span>
<span class="sd">        Data, 2016, 3:160080, doi: 10.1038/sdata.2016.80.</span>

<span class="sd">    and</span>

<span class="sd">    Kang, S., Mo, Y., Ong, S. P., &amp; Ceder, G. (2014). Nanoscale</span>
<span class="sd">        stabilization of sodium oxides: Implications for Na-O2 batteries.</span>
<span class="sd">        Nano Letters, 14(2), 1016â€“1020. https://doi.org/10.1021/nl404557w</span>

<span class="sd">    and</span>

<span class="sd">    Montoya, J. H., &amp; Persson, K. A. (2017). A high-throughput framework</span>
<span class="sd">        for determining adsorption energies on solid surfaces. Npj</span>
<span class="sd">        Computational Materials, 3(1), 14.</span>
<span class="sd">        https://doi.org/10.1038/s41524-017-0017-z</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="SlabEntry"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SlabEntry">[docs]</a><span class="k">class</span> <span class="nc">SlabEntry</span><span class="p">(</span><span class="n">ComputedStructureEntry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ComputedStructureEntry object encompassing all data relevant to a </span>
<span class="sd">        slab for analyzing surface thermodynamics.</span>

<span class="sd">    .. attribute:: miller_index</span>

<span class="sd">        Miller index of plane parallel to surface.</span>

<span class="sd">    .. attribute:: label</span>

<span class="sd">        Brief description for this slab.</span>

<span class="sd">    .. attribute:: adsorbates</span>

<span class="sd">        List of ComputedStructureEntry for the types of adsorbates</span>

<span class="sd">    ..attribute:: clean_entry</span>

<span class="sd">        SlabEntry for the corresponding clean slab for an adsorbed slab</span>

<span class="sd">    ..attribute:: ads_entries_dict</span>

<span class="sd">        Dictionary where the key is the reduced composition of the</span>
<span class="sd">            adsorbate entry and value is the entry itself</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                 <span class="n">parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">entry_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">adsorbates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clean_entry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a SlabEntry containing all relevant surface thermodynamics data.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure (Slab): The primary slab associated with this entry.</span>
<span class="sd">            energy (float): Energy from total energy calculation</span>
<span class="sd">            miller_index (tuple(h, k, l)): Miller index of plane parallel</span>
<span class="sd">                to surface</span>
<span class="sd">            correction (float): See ComputedSlabEntry</span>
<span class="sd">            parameters (dict): See ComputedSlabEntry</span>
<span class="sd">            data (dict): See ComputedSlabEntry</span>
<span class="sd">            entry_id (obj): See ComputedSlabEntry</span>
<span class="sd">            data (dict): See ComputedSlabEntry</span>
<span class="sd">            entry_id (str): See ComputedSlabEntry</span>
<span class="sd">            label (str): Any particular label for this slab, e.g. &quot;Tasker 2&quot;,</span>
<span class="sd">                &quot;non-stoichiometric&quot;, &quot;reconstructed&quot;</span>
<span class="sd">            adsorbates ([ComputedStructureEntry]): List of reference entries</span>
<span class="sd">                for the adsorbates on the slab, can be an isolated molecule</span>
<span class="sd">                (e.g. O2 for O or O2 adsorption), a bulk structure (eg. fcc</span>
<span class="sd">                Cu for Cu adsorption) or anything.</span>
<span class="sd">            clean_entry (ComputedStructureEntry): If the SlabEntry is for an</span>
<span class="sd">                adsorbed slab, this is the corresponding SlabEntry for the</span>
<span class="sd">                clean slab</span>
<span class="sd">            marker (str): Custom marker for gamma plots (&quot;--&quot; and &quot;-&quot; are typical)</span>
<span class="sd">            color (str or rgba): Custom color for gamma plots</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span> <span class="o">=</span> <span class="n">miller_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adsorbates</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">adsorbates</span> <span class="k">else</span> <span class="n">adsorbates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clean_entry</span> <span class="o">=</span> <span class="n">clean_entry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ads_entries_dict</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ads</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]):</span> \
                                     <span class="n">ads</span> <span class="k">for</span> <span class="n">ads</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adsorbates</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mark</span> <span class="o">=</span> <span class="n">marker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">SlabEntry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">structure</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">correction</span><span class="o">=</span><span class="n">correction</span><span class="p">,</span>
            <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">entry_id</span><span class="o">=</span><span class="n">entry_id</span><span class="p">)</span>

<div class="viewcode-block" id="SlabEntry.as_dict"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SlabEntry.as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns dict which contains Slab Entry data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;@module&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
             <span class="s2">&quot;@class&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">}</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;miller_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;coverage&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coverage</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;adsorbates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adsorbates</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;clean_entry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean_entry</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="SlabEntry.gibbs_binding_energy"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SlabEntry.gibbs_binding_energy">[docs]</a>    <span class="k">def</span> <span class="nf">gibbs_binding_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eads</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the adsorption energy or Gibb&#39;s binding energy</span>
<span class="sd">            of an adsorbate on a surface</span>
<span class="sd">        Args:</span>
<span class="sd">            eads (bool): Whether to calculate the adsorption energy</span>
<span class="sd">                (True) or the binding energy (False) which is just</span>
<span class="sd">                adsorption energy normalized by number of adsorbates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unit_primitive_area</span>
        <span class="n">Nads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nads_in_slab</span>

        <span class="n">BE</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean_entry</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span> <span class="o">/</span> <span class="n">Nads</span> <span class="o">-</span> \
             <span class="nb">sum</span><span class="p">([</span><span class="n">ads</span><span class="o">.</span><span class="n">energy_per_atom</span> <span class="k">for</span> <span class="n">ads</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">adsorbates</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">BE</span> <span class="o">*</span> <span class="n">Nads</span> <span class="k">if</span> <span class="n">eads</span> <span class="k">else</span> <span class="n">BE</span></div>

<div class="viewcode-block" id="SlabEntry.surface_energy"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SlabEntry.surface_energy">[docs]</a>    <span class="k">def</span> <span class="nf">surface_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ucell_entry</span><span class="p">,</span> <span class="n">ref_entries</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the surface energy of this SlabEntry.</span>
<span class="sd">        Args:</span>
<span class="sd">            ucell_entry (entry): An entry object for the bulk</span>
<span class="sd">            ref_entries (list: [entry]): A list of entries for each type</span>
<span class="sd">                of element to be used as a reservoir for nonstoichiometric</span>
<span class="sd">                systems. The length of this list MUST be n-1 where n is the</span>
<span class="sd">                number of different elements in the bulk entry. The chempot</span>
<span class="sd">                of the element ref_entry that is not in the list will be</span>
<span class="sd">                treated as a variable.</span>

<span class="sd">        Returns (Add (Sympy class)): Surface energy</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set up</span>
        <span class="n">ref_entries</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">ref_entries</span> <span class="k">else</span> <span class="n">ref_entries</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;E_surf&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;Ebulk&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">))</span>
        <span class="n">ucell_comp</span> <span class="o">=</span> <span class="n">ucell_entry</span><span class="o">.</span><span class="n">composition</span>
        <span class="n">ucell_reduced_comp</span> <span class="o">=</span> <span class="n">ucell_comp</span><span class="o">.</span><span class="n">reduced_composition</span>
        <span class="n">ref_entries_dict</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]):</span> \
                                <span class="n">ref</span> <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">ref_entries</span><span class="p">}</span>
        <span class="n">ref_entries_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ads_entries_dict</span><span class="p">)</span>

        <span class="c1"># Calculate Gibbs free energy of the bulk per unit formula</span>
        <span class="n">gbulk</span> <span class="o">=</span> <span class="n">ucell_entry</span><span class="o">.</span><span class="n">energy</span> <span class="o">/</span> \
                <span class="n">ucell_comp</span><span class="o">.</span><span class="n">get_integer_formula_and_factor</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># First we get the contribution to the bulk energy</span>
        <span class="c1"># from each element with an existing ref_entry.</span>
        <span class="n">bulk_energy</span><span class="p">,</span> <span class="n">gbulk_eqn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">el</span><span class="p">,</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">ref_entries_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">N</span><span class="p">,</span> <span class="n">delu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()[</span><span class="n">el</span><span class="p">],</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;delu_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">ucell_comp</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">gbulk_eqn</span> <span class="o">+=</span> <span class="n">ucell_reduced_comp</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">delu</span> <span class="o">+</span> <span class="n">ref</span><span class="o">.</span><span class="n">energy_per_atom</span><span class="p">)</span>
            <span class="n">bulk_energy</span> <span class="o">+=</span> <span class="n">N</span> <span class="o">*</span> <span class="p">(</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;delu_&quot;</span> <span class="o">+</span> <span class="n">el</span><span class="p">)</span> <span class="o">+</span> <span class="n">ref</span><span class="o">.</span><span class="n">energy_per_atom</span><span class="p">)</span>

        <span class="c1"># Next, we add the contribution to the bulk energy from</span>
        <span class="c1"># the variable element (the element without a ref_entry),</span>
        <span class="c1"># as a function of the other elements</span>
        <span class="k">for</span> <span class="n">ref_el</span> <span class="ow">in</span> <span class="n">ucell_comp</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">ref_el</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ref_entries_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">break</span>
        <span class="n">refEperA</span> <span class="o">=</span> <span class="p">(</span><span class="n">gbulk</span> <span class="o">-</span> <span class="n">gbulk_eqn</span><span class="p">)</span> <span class="o">/</span> <span class="n">ucell_reduced_comp</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()[</span><span class="n">ref_el</span><span class="p">]</span>
        <span class="n">bulk_energy</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()[</span><span class="n">ref_el</span><span class="p">]</span> <span class="o">*</span> <span class="n">refEperA</span>
        <span class="n">se</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;E_surf&quot;</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;Ebulk&quot;</span><span class="p">):</span> <span class="n">bulk_energy</span><span class="p">,</span>
                         <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_area</span><span class="p">})</span>


        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Float&quot;</span> <span class="k">else</span> <span class="n">se</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">get_unit_primitive_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the surface area of the adsorbed system per</span>
<span class="sd">        unit area of the primitive slab system.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">A_ads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_area</span>
        <span class="n">A_clean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean_entry</span><span class="o">.</span><span class="n">surface_area</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">A_ads</span> <span class="o">/</span> <span class="n">A_clean</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">get_monolayer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the primitive unit surface area density of the</span>
<span class="sd">            adsorbate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">unit_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unit_primitive_area</span>
        <span class="n">Nsurfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nsurfs_ads_in_slab</span>
        <span class="n">Nads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nads_in_slab</span>
        <span class="k">return</span> <span class="n">Nads</span> <span class="o">/</span> <span class="p">(</span><span class="n">unit_a</span> <span class="o">*</span> <span class="n">Nsurfs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Nads_in_slab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the TOTAL number of adsorbates in the slab on BOTH sides</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> \
                    <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ads_entries_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Nsurfs_ads_in_slab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the TOTAL number of adsorbed surfaces in the slab</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">species_and_occu</span><span class="o">.</span><span class="n">weight</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">struct</span><span class="p">]</span>
        <span class="n">center_of_mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
                                    <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">Nsurfs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Are there adsorbates on top surface?</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">site</span><span class="o">.</span><span class="n">species_string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ads_entries_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> \
                <span class="n">site</span> <span class="ow">in</span> <span class="n">struct</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">center_of_mass</span><span class="p">[</span><span class="mi">2</span><span class="p">]]):</span>
            <span class="n">Nsurfs</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Are there adsorbates on bottom surface?</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">site</span><span class="o">.</span><span class="n">species_string</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ads_entries_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> \
                <span class="n">site</span> <span class="ow">in</span> <span class="n">struct</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">center_of_mass</span><span class="p">[</span><span class="mi">2</span><span class="p">]]):</span>
            <span class="n">Nsurfs</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">Nsurfs</span>

<div class="viewcode-block" id="SlabEntry.from_dict"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SlabEntry.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a SlabEntry by reading in an dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">structure</span> <span class="o">=</span> <span class="n">SlabEntry</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">])</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">SlabEntry</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">])</span>
        <span class="n">miller_index</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;miller_index&quot;</span><span class="p">]</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
        <span class="n">coverage</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;coverage&quot;</span><span class="p">]</span>
        <span class="n">adsorbates</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;adsorbates&quot;</span><span class="p">]</span>
        <span class="n">clean_entry</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;clean_entry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clean_entry</span>

        <span class="k">return</span> <span class="n">SlabEntry</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                         <span class="n">coverage</span><span class="o">=</span><span class="n">coverage</span><span class="p">,</span> <span class="n">adsorbates</span><span class="o">=</span><span class="n">adsorbates</span><span class="p">,</span>
                         <span class="n">clean_entry</span><span class="o">=</span><span class="n">clean_entry</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">surface_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the surface area of the slab</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cleaned_up_slab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a slab with the adsorbates removed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ads_strs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ads_entries_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">cleaned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cleaned</span><span class="o">.</span><span class="n">remove_species</span><span class="p">(</span><span class="n">ads_strs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cleaned</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">create_slab_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a label (str) for this particular slab based</span>
<span class="sd">            on composition, coverage and Miller index.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;label&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>

        <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">)</span>
        <span class="n">ads_strs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ads_entries_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">cleaned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cleaned_up_slab</span>
        <span class="n">label</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cleaned</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">reduced_composition</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adsorbates</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ads</span> <span class="ow">in</span> <span class="n">ads_strs</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;+</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ads</span><span class="p">)</span>
            <span class="n">label</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;, </span><span class="si">%.3f</span><span class="s2"> ML&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_monolayer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">label</span>

<div class="viewcode-block" id="SlabEntry.from_computed_structure_entry"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SlabEntry.from_computed_structure_entry">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_computed_structure_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">adsorbates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clean_entry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns SlabEntry from a ComputedStructureEntry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SlabEntry</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                         <span class="n">adsorbates</span><span class="o">=</span><span class="n">adsorbates</span><span class="p">,</span> <span class="n">clean_entry</span><span class="o">=</span><span class="n">clean_entry</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SurfaceEnergyPlotter"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter">[docs]</a><span class="k">class</span> <span class="nc">SurfaceEnergyPlotter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class used for generating plots to analyze the thermodynamics of surfaces</span>
<span class="sd">        of a material. Produces stability maps of different slab configurations,</span>
<span class="sd">        phases diagrams of two parameters to determine stability of configurations</span>
<span class="sd">        (future release), and Wulff shapes.</span>

<span class="sd">    .. attribute:: all_slab_entries</span>

<span class="sd">        Either a list of SlabEntry objects (note for a list, the SlabEntry must</span>
<span class="sd">            have the adsorbates and clean_entry parameter pulgged in) or a Nested</span>
<span class="sd">            dictionary containing a list of entries for slab calculations as</span>
<span class="sd">            items and the corresponding Miller index of the slab as the key.</span>
<span class="sd">            To account for adsorption, each value is a sub-dictionary with the</span>
<span class="sd">            entry of a clean slab calculation as the sub-key and a list of</span>
<span class="sd">            entries for adsorption calculations as the sub-value. The sub-value</span>
<span class="sd">            can contain different adsorption configurations such as a different</span>
<span class="sd">            site or a different coverage, however, ordinarily only the most stable</span>
<span class="sd">            configuration for a particular coverage will be considered as the</span>
<span class="sd">            function of the adsorbed surface energy has an intercept dependent on</span>
<span class="sd">            the adsorption energy (ie an adsorption site with a higher adsorption</span>
<span class="sd">            energy will always provide a higher surface energy than a site with a</span>
<span class="sd">            lower adsorption energy). An example parameter is provided:</span>
<span class="sd">            {(h1,k1,l1): {clean_entry1: [ads_entry1, ads_entry2, ...],</span>
<span class="sd">                          clean_entry2: [...], ...}, (h2,k2,l2): {...}}</span>
<span class="sd">            where clean_entry1 can be a pristine surface and clean_entry2 can be a</span>
<span class="sd">            reconstructed surface while ads_entry1 can be adsorption at site 1 with</span>
<span class="sd">            a 2x2 coverage while ads_entry2 can have a 3x3 coverage. If adsorption</span>
<span class="sd">            entries are present (i.e. if all_slab_entries[(h,k,l)][clean_entry1]), we</span>
<span class="sd">            consider adsorption in all plots and analysis for this particular facet.</span>

<span class="sd">    ..attribute:: color_dict</span>

<span class="sd">        Dictionary of colors (r,g,b,a) when plotting surface energy stability. The</span>
<span class="sd">            keys are individual surface entries where clean surfaces have a solid</span>
<span class="sd">            color while the corresponding adsorbed surface will be transparent.</span>

<span class="sd">    .. attribute:: ucell_entry</span>

<span class="sd">        ComputedStructureEntry of the bulk reference for this particular material.</span>

<span class="sd">    .. attribute:: ref_entries</span>

<span class="sd">        List of ComputedStructureEntries to be used for calculating chemical potential.</span>

<span class="sd">    .. attribute:: color_dict</span>

<span class="sd">        Randomly generated dictionary of colors associated with each facet.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_slab_entries</span><span class="p">,</span> <span class="n">ucell_entry</span><span class="p">,</span> <span class="n">ref_entries</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Object for plotting surface energy in different ways for clean and</span>
<span class="sd">            adsorbed surfaces.</span>
<span class="sd">        Args:</span>
<span class="sd">            all_slab_entries (dict or list): Dictionary or list containing</span>
<span class="sd">                all entries for slab calculations. See attributes.</span>
<span class="sd">            ucell_entry (ComputedStructureEntry): ComputedStructureEntry</span>
<span class="sd">                of the bulk reference for this particular material.</span>
<span class="sd">            ref_entries ([ComputedStructureEntries]): A list of entries for</span>
<span class="sd">                each type of element to be used as a reservoir for</span>
<span class="sd">                nonstoichiometric systems. The length of this list MUST be</span>
<span class="sd">                n-1 where n is the number of different elements in the bulk</span>
<span class="sd">                entry. The bulk energy term in the grand surface potential can</span>
<span class="sd">                be defined by a summation of the chemical potentials for each</span>
<span class="sd">                element in the system. As the bulk energy is already provided,</span>
<span class="sd">                one can solve for one of the chemical potentials as a function</span>
<span class="sd">                of the other chemical potetinals and bulk energy. i.e. there</span>
<span class="sd">                are n-1 variables (chempots). e.g. if your ucell_entry is for</span>
<span class="sd">                LiFePO4 than your ref_entries should have an entry for Li, Fe,</span>
<span class="sd">                and P if you want to use the chempot of O as the variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ucell_entry</span> <span class="o">=</span> <span class="n">ucell_entry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_entries</span> <span class="o">=</span> <span class="n">ref_entries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span> <span class="o">=</span> <span class="n">all_slab_entries</span> <span class="k">if</span> \
            <span class="nb">type</span><span class="p">(</span><span class="n">all_slab_entries</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;dict&quot;</span> <span class="k">else</span> \
            <span class="n">entry_dict_from_list</span><span class="p">(</span><span class="n">all_slab_entries</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_palette_dict</span><span class="p">()</span>

        <span class="n">se_dict</span><span class="p">,</span> <span class="n">as_coeffs_dict</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">clean</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">se</span> <span class="o">=</span> <span class="n">clean</span><span class="o">.</span><span class="n">surface_energy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ucell_entry</span><span class="p">,</span> <span class="n">ref_entries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_entries</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span><span class="p">:</span>
                    <span class="n">se_dict</span><span class="p">[</span><span class="n">clean</span><span class="p">]</span> <span class="o">=</span> <span class="n">se</span>
                    <span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">clean</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">se</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">se_dict</span><span class="p">[</span><span class="n">clean</span><span class="p">]</span> <span class="o">=</span> <span class="n">se</span>
                    <span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">clean</span><span class="p">]</span> <span class="o">=</span> <span class="n">se</span><span class="o">.</span><span class="n">as_coefficients_dict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">dope</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">][</span><span class="n">clean</span><span class="p">]:</span>
                    <span class="n">se</span> <span class="o">=</span> <span class="n">dope</span><span class="o">.</span><span class="n">surface_energy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ucell_entry</span><span class="p">,</span> <span class="n">ref_entries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_entries</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span><span class="p">:</span>
                        <span class="n">se_dict</span><span class="p">[</span><span class="n">dope</span><span class="p">]</span> <span class="o">=</span> <span class="n">se</span>
                        <span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">dope</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="n">se</span><span class="p">}</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">se_dict</span><span class="p">[</span><span class="n">dope</span><span class="p">]</span> <span class="o">=</span> <span class="n">se</span>
                        <span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">dope</span><span class="p">]</span> <span class="o">=</span> <span class="n">se</span><span class="o">.</span><span class="n">as_coefficients_dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surfe_dict</span> <span class="o">=</span> <span class="n">se_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span> <span class="o">=</span> <span class="n">as_coeffs_dict</span>

        <span class="n">list_of_chempots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">du</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">du</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">list_of_chempots</span><span class="p">:</span>
                    <span class="n">list_of_chempots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">du</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_of_chempots</span> <span class="o">=</span> <span class="n">list_of_chempots</span>

<div class="viewcode-block" id="SurfaceEnergyPlotter.get_stable_entry_at_u"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.get_stable_entry_at_u">[docs]</a>    <span class="k">def</span> <span class="nf">get_stable_entry_at_u</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">delu_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delu_default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                              <span class="n">no_doped</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">no_clean</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the entry corresponding to the most stable slab for a particular</span>
<span class="sd">            facet at a specific chempot. We assume that surface energy is constant</span>
<span class="sd">            so all free variables must be set with delu_dict, otherwise they are</span>
<span class="sd">            assumed to be equal to delu_default.</span>

<span class="sd">        Args:</span>
<span class="sd">            miller_index ((h,k,l)): The facet to find the most stable slab in</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            delu_default (float): Default value for all unset chemical potentials</span>
<span class="sd">            no_doped (bool): Consider stability of clean slabs only.</span>
<span class="sd">            no_clean (bool): Consider stability of doped slabs only.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SlabEntry, surface_energy (float)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">all_delu_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_all_variables</span><span class="p">(</span><span class="n">delu_dict</span><span class="p">,</span> <span class="n">delu_default</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">get_coeffs</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">du</span> <span class="ow">in</span> <span class="n">all_delu_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">e</span><span class="p">])</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;float&#39;</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">du</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">du</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>

        <span class="n">all_entries</span><span class="p">,</span> <span class="n">all_coeffs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">miller_index</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">no_clean</span><span class="p">:</span>
                <span class="n">all_entries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
                <span class="n">all_coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_coeffs</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">no_doped</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ads_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">miller_index</span><span class="p">][</span><span class="n">entry</span><span class="p">]:</span>
                    <span class="n">all_entries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ads_entry</span><span class="p">)</span>
                    <span class="n">all_coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_coeffs</span><span class="p">(</span><span class="n">ads_entry</span><span class="p">))</span>

        <span class="n">du_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_delu_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="n">all_gamma</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">all_coeffs</span><span class="p">,</span> <span class="n">du_vals</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">all_entries</span><span class="p">[</span><span class="n">all_gamma</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">all_gamma</span><span class="p">))],</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">all_gamma</span><span class="p">))</span></div>

<div class="viewcode-block" id="SurfaceEnergyPlotter.wulff_from_chempot"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.wulff_from_chempot">[docs]</a>    <span class="k">def</span> <span class="nf">wulff_from_chempot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delu_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delu_default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
                           <span class="n">no_clean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">no_doped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to get the Wulff shape at a specific chemical potential.</span>

<span class="sd">        Args:</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            delu_default (float): Default value for all unset chemical potentials</span>
<span class="sd">            symprec (float): See WulffShape.</span>
<span class="sd">            no_doped (bool): Consider stability of clean slabs only.</span>
<span class="sd">            no_clean (bool): Consider stability of doped slabs only.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (WulffShape): The WulffShape at u_ref and u_ads.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">latt</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ucell_entry</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span><span class="o">.</span> \
            <span class="n">get_conventional_standard_structure</span><span class="p">()</span><span class="o">.</span><span class="n">lattice</span>

        <span class="n">miller_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">e_surf_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="n">miller_list</span><span class="p">:</span>
            <span class="c1"># For all configurations, calculate surface energy as a</span>
            <span class="c1"># function of u. Use the lowest surface energy (corresponds</span>
            <span class="c1"># to the most stable slab termination at that particular u)</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stable_entry_at_u</span><span class="p">(</span><span class="n">hkl</span><span class="p">,</span> <span class="n">delu_dict</span><span class="o">=</span><span class="n">delu_dict</span><span class="p">,</span>
                                               <span class="n">delu_default</span><span class="o">=</span><span class="n">delu_default</span><span class="p">,</span>
                                               <span class="n">no_clean</span><span class="o">=</span><span class="n">no_clean</span><span class="p">,</span>
                                               <span class="n">no_doped</span><span class="o">=</span><span class="n">no_doped</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">e_surf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">WulffShape</span><span class="p">(</span><span class="n">latt</span><span class="p">,</span> <span class="n">miller_list</span><span class="p">,</span> <span class="n">e_surf_list</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">)</span></div>

<div class="viewcode-block" id="SurfaceEnergyPlotter.area_frac_vs_chempot_plot"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.area_frac_vs_chempot_plot">[docs]</a>    <span class="k">def</span> <span class="nf">area_frac_vs_chempot_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_delu</span><span class="p">,</span> <span class="n">chempot_range</span><span class="p">,</span> <span class="n">delu_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">delu_default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">increments</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">no_clean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">no_doped</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        1D plot. Plots the change in the area contribution</span>
<span class="sd">        of each facet as a function of chemical potential.</span>

<span class="sd">        Args:</span>
<span class="sd">            ref_delu (sympy Symbol): The free variable chempot with the format:</span>
<span class="sd">                Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            chempot_range (list): Min/max range of chemical potential to plot along</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            delu_default (float): Default value for all unset chemical potentials</span>
<span class="sd">            increments (int): Number of data points between min/max or point</span>
<span class="sd">                of intersection. Defaults to 10 points.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Pylab): Plot of area frac on the Wulff shape</span>
<span class="sd">                for each facet vs chemical potential.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">delu_dict</span> <span class="o">=</span> <span class="n">delu_dict</span> <span class="k">if</span> <span class="n">delu_dict</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="n">chempot_range</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">chempot_range</span><span class="p">)</span>
        <span class="n">all_chempots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">chempot_range</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">chempot_range</span><span class="p">),</span>
                                   <span class="n">increments</span><span class="p">)</span>

        <span class="c1"># initialize a dictionary of lists of fractional areas for each hkl</span>
        <span class="n">hkl_area_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">hkl_area_dict</span><span class="p">[</span><span class="n">hkl</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Get plot points for each Miller index</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">all_chempots</span><span class="p">:</span>
            <span class="n">delu_dict</span><span class="p">[</span><span class="n">ref_delu</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
            <span class="n">wulffshape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wulff_from_chempot</span><span class="p">(</span><span class="n">delu_dict</span><span class="o">=</span><span class="n">delu_dict</span><span class="p">,</span> <span class="n">no_clean</span><span class="o">=</span><span class="n">no_clean</span><span class="p">,</span>
                                                 <span class="n">no_doped</span><span class="o">=</span><span class="n">no_doped</span><span class="p">,</span> <span class="n">delu_default</span><span class="o">=</span><span class="n">delu_default</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="n">wulffshape</span><span class="o">.</span><span class="n">area_fraction_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">hkl_area_dict</span><span class="p">[</span><span class="n">hkl</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wulffshape</span><span class="o">.</span><span class="n">area_fraction_dict</span><span class="p">[</span><span class="n">hkl</span><span class="p">])</span>

        <span class="c1"># Plot the area fraction vs chemical potential for each facet</span>
        <span class="n">plt</span> <span class="o">=</span> <span class="n">pretty_plot</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">clean_entry</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Ignore any facets that never show up on the</span>
            <span class="c1"># Wulff shape regardless of chemical potential</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">hkl_area_dict</span><span class="p">[</span><span class="n">hkl</span><span class="p">]]):</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">all_chempots</span><span class="p">,</span> <span class="n">hkl_area_dict</span><span class="p">[</span><span class="n">hkl</span><span class="p">],</span>
                         <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">color_dict</span><span class="p">[</span><span class="n">clean_entry</span><span class="p">],</span>
                         <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">hkl</span><span class="p">))</span>

        <span class="c1"># Make the figure look nice</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Fractional area $A^</span><span class="si">{Wulff}</span><span class="s2">_</span><span class="si">{hkl}</span><span class="s2">/A^</span><span class="si">{Wulff}</span><span class="s2">$&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chempot_plot_addons</span><span class="p">(</span><span class="n">plt</span><span class="p">,</span> <span class="n">chempot_range</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">ref_delu</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="n">axes</span><span class="p">,</span> <span class="n">rect</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pad</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">plt</span></div>

<div class="viewcode-block" id="SurfaceEnergyPlotter.get_surface_equilibrium"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.get_surface_equilibrium">[docs]</a>    <span class="k">def</span> <span class="nf">get_surface_equilibrium</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slab_entries</span><span class="p">,</span> <span class="n">delu_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes in a list of SlabEntries and calculates the chemical potentials</span>
<span class="sd">            at which all slabs in the list coexists simultaneously. Useful for</span>
<span class="sd">            building surface phase diagrams. Note that to solve for x equations</span>
<span class="sd">            (x slab_entries), there must be x free variables (chemical potentials).</span>
<span class="sd">            Adjust delu_dict as need be to get the correct number of free variables.</span>
<span class="sd">        Args:</span>
<span class="sd">            slab_entries (array): The coefficients of the first equation</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (array): Array containing a solution to x equations with x</span>
<span class="sd">                variables (x-1 chemical potential and 1 surface energy)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate all possible coefficients</span>
        <span class="n">all_parameters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_eqns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">slab_entry</span> <span class="ow">in</span> <span class="n">slab_entries</span><span class="p">:</span>
            <span class="n">se</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surfe_dict</span><span class="p">[</span><span class="n">slab_entry</span><span class="p">]</span>

            <span class="c1"># remove the free chempots we wish to keep constant and</span>
            <span class="c1"># set the equation to 0 (subtract gamma from both sides)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span><span class="p">:</span>
                <span class="n">all_eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">se</span> <span class="o">-</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;gamma&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="n">se</span> <span class="o">=</span> <span class="n">sub_chempots</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">delu_dict</span><span class="p">)</span> <span class="k">if</span> <span class="n">delu_dict</span> <span class="k">else</span> <span class="n">se</span>
                <span class="n">all_eqns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">se</span> <span class="o">-</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;gamma&quot;</span><span class="p">))</span>
                <span class="n">all_parameters</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">se</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
                                       <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_parameters</span><span class="p">])</span>

        <span class="n">all_parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;gamma&quot;</span><span class="p">))</span>
        <span class="c1"># Now solve the system of linear eqns to find the chempot</span>
        <span class="c1"># where the slabs are at equilibrium with each other</span>

        <span class="n">soln</span> <span class="o">=</span> <span class="n">linsolve</span><span class="p">(</span><span class="n">all_eqns</span><span class="p">,</span> <span class="n">all_parameters</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">soln</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No solution&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">soln</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">soln</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_parameters</span><span class="p">)}</span></div>

<div class="viewcode-block" id="SurfaceEnergyPlotter.stable_u_range_dict"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.stable_u_range_dict">[docs]</a>    <span class="k">def</span> <span class="nf">stable_u_range_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chempot_range</span><span class="p">,</span> <span class="n">ref_delu</span><span class="p">,</span> <span class="n">no_doped</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">no_clean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">delu_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">miller_index</span><span class="o">=</span><span class="p">(),</span>
                            <span class="n">dmu_at_0</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_se_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dictionary where each entry is a key pointing to a</span>
<span class="sd">        chemical potential range where the surface of that entry is stable.</span>
<span class="sd">        Does so by enumerating through all possible solutions (intersect)</span>
<span class="sd">        for surface energies of a specific facet.</span>

<span class="sd">        Args:</span>
<span class="sd">            chempot_range ([max_chempot, min_chempot]): Range to consider the</span>
<span class="sd">                stability of the slabs.</span>
<span class="sd">            ref_delu (sympy Symbol): The range stability of each slab is based</span>
<span class="sd">                on the chempot range of this chempot. Should be a sympy Symbol</span>
<span class="sd">                object of the format: Symbol(&quot;delu_el&quot;) where el is the name of</span>
<span class="sd">                the element</span>
<span class="sd">            no_doped (bool): Consider stability of clean slabs only.</span>
<span class="sd">            no_clean (bool): Consider stability of doped slabs only.</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            miller_index (list): Miller index for a specific facet to get a</span>
<span class="sd">                dictionary for.</span>
<span class="sd">            dmu_at_0 (bool): If True, if the surface energies corresponding to</span>
<span class="sd">                the chemical potential range is between a negative and positive</span>
<span class="sd">                value, the value is a list of three chemical potentials with the</span>
<span class="sd">                one in the center corresponding a surface energy of 0. Uselful</span>
<span class="sd">                in identifying unphysical ranges of surface energies and their</span>
<span class="sd">                chemical potential range.</span>
<span class="sd">            return_se_dict (bool): Whether or not to return the corresponding</span>
<span class="sd">                dictionary of surface energies</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">chempot_range</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">chempot_range</span><span class="p">)</span>
        <span class="n">stable_urange_dict</span><span class="p">,</span> <span class="n">se_dict</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>

        <span class="c1"># Get all entries for a specific facet</span>
        <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">entries_in_hkl</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Skip this facet if this is not the facet we want</span>
            <span class="k">if</span> <span class="n">miller_index</span> <span class="ow">and</span> <span class="n">hkl</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">miller_index</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">no_clean</span><span class="p">:</span>
                <span class="n">entries_in_hkl</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">clean</span> <span class="k">for</span> <span class="n">clean</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">]])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">no_doped</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">]:</span>
                    <span class="n">entries_in_hkl</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">ads_entry</span> <span class="k">for</span> <span class="n">ads_entry</span> <span class="ow">in</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">][</span><span class="n">entry</span><span class="p">]])</span>

            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries_in_hkl</span><span class="p">:</span>
                <span class="n">stable_urange_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">se_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># if there is only one entry for this facet, then just give it the</span>
            <span class="c1"># default urange, you can&#39;t make combinations with just 1 item</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">entries_in_hkl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">stable_urange_dict</span><span class="p">[</span><span class="n">entries_in_hkl</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">chempot_range</span>
                <span class="n">u1</span><span class="p">,</span> <span class="n">u2</span> <span class="o">=</span> <span class="n">delu_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">delu_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">u1</span><span class="p">[</span><span class="n">ref_delu</span><span class="p">],</span> <span class="n">u2</span><span class="p">[</span><span class="n">ref_delu</span><span class="p">]</span> <span class="o">=</span> <span class="n">chempot_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">chempot_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">se</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">entries_in_hkl</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">se_dict</span><span class="p">[</span><span class="n">entries_in_hkl</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_chempots</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">u1</span><span class="p">),</span> <span class="n">sub_chempots</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">u2</span><span class="p">)]</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">entries_in_hkl</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="c1"># I&#39;m assuming ref_delu was not set in delu_dict,</span>
                <span class="c1"># so the solution should be for ref_delu</span>
                <span class="n">solution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_surface_equilibrium</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">delu_dict</span><span class="o">=</span><span class="n">delu_dict</span><span class="p">)</span>

                <span class="c1"># Check if this solution is stable</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">solution</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">new_delu_dict</span> <span class="o">=</span> <span class="n">delu_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_delu_dict</span><span class="p">[</span><span class="n">ref_delu</span><span class="p">]</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="n">ref_delu</span><span class="p">]</span>
                <span class="n">stable_entry</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stable_entry_at_u</span><span class="p">(</span><span class="n">hkl</span><span class="p">,</span> <span class="n">new_delu_dict</span><span class="p">,</span>
                                                                 <span class="n">no_doped</span><span class="o">=</span><span class="n">no_doped</span><span class="p">,</span>
                                                                 <span class="n">no_clean</span><span class="o">=</span><span class="n">no_clean</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stable_entry</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Now check if the solution is within the chempot range</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">chempot_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">solution</span><span class="p">[</span><span class="n">ref_delu</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">chempot_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">:</span>
                    <span class="n">stable_urange_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="n">ref_delu</span><span class="p">])</span>
                    <span class="n">se_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>

            <span class="c1"># Now check if all entries have 2 chempot values. If only</span>
            <span class="c1"># one, we need to set the other value as either the upper</span>
            <span class="c1"># limit or lower limit of the user provided chempot_range</span>
            <span class="n">new_delu_dict</span> <span class="o">=</span> <span class="n">delu_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">chempot_range</span><span class="p">:</span>
                <span class="n">new_delu_dict</span><span class="p">[</span><span class="n">ref_delu</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
                <span class="n">entry</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stable_entry_at_u</span><span class="p">(</span><span class="n">hkl</span><span class="p">,</span> <span class="n">delu_dict</span><span class="o">=</span><span class="n">new_delu_dict</span><span class="p">,</span>
                                                          <span class="n">no_doped</span><span class="o">=</span><span class="n">no_doped</span><span class="p">,</span>
                                                          <span class="n">no_clean</span><span class="o">=</span><span class="n">no_clean</span><span class="p">)</span>
                <span class="n">stable_urange_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="n">se_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dmu_at_0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">se_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># if se are of opposite sign, determine chempot when se=0.</span>
                <span class="c1"># Useful for finding a chempot range where se is unphysical</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">stable_urange_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">se_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">se_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># solve for gamma=0</span>
                    <span class="n">se</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span>
                    <span class="n">se_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">stable_urange_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solve</span><span class="p">(</span><span class="n">sub_chempots</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">delu_dict</span><span class="p">),</span>
                                                           <span class="n">ref_delu</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># sort the chempot ranges for each facet</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">stable_urange_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">se_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">se</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">se</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">stable_urange_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span>
                                                         <span class="n">se_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]))]</span>
            <span class="n">stable_urange_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">stable_urange_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">return_se_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stable_urange_dict</span><span class="p">,</span> <span class="n">se_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stable_urange_dict</span></div>

<div class="viewcode-block" id="SurfaceEnergyPlotter.color_palette_dict"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.color_palette_dict">[docs]</a>    <span class="k">def</span> <span class="nf">color_palette_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.35</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to assign each facet a unique color using a dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            alpha (float): Degree of transparency</span>

<span class="sd">        return (dict): Dictionary of colors (r,g,b,a) when plotting surface</span>
<span class="sd">            energy stability. The keys are individual surface entries where</span>
<span class="sd">            clean surfaces have a solid color while the corresponding adsorbed</span>
<span class="sd">            surface will be transparent.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">color_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">rgb_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">rgb_indices</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rgb_indices</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">color</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Get the clean (solid) colors first</span>
            <span class="n">clean_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">clean</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                <span class="n">c</span><span class="p">[</span><span class="n">rgb_indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">clean_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">color_dict</span><span class="p">[</span><span class="n">clean</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>

                <span class="c1"># Now get the adsorbed (transparent) colors</span>
                <span class="k">for</span> <span class="n">ads_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">][</span><span class="n">clean</span><span class="p">]:</span>
                    <span class="n">c_ads</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="n">c_ads</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha</span>
                    <span class="n">color_dict</span><span class="p">[</span><span class="n">ads_entry</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_ads</span>

        <span class="k">return</span> <span class="n">color_dict</span></div>

<div class="viewcode-block" id="SurfaceEnergyPlotter.chempot_vs_gamma_plot_one"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.chempot_vs_gamma_plot_one">[docs]</a>    <span class="k">def</span> <span class="nf">chempot_vs_gamma_plot_one</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plt</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">ref_delu</span><span class="p">,</span> <span class="n">chempot_range</span><span class="p">,</span>
                                  <span class="n">delu_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">delu_default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">JPERM2</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to  help plot the surface energy of a</span>
<span class="sd">        single SlabEntry as a function of chemical potential.</span>

<span class="sd">        Args:</span>
<span class="sd">            plt (Plot): A plot.</span>
<span class="sd">            entry (SlabEntry): Entry of the slab whose surface energy we want</span>
<span class="sd">                to plot</span>
<span class="sd">            ref_delu (sympy Symbol): The range stability of each slab is based</span>
<span class="sd">                on the chempot range of this chempot. Should be a sympy Symbol</span>
<span class="sd">                object of the format: Symbol(&quot;delu_el&quot;) where el is the name of</span>
<span class="sd">                the element</span>
<span class="sd">            chempot_range ([max_chempot, min_chempot]): Range to consider the</span>
<span class="sd">                stability of the slabs.</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            delu_default (float): Default value for all unset chemical potentials</span>
<span class="sd">            label (str): Label of the slab for the legend.</span>
<span class="sd">            JPERM2 (bool): Whether to plot surface energy in /m^2 (True) or</span>
<span class="sd">                eV/A^2 (False)</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Plot): Plot of surface energy vs chemical potential for one entry.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">chempot_range</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">chempot_range</span><span class="p">)</span>

        <span class="c1"># use dashed lines for slabs that are not stoichiometric</span>
        <span class="c1"># wrt bulk. Label with formula if nonstoichiometric</span>
        <span class="n">ucell_comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ucell_entry</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">reduced_composition</span>
        <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">adsorbates</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">cleaned_up_slab</span>
            <span class="n">clean_comp</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">reduced_composition</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clean_comp</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">reduced_composition</span>


        <span class="n">mark</span> <span class="o">=</span> <span class="s1">&#39;--&#39;</span> <span class="k">if</span> <span class="n">ucell_comp</span> <span class="o">!=</span> <span class="n">clean_comp</span> <span class="k">else</span> <span class="s1">&#39;-&#39;</span>

        <span class="n">delu_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_all_variables</span><span class="p">(</span><span class="n">delu_dict</span><span class="p">,</span> <span class="n">delu_default</span><span class="p">)</span>
        <span class="n">delu_dict</span><span class="p">[</span><span class="n">ref_delu</span><span class="p">]</span> <span class="o">=</span> <span class="n">chempot_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">gamma_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span>
        <span class="n">gamma_min</span> <span class="o">=</span> <span class="n">gamma_min</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">gamma_min</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> \
                                 <span class="s2">&quot;float&quot;</span> <span class="k">else</span> <span class="n">sub_chempots</span><span class="p">(</span><span class="n">gamma_min</span><span class="p">,</span> <span class="n">delu_dict</span><span class="p">)</span>
        <span class="n">delu_dict</span><span class="p">[</span><span class="n">ref_delu</span><span class="p">]</span> <span class="o">=</span> <span class="n">chempot_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">gamma_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span>
        <span class="n">gamma_max</span> <span class="o">=</span> <span class="n">gamma_max</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">gamma_max</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> \
                                 <span class="s2">&quot;float&quot;</span> <span class="k">else</span> <span class="n">sub_chempots</span><span class="p">(</span><span class="n">gamma_max</span><span class="p">,</span> <span class="n">delu_dict</span><span class="p">)</span>
        <span class="n">gamma_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">gamma_min</span><span class="p">,</span> <span class="n">gamma_max</span><span class="p">]</span>

        <span class="n">se_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gamma_range</span><span class="p">)</span> <span class="o">*</span> <span class="n">EV_PER_ANG2_TO_JOULES_PER_M2</span> \
            <span class="k">if</span> <span class="n">JPERM2</span> <span class="k">else</span> <span class="n">gamma_range</span>

        <span class="n">mark</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">mark</span> <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">mark</span> <span class="k">else</span> <span class="n">mark</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">color</span> <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">color</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">color_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">chempot_range</span><span class="p">,</span> <span class="n">se_range</span><span class="p">,</span> <span class="n">mark</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">plt</span></div>

<div class="viewcode-block" id="SurfaceEnergyPlotter.chempot_vs_gamma"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.chempot_vs_gamma">[docs]</a>    <span class="k">def</span> <span class="nf">chempot_vs_gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_delu</span><span class="p">,</span> <span class="n">chempot_range</span><span class="p">,</span> <span class="n">miller_index</span><span class="o">=</span><span class="p">(),</span>
                         <span class="n">delu_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">delu_default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">JPERM2</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">show_unstable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="p">[],</span> <span class="n">plt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">no_clean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">no_doped</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">use_entry_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">no_label</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the surface energy as a function of chemical potential.</span>
<span class="sd">            Each facet will be associated with its own distinct colors.</span>
<span class="sd">            Dashed lines will represent stoichiometries different from that</span>
<span class="sd">            of the mpid&#39;s compound. Transparent lines indicates adsorption.</span>

<span class="sd">        Args:</span>
<span class="sd">            ref_delu (sympy Symbol): The range stability of each slab is based</span>
<span class="sd">                on the chempot range of this chempot. Should be a sympy Symbol</span>
<span class="sd">                object of the format: Symbol(&quot;delu_el&quot;) where el is the name of</span>
<span class="sd">                the element</span>
<span class="sd">            chempot_range ([max_chempot, min_chempot]): Range to consider the</span>
<span class="sd">                stability of the slabs.</span>
<span class="sd">            miller_index (list): Miller index for a specific facet to get a</span>
<span class="sd">                dictionary for.</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            delu_default (float): Default value for all unset chemical potentials</span>
<span class="sd">            JPERM2 (bool): Whether to plot surface energy in /m^2 (True) or</span>
<span class="sd">                eV/A^2 (False)</span>
<span class="sd">            show_unstable (bool): Whether or not to show parts of the surface</span>
<span class="sd">                energy plot outside the region of stability.</span>
<span class="sd">            ylim ([ymax, ymin]): Range of y axis</span>
<span class="sd">            no_doped (bool): Whether to plot for the clean slabs only.</span>
<span class="sd">            no_clean (bool): Whether to plot for the doped slabs only.</span>
<span class="sd">            use_entry_labels (bool): If True, will label each slab configuration</span>
<span class="sd">                according to their given label in the SlabEntry object.</span>
<span class="sd">            no_label (bool): Option to turn off labels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Plot): Plot of surface energy vs chempot for all entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">chempot_range</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">chempot_range</span><span class="p">)</span>

        <span class="n">plt</span> <span class="o">=</span> <span class="n">pretty_plot</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">plt</span> <span class="k">else</span> <span class="n">plt</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">miller_index</span> <span class="ow">and</span> <span class="n">hkl</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">miller_index</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># Get the chempot range of each surface if we only</span>
            <span class="c1"># want to show the region where each slab is stable</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">show_unstable</span><span class="p">:</span>
                <span class="n">stable_u_range_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stable_u_range_dict</span><span class="p">(</span><span class="n">chempot_range</span><span class="p">,</span> <span class="n">ref_delu</span><span class="p">,</span>
                                                               <span class="n">no_doped</span><span class="o">=</span><span class="n">no_doped</span><span class="p">,</span>
                                                               <span class="n">delu_dict</span><span class="o">=</span><span class="n">delu_dict</span><span class="p">,</span>
                                                               <span class="n">miller_index</span><span class="o">=</span><span class="n">hkl</span><span class="p">)</span>

            <span class="n">already_labelled</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">for</span> <span class="n">clean_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">]:</span>

                <span class="n">urange</span> <span class="o">=</span> <span class="n">stable_u_range_dict</span><span class="p">[</span><span class="n">clean_entry</span><span class="p">]</span> <span class="k">if</span> \
                    <span class="ow">not</span> <span class="n">show_unstable</span> <span class="k">else</span> <span class="n">chempot_range</span>
                <span class="c1"># Don&#39;t plot if the slab is unstable, plot if it is.</span>
                <span class="k">if</span> <span class="n">urange</span> <span class="o">!=</span> <span class="p">[]:</span>

                    <span class="n">label</span> <span class="o">=</span> <span class="n">clean_entry</span><span class="o">.</span><span class="n">label</span>
                    <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">already_labelled</span><span class="p">:</span>
                        <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">already_labelled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">no_clean</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">use_entry_labels</span><span class="p">:</span>
                            <span class="n">label</span> <span class="o">=</span> <span class="n">clean_entry</span><span class="o">.</span><span class="n">label</span>
                        <span class="k">if</span> <span class="n">no_label</span><span class="p">:</span>
                            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                        <span class="n">plt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chempot_vs_gamma_plot_one</span><span class="p">(</span><span class="n">plt</span><span class="p">,</span> <span class="n">clean_entry</span><span class="p">,</span> <span class="n">ref_delu</span><span class="p">,</span>
                                                             <span class="n">urange</span><span class="p">,</span> <span class="n">delu_dict</span><span class="o">=</span><span class="n">delu_dict</span><span class="p">,</span>
                                                             <span class="n">delu_default</span><span class="o">=</span><span class="n">delu_default</span><span class="p">,</span>
                                                             <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">JPERM2</span><span class="o">=</span><span class="n">JPERM2</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">no_doped</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ads_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">][</span><span class="n">clean_entry</span><span class="p">]:</span>
                        <span class="c1"># Plot the adsorbed slabs</span>
                        <span class="c1"># Generate a label for the type of slab</span>
                        <span class="n">urange</span> <span class="o">=</span> <span class="n">stable_u_range_dict</span><span class="p">[</span><span class="n">ads_entry</span><span class="p">]</span> \
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">show_unstable</span> <span class="k">else</span> <span class="n">chempot_range</span>
                        <span class="k">if</span> <span class="n">urange</span> <span class="o">!=</span> <span class="p">[]:</span>
                            <span class="k">if</span> <span class="n">use_entry_labels</span><span class="p">:</span>
                                <span class="n">label</span> <span class="o">=</span> <span class="n">ads_entry</span><span class="o">.</span><span class="n">label</span>
                            <span class="k">if</span> <span class="n">no_label</span><span class="p">:</span>
                                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                            <span class="n">plt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chempot_vs_gamma_plot_one</span><span class="p">(</span><span class="n">plt</span><span class="p">,</span> <span class="n">ads_entry</span><span class="p">,</span>
                                                                 <span class="n">ref_delu</span><span class="p">,</span> <span class="n">urange</span><span class="p">,</span>
                                                                 <span class="n">delu_dict</span><span class="o">=</span><span class="n">delu_dict</span><span class="p">,</span>
                                                                 <span class="n">delu_default</span><span class="o">=</span><span class="n">delu_default</span><span class="p">,</span>
                                                                 <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                                                                 <span class="n">JPERM2</span><span class="o">=</span><span class="n">JPERM2</span><span class="p">)</span>

        <span class="c1"># Make the figure look nice</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Surface energy (J/$m^</span><span class="si">{2}</span><span class="s2">$)&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">JPERM2</span> \
            <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Surface energy (eV/$\AA^</span><span class="si">{2}</span><span class="s2">$)&quot;</span><span class="p">)</span>
        <span class="n">plt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chempot_plot_addons</span><span class="p">(</span><span class="n">plt</span><span class="p">,</span> <span class="n">chempot_range</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">ref_delu</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span>
                                       <span class="n">axes</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="n">ylim</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">plt</span></div>

<div class="viewcode-block" id="SurfaceEnergyPlotter.monolayer_vs_BE"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.monolayer_vs_BE">[docs]</a>    <span class="k">def</span> <span class="nf">monolayer_vs_BE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot_eads</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the binding energy energy as a function of monolayers (ML), i.e.</span>
<span class="sd">            the fractional area adsorbate density for all facets. For each</span>
<span class="sd">            facet at a specific monlayer, only plot the lowest binding energy.</span>

<span class="sd">        Args:</span>
<span class="sd">            plot_eads (bool): Option to plot the adsorption energy (binding</span>
<span class="sd">                 energy multiplied by number of adsorbates) instead.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Plot): Plot of binding energy vs monolayer for all facets.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">plt</span> <span class="o">=</span> <span class="n">pretty_plot</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">ml_be_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">clean_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">][</span><span class="n">clean_entry</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">ads_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">][</span><span class="n">clean_entry</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">ads_entry</span><span class="o">.</span><span class="n">get_monolayer</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ml_be_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">ml_be_dict</span><span class="p">[</span><span class="n">ads_entry</span><span class="o">.</span><span class="n">get_monolayer</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
                        <span class="n">be</span> <span class="o">=</span> <span class="n">ads_entry</span><span class="o">.</span><span class="n">gibbs_binding_energy</span><span class="p">(</span><span class="n">eads</span><span class="o">=</span><span class="n">plot_eads</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">be</span> <span class="o">&lt;</span> <span class="n">ml_be_dict</span><span class="p">[</span><span class="n">ads_entry</span><span class="o">.</span><span class="n">get_monolayer</span><span class="p">]:</span>
                            <span class="n">ml_be_dict</span><span class="p">[</span><span class="n">ads_entry</span><span class="o">.</span><span class="n">get_monolayer</span><span class="p">]</span> <span class="o">=</span> <span class="n">be</span>
            <span class="c1"># sort the binding energies and monolayers</span>
            <span class="c1"># in order to properly draw a line plot</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ml_be_dict</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="n">monolayers</span><span class="p">,</span> <span class="n">BEs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">monolayers</span><span class="p">,</span> <span class="n">BEs</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">,</span>
                     <span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">color_dict</span><span class="p">[</span><span class="n">clean_entry</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">hkl</span><span class="p">)</span>

        <span class="n">adsorbates</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ads_entry</span><span class="o">.</span><span class="n">ads_entries_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">adsorbates</span><span class="p">)</span> <span class="o">%</span> <span class="n">adsorbates</span> <span class="o">+</span> <span class="s2">&quot; Coverage (ML)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Adsorption Energy (eV)&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">plot_eads</span> \
            <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Binding Energy (eV)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">plt</span></div>

<div class="viewcode-block" id="SurfaceEnergyPlotter.chempot_plot_addons"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.chempot_plot_addons">[docs]</a>    <span class="k">def</span> <span class="nf">chempot_plot_addons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plt</span><span class="p">,</span> <span class="n">xrange</span><span class="p">,</span> <span class="n">ref_el</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">2.4</span><span class="p">,</span>
                            <span class="n">rect</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">0.047</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.84</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ylim</span><span class="o">=</span><span class="p">[]):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to a chempot plot look nicer.</span>

<span class="sd">        Args:</span>
<span class="sd">            plt (Plot) Plot to add things to.</span>
<span class="sd">            xrange (list): xlim parameter</span>
<span class="sd">            ref_el (str): Element of the referenced chempot.</span>
<span class="sd">            axes(axes) Axes object from matplotlib</span>
<span class="sd">            pad (float) For tight layout</span>
<span class="sd">            rect (list): For tight layout</span>
<span class="sd">            ylim (ylim parameter):</span>

<span class="sd">        return (Plot): Modified plot with addons.</span>
<span class="sd">        return (Plot): Modified plot with addons.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Make the figure look nice</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.01</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">borderaxespad</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Chemical potential $\Delta\mu_{</span><span class="si">%s</span><span class="s2">}$ (eV)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ref_el</span><span class="p">))</span>

        <span class="n">ylim</span> <span class="o">=</span> <span class="n">ylim</span> <span class="k">if</span> <span class="n">ylim</span> <span class="k">else</span> <span class="n">axes</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
        <span class="n">xlim</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">(</span><span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span> <span class="n">rect</span><span class="o">=</span><span class="n">rect</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xrange</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">ylim</span><span class="p">,</span> <span class="s1">&#39;--k&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">ylim</span><span class="p">,</span> <span class="s1">&#39;--k&#39;</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">xrange</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ylim</span><span class="p">)]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-rich&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ref_el</span><span class="p">),</span> <span class="n">xy</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span>
                     <span class="n">xytext</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ylim</span><span class="p">)]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-poor&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ref_el</span><span class="p">),</span> <span class="n">xy</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span>
                     <span class="n">xytext</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">17</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">plt</span></div>

<div class="viewcode-block" id="SurfaceEnergyPlotter.BE_vs_clean_SE"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.BE_vs_clean_SE">[docs]</a>    <span class="k">def</span> <span class="nf">BE_vs_clean_SE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delu_dict</span><span class="p">,</span> <span class="n">delu_default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">plot_eads</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">annotate_monolayer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">JPERM2</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each facet, plot the clean surface energy against the most</span>
<span class="sd">            stable binding energy.</span>
<span class="sd">        Args:</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            delu_default (float): Default value for all unset chemical potentials</span>
<span class="sd">            plot_eads (bool): Option to plot the adsorption energy (binding</span>
<span class="sd">                energy multiplied by number of adsorbates) instead.</span>
<span class="sd">            annotate_monolayer (bool): Whether or not to label each data point</span>
<span class="sd">                with its monolayer (adsorbate density per unit primiitve area)</span>
<span class="sd">            JPERM2 (bool): Whether to plot surface energy in /m^2 (True) or</span>
<span class="sd">                eV/A^2 (False)</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Plot): Plot of clean surface energy vs binding energy for</span>
<span class="sd">                all facets.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">plt</span> <span class="o">=</span> <span class="n">pretty_plot</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">clean_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">all_delu_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_all_variables</span><span class="p">(</span><span class="n">delu_dict</span><span class="p">,</span> <span class="n">delu_default</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">][</span><span class="n">clean_entry</span><span class="p">]:</span>
                    <span class="n">clean_se</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeffs_dict</span><span class="p">[</span><span class="n">clean_entry</span><span class="p">]</span>
                    <span class="n">se</span> <span class="o">=</span> <span class="n">sub_chempots</span><span class="p">(</span><span class="n">clean_se</span><span class="p">,</span> <span class="n">all_delu_dict</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">ads_entry</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_slab_entries</span><span class="p">[</span><span class="n">hkl</span><span class="p">][</span><span class="n">clean_entry</span><span class="p">]:</span>
                        <span class="n">ml</span> <span class="o">=</span> <span class="n">ads_entry</span><span class="o">.</span><span class="n">get_monolayer</span>
                        <span class="n">be</span> <span class="o">=</span> <span class="n">ads_entry</span><span class="o">.</span><span class="n">gibbs_binding_energy</span><span class="p">(</span><span class="n">eads</span><span class="o">=</span><span class="n">plot_eads</span><span class="p">)</span>

                        <span class="c1"># Now plot the surface energy vs binding energy</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">se</span><span class="p">,</span> <span class="n">be</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">annotate_monolayer</span><span class="p">:</span>
                            <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ml</span><span class="p">),</span> <span class="n">xy</span><span class="o">=</span><span class="p">[</span><span class="n">se</span><span class="p">,</span> <span class="n">be</span><span class="p">],</span>
                                         <span class="n">xytext</span><span class="o">=</span><span class="p">[</span><span class="n">se</span><span class="p">,</span> <span class="n">be</span><span class="p">])</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Surface energy ($J/m^2$)&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">JPERM2</span> \
            <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Surface energy ($eV/\AA^2$)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Adsorption Energy (eV)&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">plot_eads</span> \
            <span class="k">else</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Binding Energy (eV)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">plt</span></div>

<div class="viewcode-block" id="SurfaceEnergyPlotter.surface_chempot_range_map"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.surface_chempot_range_map">[docs]</a>    <span class="k">def</span> <span class="nf">surface_chempot_range_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">ranges</span><span class="p">,</span>
                                  <span class="n">incr</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">no_doped</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">no_clean</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">delu_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                  <span class="n">show_unphyiscal_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adapted from the get_chempot_range_map() method in the PhaseDiagram</span>
<span class="sd">            class. Plot the chemical potential range map based on surface</span>
<span class="sd">            energy stability. Currently works only for 2-component PDs. At</span>
<span class="sd">            the moment uses a brute force method by enumerating through the</span>
<span class="sd">            range of the first element chempot with a specified increment</span>
<span class="sd">            and determines the chempot rangeo fht e second element for each</span>
<span class="sd">            SlabEntry. Future implementation will determine the chempot range</span>
<span class="sd">            map first by solving systems of equations up to 3 instead of 2.</span>
<span class="sd">        Args:</span>
<span class="sd">            elements (list): Sequence of elements to be considered as independent</span>
<span class="sd">                variables. E.g., if you want to show the stability ranges of</span>
<span class="sd">                all Li-Co-O phases wrt to duLi and duO, you will supply</span>
<span class="sd">                [Element(&quot;Li&quot;), Element(&quot;O&quot;)]</span>
<span class="sd">            miller_index ([h, k, l]): Miller index of the surface we are interested in</span>
<span class="sd">            ranges ([[range1], [range2]]): List of chempot ranges (max and min values)</span>
<span class="sd">                for the first and second element.</span>
<span class="sd">            incr (int): Number of points to sample along the range of the first chempot</span>
<span class="sd">            no_doped (bool): Whether or not to include doped systems.</span>
<span class="sd">            no_clean (bool): Whether or not to include clean systems.</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            annotate (bool): Whether to annotate each &quot;phase&quot; with the label of</span>
<span class="sd">                the entry. If no label, uses the reduced formula</span>
<span class="sd">            show_unphyiscal_only (bool): Whether to only show the shaded region where</span>
<span class="sd">                surface energy is negative. Useful for drawing other chempot range maps.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set up</span>
        <span class="n">delu_dict</span> <span class="o">=</span> <span class="n">delu_dict</span> <span class="k">if</span> <span class="n">delu_dict</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="n">plt</span> <span class="o">=</span> <span class="n">pretty_plot</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">plt</span> <span class="k">else</span> <span class="n">plt</span>
        <span class="n">el1</span><span class="p">,</span> <span class="n">el2</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">str</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">delu1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;delu_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
        <span class="n">delu2</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;delu_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
        <span class="n">range1</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">range2</span> <span class="o">=</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Find a range map for each entry (surface). This part is very slow, will</span>
        <span class="c1"># need to implement a more sophisticated method of getting the range map</span>
        <span class="n">vertices_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dmu1</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">range1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">incr</span><span class="p">):</span>
            <span class="c1"># Get chemical potential range of dmu2 for each increment of dmu1</span>
            <span class="n">new_delu_dict</span> <span class="o">=</span> <span class="n">delu_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_delu_dict</span><span class="p">[</span><span class="n">delu1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmu1</span>
            <span class="n">range_dict</span><span class="p">,</span> <span class="n">se_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stable_u_range_dict</span><span class="p">(</span><span class="n">range2</span><span class="p">,</span> <span class="n">delu2</span><span class="p">,</span> <span class="n">dmu_at_0</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                           <span class="n">miller_index</span><span class="o">=</span><span class="n">miller_index</span><span class="p">,</span>
                                                           <span class="n">no_doped</span><span class="o">=</span><span class="n">no_doped</span><span class="p">,</span>
                                                           <span class="n">no_clean</span><span class="o">=</span><span class="n">no_clean</span><span class="p">,</span>
                                                           <span class="n">delu_dict</span><span class="o">=</span><span class="n">new_delu_dict</span><span class="p">,</span>
                                                           <span class="n">return_se_dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Save the chempot range for dmu1 and dmu2</span>
            <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">range_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">range_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">entry</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vertices_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">vertices_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">selist</span> <span class="o">=</span> <span class="n">se_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span>
                <span class="n">vertices_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">delu1</span><span class="p">:</span> <span class="n">dmu1</span><span class="p">,</span> <span class="n">delu2</span><span class="p">:</span> <span class="p">[</span><span class="n">range_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span> <span class="n">selist</span><span class="p">]})</span>

        <span class="c1"># Plot the edges of the phases</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">vertices_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

            <span class="c1"># Plot each edge of a phase within the borders</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">pt1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertices_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">]):</span>

                <span class="c1"># Determine if the surface energy at this lower range</span>
                <span class="c1"># of dmu2 is negative. If so, shade this region.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pt1</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">neg_dmu_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt1</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt1</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">neg_dmu_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt1</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">pt1</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>
                    <span class="c1"># Shade the threshold and region at which se&lt;=0</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">pt1</span><span class="p">[</span><span class="n">delu1</span><span class="p">],</span> <span class="n">pt1</span><span class="p">[</span><span class="n">delu1</span><span class="p">]],</span> <span class="n">neg_dmu_range</span><span class="p">,</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">pt1</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pt1</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Any chempot at at this point will result</span>
                    <span class="c1"># in se&lt;0, shade the entire y range</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">show_unphyiscal_only</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">pt1</span><span class="p">[</span><span class="n">delu1</span><span class="p">],</span> <span class="n">pt1</span><span class="p">[</span><span class="n">delu1</span><span class="p">]],</span> <span class="n">range2</span><span class="p">,</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">ii</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">pt2</span> <span class="o">=</span> <span class="n">vertices_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">][</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">show_unphyiscal_only</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">pt1</span><span class="p">[</span><span class="n">delu1</span><span class="p">],</span> <span class="n">pt2</span><span class="p">[</span><span class="n">delu1</span><span class="p">]],</span> <span class="p">[</span><span class="n">pt1</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt2</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

                <span class="c1"># Need these values to get a good position for labelling phases</span>
                <span class="n">xvals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pt1</span><span class="p">[</span><span class="n">delu1</span><span class="p">],</span> <span class="n">pt2</span><span class="p">[</span><span class="n">delu1</span><span class="p">]])</span>
                <span class="n">yvals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pt1</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt2</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

            <span class="c1"># Plot the edge along the max x value</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">vertices_dict</span><span class="p">[</span><span class="n">entry</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">delu1</span><span class="p">,</span> <span class="n">delu2</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">xvals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pt</span><span class="p">[</span><span class="n">delu1</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="n">delu1</span><span class="p">]])</span>
            <span class="n">yvals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">show_unphyiscal_only</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">pt</span><span class="p">[</span><span class="n">delu1</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="n">delu1</span><span class="p">]],</span> <span class="p">[</span><span class="n">pt</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="n">delu2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
                <span class="c1"># Label the phases</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">xvals</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">xvals</span><span class="p">)])</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">yvals</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">yvals</span><span class="p">)])</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">label</span> <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">label</span> <span class="k">else</span> <span class="n">entry</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">reduced_formula</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">xytext</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>

        <span class="c1"># Label plot</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">range1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">range2</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\Delta\mu_{</span><span class="si">%s</span><span class="s2">} (eV)$&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">el1</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\Delta\mu_{</span><span class="si">%s</span><span class="s2">} (eV)$&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">el2</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">plt</span></div>

<div class="viewcode-block" id="SurfaceEnergyPlotter.set_all_variables"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.SurfaceEnergyPlotter.set_all_variables">[docs]</a>    <span class="k">def</span> <span class="nf">set_all_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delu_dict</span><span class="p">,</span> <span class="n">delu_default</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets all chemical potential values and returns a dictionary where</span>
<span class="sd">            the key is a sympy Symbol and the value is a float (chempot).</span>

<span class="sd">        Args:</span>
<span class="sd">            entry (SlabEntry): Computed structure entry of the slab</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            delu_default (float): Default value for all unset chemical potentials</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary of set chemical potential values</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set up the variables</span>
        <span class="n">all_delu_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">du</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_of_chempots</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">delu_dict</span> <span class="ow">and</span> <span class="n">du</span> <span class="ow">in</span> <span class="n">delu_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">all_delu_dict</span><span class="p">[</span><span class="n">du</span><span class="p">]</span> <span class="o">=</span> <span class="n">delu_dict</span><span class="p">[</span><span class="n">du</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">du</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">all_delu_dict</span><span class="p">[</span><span class="n">du</span><span class="p">]</span> <span class="o">=</span> <span class="n">du</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_delu_dict</span><span class="p">[</span><span class="n">du</span><span class="p">]</span> <span class="o">=</span> <span class="n">delu_default</span>

        <span class="k">return</span> <span class="n">all_delu_dict</span></div></div>


        <span class="c1"># def surface_phase_diagram(self, y_param, x_param, miller_index):</span>
        <span class="c1">#     return</span>
        <span class="c1">#</span>
        <span class="c1"># def wulff_shape_extrapolated_model(self):</span>
        <span class="c1">#     return</span>
        <span class="c1">#</span>
        <span class="c1"># def surface_pourbaix_diagram(self):</span>
        <span class="c1">#</span>
        <span class="c1">#     return</span>
        <span class="c1">#</span>
        <span class="c1"># def surface_p_vs_t_phase_diagram(self):</span>
        <span class="c1">#</span>
        <span class="c1">#     return</span>
        <span class="c1">#</span>
        <span class="c1"># def broken_bond_vs_gamma(self):</span>
        <span class="c1">#</span>
        <span class="c1">#     return</span>

<div class="viewcode-block" id="entry_dict_from_list"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.entry_dict_from_list">[docs]</a><span class="k">def</span> <span class="nf">entry_dict_from_list</span><span class="p">(</span><span class="n">all_slab_entries</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a list of SlabEntry to an appropriate dictionary. It is</span>
<span class="sd">    assumed that if there is no adsorbate, then it is a clean SlabEntry</span>
<span class="sd">    and that adsorbed SlabEntry has the clean_entry parameter set.</span>

<span class="sd">    Args:</span>
<span class="sd">        all_slab_entries (list): List of SlabEntry objects</span>

<span class="sd">    Returns:</span>
<span class="sd">        (dict): Dictionary of SlabEntry with the Miller index as the main</span>
<span class="sd">            key to a dictionary with a clean SlabEntry as the key to a</span>
<span class="sd">            list of adsorbed SlabEntry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">entry_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">all_slab_entries</span><span class="p">:</span>
        <span class="n">hkl</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">miller_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hkl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entry_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">entry_dict</span><span class="p">[</span><span class="n">hkl</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">clean_entry</span><span class="p">:</span>
            <span class="n">clean</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">clean_entry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clean</span> <span class="o">=</span> <span class="n">entry</span>
        <span class="k">if</span> <span class="n">clean</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entry_dict</span><span class="p">[</span><span class="n">hkl</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">entry_dict</span><span class="p">[</span><span class="n">hkl</span><span class="p">][</span><span class="n">clean</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">adsorbates</span><span class="p">:</span>
            <span class="n">entry_dict</span><span class="p">[</span><span class="n">hkl</span><span class="p">][</span><span class="n">clean</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">entry_dict</span></div>


<div class="viewcode-block" id="WorkFunctionAnalyzer"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.WorkFunctionAnalyzer">[docs]</a><span class="k">class</span> <span class="nc">WorkFunctionAnalyzer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that post processes a task document of a vasp calculation (from</span>
<span class="sd">        using drone.assimilate). Can calculate work function from the vasp</span>
<span class="sd">        calculations and plot the potential along the c axis. This class</span>
<span class="sd">        assumes that LVTOT=True (i.e. the LOCPOT file was generated) for a</span>
<span class="sd">        slab calculation and it was insert into the task document along with</span>
<span class="sd">        the other outputs.</span>

<span class="sd">    .. attribute:: efermi</span>

<span class="sd">        The Fermi energy</span>

<span class="sd">    .. attribute:: locpot_along_c</span>

<span class="sd">        Local potential in eV along points along the  axis</span>

<span class="sd">    .. attribute:: vacuum_locpot</span>

<span class="sd">        The maximum local potential along the c direction for</span>
<span class="sd">            the slab model, ie the potential at the vacuum</span>

<span class="sd">    .. attribute:: work_function</span>

<span class="sd">        The minimum energy needed to move an electron from the</span>
<span class="sd">            surface to infinity. Defined as the difference between</span>
<span class="sd">            the potential at the vacuum and the Fermi energy.</span>

<span class="sd">    .. attribute:: slab</span>

<span class="sd">        The slab structure model</span>

<span class="sd">    .. attribute:: along_c</span>

<span class="sd">        Points along the c direction with same</span>
<span class="sd">            increments as the locpot in the c axis</span>

<span class="sd">    .. attribute:: ave_locpot</span>

<span class="sd">        Mean of the minimum and maximmum (vacuum) locpot along c</span>

<span class="sd">    .. attribute:: sorted_sites</span>

<span class="sd">        List of sites from the slab sorted along the c direction</span>

<span class="sd">    .. attribute:: ave_bulk_p</span>

<span class="sd">        The average locpot of the slab region along the c direction</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">locpot_along_c</span><span class="p">,</span> <span class="n">efermi</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the WorkFunctionAnalyzer class.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure (Structure): Structure object modelling the surface</span>
<span class="sd">            locpot_along_c (list): Local potential along the c direction</span>
<span class="sd">            outcar (MSONable): Outcar vasp output object</span>
<span class="sd">            shift (float): Parameter to translate the slab (and</span>
<span class="sd">                therefore the vacuum) of the slab structure, thereby</span>
<span class="sd">                translating the plot along the x axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># properties that can be shifted</span>
        <span class="n">slab</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">slab</span><span class="o">.</span><span class="n">translate_sites</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slab</span><span class="p">)],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">shift</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slab</span> <span class="o">=</span> <span class="n">slab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sorted_sites</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slab</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">site</span><span class="p">:</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Get the plot points between 0 and c</span>
        <span class="c1"># increments of the number of locpot points</span>
        <span class="n">locpot_along_c</span> <span class="o">=</span> <span class="n">locpot_along_c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">along_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">locpot_along_c</span><span class="p">))</span>
        <span class="n">locpot_along_c_mid</span><span class="p">,</span> <span class="n">locpot_end</span><span class="p">,</span> <span class="n">locpot_start</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">along_c</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">shift</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">locpot_start</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locpot_along_c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">locpot_end</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locpot_along_c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">locpot_along_c_mid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locpot_along_c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locpot_along_c</span> <span class="o">=</span> <span class="n">locpot_start</span> <span class="o">+</span> <span class="n">locpot_along_c_mid</span> <span class="o">+</span> <span class="n">locpot_end</span>

        <span class="c1"># get the average of the signal in the bulk-like region of the</span>
        <span class="c1"># slab, i.e. the average of the oscillating region. This gives</span>
        <span class="c1"># a rough appr. of the potential in the interior of the slab</span>
        <span class="n">bulk_p</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_along_c</span><span class="p">)</span> <span class="k">if</span> \
                  <span class="bp">self</span><span class="o">.</span><span class="n">sorted_sites</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">along_c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> \
                  <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ave_bulk_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bulk_p</span><span class="p">)</span>

        <span class="c1"># shift independent quantities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span> <span class="o">=</span> <span class="n">efermi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vacuum_locpot</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_along_c</span><span class="p">)</span>
        <span class="c1"># get the work function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">work_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacuum_locpot</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span>
        <span class="c1"># for setting ylim and annotating</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ave_locpot</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vacuum_locpot</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_along_c</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>

<div class="viewcode-block" id="WorkFunctionAnalyzer.get_locpot_along_slab_plot"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.WorkFunctionAnalyzer.get_locpot_along_slab_plot">[docs]</a>    <span class="k">def</span> <span class="nf">get_locpot_along_slab_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_energies</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">plt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label_fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a plot of the local potential (eV) vs the</span>
<span class="sd">            position along the c axis of the slab model (Ang)</span>

<span class="sd">        Args:</span>
<span class="sd">            label_energies (bool): Whether to label relevant energy</span>
<span class="sd">                quantities such as the work function, Fermi energy,</span>
<span class="sd">                vacuum locpot, bulk-like locpot</span>
<span class="sd">            plt (plt): Matplotlib pylab object</span>
<span class="sd">            label_fontsize (float): Fontsize of labels</span>

<span class="sd">        Returns plt of the locpot vs c axis</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">plt</span> <span class="o">=</span> <span class="n">pretty_plot</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">plt</span> <span class="k">else</span> <span class="n">plt</span>

        <span class="c1"># plot the raw locpot signal along c</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">along_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_along_c</span><span class="p">,</span> <span class="s1">&#39;b--&#39;</span><span class="p">)</span>

        <span class="c1"># Get the local averaged signal of the locpot along c</span>
        <span class="n">xg</span><span class="p">,</span> <span class="n">yg</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_along_c</span><span class="p">):</span>
            <span class="c1"># average signal is just the bulk-like potential when in the slab region</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ave_bulk_p</span> \
                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_sites</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">along_c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> \
                            <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">yg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ave_bulk_p</span><span class="p">)</span>
                <span class="n">xg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">along_c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">yg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">xg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">along_c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">xg</span><span class="p">,</span> <span class="n">yg</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xg</span><span class="p">,</span> <span class="n">yg</span><span class="p">)))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xg</span><span class="p">,</span> <span class="n">yg</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># make it look nice</span>
        <span class="k">if</span> <span class="n">label_energies</span><span class="p">:</span>
            <span class="n">plt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_labels</span><span class="p">(</span><span class="n">plt</span><span class="p">,</span> <span class="n">label_fontsize</span><span class="o">=</span><span class="n">label_fontsize</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_along_c</span><span class="p">),</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">vacuum_locpot</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ave_locpot</span><span class="o">*</span><span class="mf">0.2</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Fractional coordinates ($\hat</span><span class="si">{c}</span><span class="s2">$)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Potential (eV)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">plt</span></div>

<div class="viewcode-block" id="WorkFunctionAnalyzer.get_labels"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.WorkFunctionAnalyzer.get_labels">[docs]</a>    <span class="k">def</span> <span class="nf">get_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plt</span><span class="p">,</span> <span class="n">label_fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles the optional labelling of the plot with relevant quantities</span>
<span class="sd">        Args:</span>
<span class="sd">            plt (plt): Plot of the locpot vs c axis</span>
<span class="sd">            label_fontsize (float): Fontsize of labels</span>
<span class="sd">        Returns Labelled plt</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">maxc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_sites</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">minc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># determine whether most of the vacuum is to</span>
        <span class="c1"># the left or right for labelling purposes</span>
        <span class="n">vleft</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">along_c</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">minc</span><span class="p">]</span>
        <span class="n">vright</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">along_c</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">maxc</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">vleft</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">vleft</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">vright</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">vright</span><span class="p">):</span>
            <span class="n">label_in_vac</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">vleft</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">vleft</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label_in_vac</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">vright</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">vright</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">maxc</span>

        <span class="c1"># label the vacuum locpot</span>
        <span class="n">label_in_bulk</span> <span class="o">=</span> <span class="n">maxc</span> <span class="o">-</span> <span class="p">(</span><span class="n">maxc</span> <span class="o">-</span> <span class="n">minc</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vacuum_locpot</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b--&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">5</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="p">[</span><span class="n">label_in_bulk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacuum_locpot</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ave_locpot</span><span class="o">*</span><span class="mf">0.05</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$V_</span><span class="si">{vac}</span><span class="s2">=</span><span class="si">%.2f</span><span class="s2">$&quot;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vacuum_locpot</span><span class="p">),</span> <span class="n">xy</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span>
                     <span class="n">xytext</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">label_fontsize</span><span class="p">)</span>

        <span class="c1"># label the fermi energy</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">efermi</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;g--&#39;</span><span class="p">,</span>
                 <span class="n">zorder</span><span class="o">=-</span><span class="mi">5</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="p">[</span><span class="n">label_in_bulk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ave_locpot</span><span class="o">*</span><span class="mf">0.05</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$E_F=</span><span class="si">%.2f</span><span class="s2">$&quot;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">efermi</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span>
                     <span class="n">xy</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">label_fontsize</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span>

        <span class="c1"># label the bulk-like locpot</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ave_bulk_p</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="p">[</span><span class="n">label_in_vac</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ave_bulk_p</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ave_locpot</span> <span class="o">*</span> <span class="mf">0.05</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$V^</span><span class="si">{interior}</span><span class="s2">_</span><span class="si">{slab}</span><span class="s2">=</span><span class="si">%.2f</span><span class="s2">$&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ave_bulk_p</span><span class="p">),</span>
                     <span class="n">xy</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">label_fontsize</span><span class="p">)</span>

        <span class="c1"># label the work function as a barrier</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">label_in_vac</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">efermi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vacuum_locpot</span><span class="p">],</span>
                 <span class="s1">&#39;k--&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=-</span><span class="mi">5</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="p">[</span><span class="n">label_in_vac</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ave_locpot</span> <span class="o">*</span> <span class="mf">0.05</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\Phi=</span><span class="si">%.2f</span><span class="s2">$&quot;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work_function</span><span class="p">),</span>
                     <span class="n">xy</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">label_fontsize</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">plt</span></div>

<div class="viewcode-block" id="WorkFunctionAnalyzer.is_converged"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.WorkFunctionAnalyzer.is_converged">[docs]</a>    <span class="k">def</span> <span class="nf">is_converged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_points_frac</span><span class="o">=</span><span class="mf">0.015</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.0025</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A well converged work function should have a flat electrostatic</span>
<span class="sd">            potential within some distance (min_point) about where the peak</span>
<span class="sd">            electrostatic potential is found along the c direction of the</span>
<span class="sd">            slab. This is dependent on the size of the slab.</span>
<span class="sd">        Args:</span>
<span class="sd">            min_point (fractional coordinates): The number of data points</span>
<span class="sd">                +/- the point of where the electrostatic potential is at</span>
<span class="sd">                its peak along the c direction.</span>
<span class="sd">            tol (float): If the electrostatic potential stays the same</span>
<span class="sd">                within this tolerance, within the min_points, it is converged.</span>

<span class="sd">        Returns a bool (whether or not the work function is converged)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">conv_within</span> <span class="o">=</span> <span class="n">tol</span><span class="o">*</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_along_c</span><span class="p">)</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_along_c</span><span class="p">))</span>
        <span class="n">min_points</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_points_frac</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locpot_along_c</span><span class="p">))</span>
        <span class="n">peak_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_along_c</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vacuum_locpot</span><span class="p">)</span>
        <span class="n">all_flat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">along_c</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">peak_i</span> <span class="o">-</span> <span class="n">min_points</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span>  <span class="n">peak_i</span> <span class="o">+</span> <span class="n">min_points</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vacuum_locpot</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">locpot_along_c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">conv_within</span><span class="p">:</span>
                    <span class="n">all_flat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">all_flat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">all_flat</span><span class="p">)</span></div>

<div class="viewcode-block" id="WorkFunctionAnalyzer.from_files"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.WorkFunctionAnalyzer.from_files">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_files</span><span class="p">(</span><span class="n">poscar_filename</span><span class="p">,</span> <span class="n">locpot_filename</span><span class="p">,</span> <span class="n">outcar_filename</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Poscar</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">poscar_filename</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">Locpot</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">locpot_filename</span><span class="p">)</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">Outcar</span><span class="p">(</span><span class="n">outcar_filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">WorkFunctionAnalyzer</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">get_average_along_axis</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
                                    <span class="n">o</span><span class="o">.</span><span class="n">efermi</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="NanoscaleStability"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.NanoscaleStability">[docs]</a><span class="k">class</span> <span class="nc">NanoscaleStability</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for analyzing the stability of nanoparticles of different</span>
<span class="sd">        polymorphs with respect to size. The Wulff shape will be the</span>
<span class="sd">        model for the nanoparticle. Stability will be determined by</span>
<span class="sd">        an energetic competition between the weighted surface energy</span>
<span class="sd">        (surface energy of the Wulff shape) and the bulk energy. A</span>
<span class="sd">        future release will include a 2D phase diagram (e.g. wrt size</span>
<span class="sd">        vs chempot for adsorbed or nonstoichiometric surfaces). Based</span>
<span class="sd">        on the following work:</span>

<span class="sd">        Kang, S., Mo, Y., Ong, S. P., &amp; Ceder, G. (2014). Nanoscale</span>
<span class="sd">            stabilization of sodium oxides: Implications for Na-O2</span>
<span class="sd">            batteries. Nano Letters, 14(2), 1016â€“1020.</span>
<span class="sd">            https://doi.org/10.1021/nl404557w</span>

<span class="sd">    .. attribute:: se_analyzers</span>

<span class="sd">        List of SurfaceEnergyPlotter objects. Each item corresponds to a</span>
<span class="sd">            different polymorph.</span>

<span class="sd">    .. attribute:: symprec</span>

<span class="sd">        See WulffShape.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">se_analyzers</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyzes the nanoscale stability of different polymorphs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">se_analyzers</span> <span class="o">=</span> <span class="n">se_analyzers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symprec</span> <span class="o">=</span> <span class="n">symprec</span>

<div class="viewcode-block" id="NanoscaleStability.solve_equilibrium_point"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.NanoscaleStability.solve_equilibrium_point">[docs]</a>    <span class="k">def</span> <span class="nf">solve_equilibrium_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analyzer1</span><span class="p">,</span> <span class="n">analyzer2</span><span class="p">,</span>
                                <span class="n">delu_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">delu_default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;nanometers&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the radial size of two particles where equilibrium is reached</span>
<span class="sd">            between both particles. NOTE: the solution here is not the same</span>
<span class="sd">            as the solution visualized in the plot because solving for r</span>
<span class="sd">            requires that both the total surface area and volume of the</span>
<span class="sd">            particles are functions of r.</span>

<span class="sd">        Args:</span>
<span class="sd">            analyzer1 (SurfaceEnergyPlotter): Analyzer associated with the</span>
<span class="sd">                first polymorph</span>
<span class="sd">            analyzer2 (SurfaceEnergyPlotter): Analyzer associated with the</span>
<span class="sd">                second polymorph</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            delu_default (float): Default value for all unset chemical potentials</span>
<span class="sd">            units (str): Can be nanometers or Angstrom</span>

<span class="sd">        Returns:</span>
<span class="sd">            Particle radius in nm</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set up</span>
        <span class="n">wulff1</span> <span class="o">=</span> <span class="n">analyzer1</span><span class="o">.</span><span class="n">wulff_from_chempot</span><span class="p">(</span><span class="n">delu_dict</span><span class="o">=</span><span class="n">delu_dict</span><span class="p">,</span>
                                              <span class="n">delu_default</span><span class="o">=</span><span class="n">delu_default</span><span class="p">,</span>
                                              <span class="n">symprec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symprec</span><span class="p">)</span>
        <span class="n">wulff2</span> <span class="o">=</span> <span class="n">analyzer2</span><span class="o">.</span><span class="n">wulff_from_chempot</span><span class="p">(</span><span class="n">delu_dict</span><span class="o">=</span><span class="n">delu_dict</span><span class="p">,</span>
                                              <span class="n">delu_default</span><span class="o">=</span><span class="n">delu_default</span><span class="p">,</span>
                                              <span class="n">symprec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symprec</span><span class="p">)</span>

        <span class="c1"># Now calculate r</span>
        <span class="n">delta_gamma</span> <span class="o">=</span> <span class="n">wulff1</span><span class="o">.</span><span class="n">weighted_surface_energy</span> <span class="o">-</span> <span class="n">wulff2</span><span class="o">.</span><span class="n">weighted_surface_energy</span>
        <span class="n">delta_E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulk_gform</span><span class="p">(</span><span class="n">analyzer1</span><span class="o">.</span><span class="n">ucell_entry</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulk_gform</span><span class="p">(</span><span class="n">analyzer2</span><span class="o">.</span><span class="n">ucell_entry</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">3</span> <span class="o">*</span> <span class="n">delta_gamma</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">delta_E</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">r</span> <span class="o">/</span> <span class="mi">10</span> <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s2">&quot;nanometers&quot;</span> <span class="k">else</span> <span class="n">r</span></div>

<div class="viewcode-block" id="NanoscaleStability.wulff_gform_and_r"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.NanoscaleStability.wulff_gform_and_r">[docs]</a>    <span class="k">def</span> <span class="nf">wulff_gform_and_r</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wulffshape</span><span class="p">,</span> <span class="n">bulk_entry</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">from_sphere_area</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">r_units</span><span class="o">=</span><span class="s2">&quot;nanometers&quot;</span><span class="p">,</span> <span class="n">e_units</span><span class="o">=</span><span class="s2">&quot;keV&quot;</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">scale_per_atom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the formation energy of the particle with arbitrary radius r.</span>

<span class="sd">        Args:</span>
<span class="sd">            wulffshape (WulffShape): Initial, unscaled WulffShape</span>
<span class="sd">            bulk_entry (ComputedStructureEntry): Entry of the corresponding bulk.</span>
<span class="sd">            r (float (Ang)): Arbitrary effective radius of the WulffShape</span>
<span class="sd">            from_sphere_area (bool): There are two ways to calculate the bulk</span>
<span class="sd">                formation energy. Either by treating the volume and thus surface</span>
<span class="sd">                area of the particle as a perfect sphere, or as a Wulff shape.</span>
<span class="sd">            r_units (str): Can be nanometers or Angstrom</span>
<span class="sd">            e_units (str): Can be keV or eV</span>
<span class="sd">            normalize (bool): Whether or not to normalize energy by volume</span>
<span class="sd">            scale_per_atom (True): Whether or not to normalize by number of</span>
<span class="sd">                atoms in the particle</span>

<span class="sd">        Returns:</span>
<span class="sd">            particle formation energy (float in keV), effective radius</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set up</span>
        <span class="n">miller_se_dict</span> <span class="o">=</span> <span class="n">wulffshape</span><span class="o">.</span><span class="n">miller_energy_dict</span>
        <span class="n">new_wulff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaled_wulff</span><span class="p">(</span><span class="n">wulffshape</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="n">new_wulff_area</span> <span class="o">=</span> <span class="n">new_wulff</span><span class="o">.</span><span class="n">miller_area_dict</span>

        <span class="c1"># calculate surface energy of the particle</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">from_sphere_area</span><span class="p">:</span>
            <span class="c1"># By approximating the particle as a Wulff shape</span>
            <span class="n">w_vol</span> <span class="o">=</span> <span class="n">new_wulff</span><span class="o">.</span><span class="n">volume</span>
            <span class="n">tot_wulff_se</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="n">new_wulff_area</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">tot_wulff_se</span> <span class="o">+=</span> <span class="n">miller_se_dict</span><span class="p">[</span><span class="n">hkl</span><span class="p">]</span> <span class="o">*</span> <span class="n">new_wulff_area</span><span class="p">[</span><span class="n">hkl</span><span class="p">]</span>
            <span class="n">Ebulk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulk_gform</span><span class="p">(</span><span class="n">bulk_entry</span><span class="p">)</span> <span class="o">*</span> <span class="n">w_vol</span>
            <span class="n">new_r</span> <span class="o">=</span> <span class="n">new_wulff</span><span class="o">.</span><span class="n">effective_radius</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># By approximating the particle as a perfect sphere</span>
            <span class="n">w_vol</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">3</span>
            <span class="n">sphere_sa</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">tot_wulff_se</span> <span class="o">=</span> <span class="n">wulffshape</span><span class="o">.</span><span class="n">weighted_surface_energy</span> <span class="o">*</span> <span class="n">sphere_sa</span>
            <span class="n">Ebulk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulk_gform</span><span class="p">(</span><span class="n">bulk_entry</span><span class="p">)</span> <span class="o">*</span> <span class="n">w_vol</span>
            <span class="n">new_r</span> <span class="o">=</span> <span class="n">r</span>

        <span class="n">new_r</span> <span class="o">=</span> <span class="n">new_r</span> <span class="o">/</span> <span class="mi">10</span> <span class="k">if</span> <span class="n">r_units</span> <span class="o">==</span> <span class="s2">&quot;nanometers&quot;</span> <span class="k">else</span> <span class="n">new_r</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ebulk</span> <span class="o">+</span> <span class="n">tot_wulff_se</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">e</span> <span class="o">/</span> <span class="mi">1000</span> <span class="k">if</span> <span class="n">e_units</span> <span class="o">==</span> <span class="s2">&quot;keV&quot;</span> <span class="k">else</span> <span class="n">e</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">e</span> <span class="o">/</span> <span class="p">((</span><span class="mi">4</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">new_r</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="n">normalize</span> <span class="k">else</span> <span class="n">e</span>
        <span class="n">bulk_struct</span> <span class="o">=</span> <span class="n">bulk_entry</span><span class="o">.</span><span class="n">structure</span>
        <span class="n">density</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bulk_struct</span><span class="p">)</span><span class="o">/</span><span class="n">bulk_struct</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">volume</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">/</span><span class="p">(</span><span class="n">density</span><span class="o">*</span><span class="n">w_vol</span><span class="p">)</span> <span class="k">if</span> <span class="n">scale_per_atom</span> <span class="k">else</span> <span class="n">e</span>

        <span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="n">new_r</span></div>

<div class="viewcode-block" id="NanoscaleStability.bulk_gform"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.NanoscaleStability.bulk_gform">[docs]</a>    <span class="k">def</span> <span class="nf">bulk_gform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulk_entry</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the formation energy of the bulk</span>
<span class="sd">        Args:</span>
<span class="sd">            bulk_entry (ComputedStructureEntry): Entry of the corresponding bulk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">bulk_entry</span><span class="o">.</span><span class="n">energy</span><span class="o">/</span><span class="n">bulk_entry</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">volume</span></div>

<div class="viewcode-block" id="NanoscaleStability.scaled_wulff"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.NanoscaleStability.scaled_wulff">[docs]</a>    <span class="k">def</span> <span class="nf">scaled_wulff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wulffshape</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scales the Wulff shape with an effective radius r. Note that the resulting</span>
<span class="sd">            Wulff does not neccesarily have the same effective radius as the one</span>
<span class="sd">            provided. The Wulff shape is scaled by its surface energies where first</span>
<span class="sd">            the surface energies are scale by the minimum surface energy and then</span>
<span class="sd">            multiplied by the given effective radius.</span>

<span class="sd">        Args:</span>
<span class="sd">            wulffshape (WulffShape): Initial, unscaled WulffShape</span>
<span class="sd">            r (float): Arbitrary effective radius of the WulffShape</span>

<span class="sd">        Returns:</span>
<span class="sd">            WulffShape (scaled by r)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the scaling ratio for the energies</span>
        <span class="n">r_ratio</span> <span class="o">=</span> <span class="n">r</span><span class="o">/</span><span class="n">wulffshape</span><span class="o">.</span><span class="n">effective_radius</span>
        <span class="n">miller_list</span> <span class="o">=</span> <span class="n">wulffshape</span><span class="o">.</span><span class="n">miller_energy_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c1"># Normalize the magnitude of the facet normal vectors</span>
        <span class="c1"># of the Wulff shape by the minimum surface energy.</span>
        <span class="n">se_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">wulffshape</span><span class="o">.</span><span class="n">miller_energy_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="c1"># Scale the magnitudes by r_ratio</span>
        <span class="n">scaled_se</span> <span class="o">=</span> <span class="n">se_list</span> <span class="o">*</span> <span class="n">r_ratio</span>

        <span class="k">return</span> <span class="n">WulffShape</span><span class="p">(</span><span class="n">wulffshape</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">miller_list</span><span class="p">,</span>
                          <span class="n">scaled_se</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symprec</span><span class="p">)</span></div>

<div class="viewcode-block" id="NanoscaleStability.plot_one_stability_map"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.NanoscaleStability.plot_one_stability_map">[docs]</a>    <span class="k">def</span> <span class="nf">plot_one_stability_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analyzer</span><span class="p">,</span> <span class="n">max_r</span><span class="p">,</span> <span class="n">delu_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                               <span class="n">increments</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">delu_default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">plt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">from_sphere_area</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">e_units</span><span class="o">=</span><span class="s2">&quot;keV&quot;</span><span class="p">,</span>
                               <span class="n">r_units</span><span class="o">=</span><span class="s2">&quot;nanometers&quot;</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">scale_per_atom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the plot of the formation energy of a particle against its</span>
<span class="sd">            effect radius</span>

<span class="sd">        Args:</span>
<span class="sd">            analyzer (SurfaceEnergyPlotter): Analyzer associated with the</span>
<span class="sd">                first polymorph</span>
<span class="sd">            max_r (float): The maximum radius of the particle to plot up to.</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            label (str): Label of the plot for legend</span>
<span class="sd">            increments (int): Number of plot points</span>
<span class="sd">            delu_default (float): Default value for all unset chemical potentials</span>
<span class="sd">            plt (pylab): Plot</span>
<span class="sd">            from_sphere_area (bool): There are two ways to calculate the bulk</span>
<span class="sd">                formation energy. Either by treating the volume and thus surface</span>
<span class="sd">                area of the particle as a perfect sphere, or as a Wulff shape.</span>
<span class="sd">            r_units (str): Can be nanometers or Angstrom</span>
<span class="sd">            e_units (str): Can be keV or eV</span>
<span class="sd">            normalize (str): Whether or not to normalize energy by volume</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">plt</span> <span class="o">=</span> <span class="n">plt</span> <span class="k">if</span> <span class="n">plt</span> <span class="k">else</span> <span class="n">pretty_plot</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>

        <span class="n">wulffshape</span> <span class="o">=</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">wulff_from_chempot</span><span class="p">(</span><span class="n">delu_dict</span><span class="o">=</span><span class="n">delu_dict</span><span class="p">,</span>
                                                 <span class="n">delu_default</span><span class="o">=</span><span class="n">delu_default</span><span class="p">,</span>
                                                 <span class="n">symprec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symprec</span><span class="p">)</span>

        <span class="n">gform_list</span><span class="p">,</span> <span class="n">r_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">max_r</span><span class="p">,</span> <span class="n">increments</span><span class="p">):</span>
            <span class="n">gform</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wulff_gform_and_r</span><span class="p">(</span><span class="n">wulffshape</span><span class="p">,</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">ucell_entry</span><span class="p">,</span>
                                              <span class="n">r</span><span class="p">,</span> <span class="n">from_sphere_area</span><span class="o">=</span><span class="n">from_sphere_area</span><span class="p">,</span>
                                              <span class="n">r_units</span><span class="o">=</span><span class="n">r_units</span><span class="p">,</span> <span class="n">e_units</span><span class="o">=</span><span class="n">e_units</span><span class="p">,</span>
                                              <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
                                              <span class="n">scale_per_atom</span><span class="o">=</span><span class="n">scale_per_atom</span><span class="p">)</span>
            <span class="n">gform_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gform</span><span class="p">)</span>
            <span class="n">r_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="n">ru</span> <span class="o">=</span> <span class="s2">&quot;nm&quot;</span> <span class="k">if</span> <span class="n">r_units</span> <span class="o">==</span> <span class="s2">&quot;nanometers&quot;</span> <span class="k">else</span> <span class="s2">&quot;\AA&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Particle radius ($</span><span class="si">%s</span><span class="s2">$)&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">ru</span><span class="p">))</span>
        <span class="n">eu</span> <span class="o">=</span> <span class="s2">&quot;$</span><span class="si">%s</span><span class="s2">/</span><span class="si">%s</span><span class="s2">^3$&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">e_units</span><span class="p">,</span> <span class="n">ru</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$G_</span><span class="si">{form}</span><span class="s2">$ (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">eu</span><span class="p">))</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r_list</span><span class="p">,</span> <span class="n">gform_list</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">plt</span></div>

<div class="viewcode-block" id="NanoscaleStability.plot_all_stability_map"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.NanoscaleStability.plot_all_stability_map">[docs]</a>    <span class="k">def</span> <span class="nf">plot_all_stability_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_r</span><span class="p">,</span> <span class="n">increments</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">delu_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">delu_default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">plt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">from_sphere_area</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">e_units</span><span class="o">=</span><span class="s2">&quot;keV&quot;</span><span class="p">,</span>
                               <span class="n">r_units</span><span class="o">=</span><span class="s2">&quot;nanometers&quot;</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">scale_per_atom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the plot of the formation energy of a particles</span>
<span class="sd">            of different polymorphs against its effect radius</span>

<span class="sd">        Args:</span>
<span class="sd">            max_r (float): The maximum radius of the particle to plot up to.</span>
<span class="sd">            increments (int): Number of plot points</span>
<span class="sd">            delu_dict (Dict): Dictionary of the chemical potentials to be set as</span>
<span class="sd">                constant. Note the key should be a sympy Symbol object of the</span>
<span class="sd">                format: Symbol(&quot;delu_el&quot;) where el is the name of the element.</span>
<span class="sd">            delu_default (float): Default value for all unset chemical potentials</span>
<span class="sd">            plt (pylab): Plot</span>
<span class="sd">            labels (list): List of labels for each plot, corresponds to the</span>
<span class="sd">                list of se_analyzers</span>
<span class="sd">            from_sphere_area (bool): There are two ways to calculate the bulk</span>
<span class="sd">                formation energy. Either by treating the volume and thus surface</span>
<span class="sd">                area of the particle as a perfect sphere, or as a Wulff shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">plt</span> <span class="o">=</span> <span class="n">plt</span> <span class="k">if</span> <span class="n">plt</span> <span class="k">else</span> <span class="n">pretty_plot</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">analyzer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">se_analyzers</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">labels</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">plt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_one_stability_map</span><span class="p">(</span><span class="n">analyzer</span><span class="p">,</span> <span class="n">max_r</span><span class="p">,</span> <span class="n">delu_dict</span><span class="p">,</span>
                                              <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">plt</span><span class="o">=</span><span class="n">plt</span><span class="p">,</span>
                                              <span class="n">increments</span><span class="o">=</span><span class="n">increments</span><span class="p">,</span>
                                              <span class="n">delu_default</span><span class="o">=</span><span class="n">delu_default</span><span class="p">,</span>
                                              <span class="n">from_sphere_area</span><span class="o">=</span><span class="n">from_sphere_area</span><span class="p">,</span>
                                              <span class="n">e_units</span><span class="o">=</span><span class="n">e_units</span><span class="p">,</span> <span class="n">r_units</span><span class="o">=</span><span class="n">r_units</span><span class="p">,</span>
                                              <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
                                              <span class="n">scale_per_atom</span><span class="o">=</span><span class="n">scale_per_atom</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">plt</span></div></div>

        <span class="c1"># class GetChempotRange(object):</span>
        <span class="c1">#     def __init__(self, entry):</span>
        <span class="c1">#         self.entry = entry</span>
        <span class="c1">#</span>
        <span class="c1">#</span>
        <span class="c1"># class SlabEntryGenerator(object):</span>
        <span class="c1">#     def __init__(self, entry):</span>
        <span class="c1">#         self.entry = entry</span>

<div class="viewcode-block" id="sub_chempots"><a class="viewcode-back" href="../../../pymatgen.analysis.surface_analysis.html#pymatgen.analysis.surface_analysis.sub_chempots">[docs]</a><span class="k">def</span> <span class="nf">sub_chempots</span><span class="p">(</span><span class="n">gamma_dict</span><span class="p">,</span> <span class="n">chempots</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Uses dot product of numpy array to sub chemical potentials</span>
<span class="sd">        into the surface grand potential. This is much faster</span>
<span class="sd">        than using the subs function in sympy.</span>
<span class="sd">    Args:</span>
<span class="sd">        gamma_dict (dict): Surface grand potential equation</span>
<span class="sd">            as a coefficient dictionary</span>
<span class="sd">        chempots (dict): Dictionary assigning each chemical</span>
<span class="sd">            potential (key) in gamma a value</span>
<span class="sd">    Returns:</span>
<span class="sd">        Surface energy as a float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">gamma_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">gamma_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
    <span class="n">chempot_vals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">gamma_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">chempots</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">chempot_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">chempot_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chempot_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chempots</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">chempot_vals</span><span class="p">)</span></div>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pymatgen 2018.9.12 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../pymatgen.html" >pymatgen</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2011, Pymatgen Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.0.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>