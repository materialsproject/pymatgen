
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pymatgen.io.abinit.qadapters &#8212; pymatgen 2018.9.12 documentation</title>
    <link rel="stylesheet" href="../../../../_static/proBlue.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 2018.9.12 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../pymatgen.html" accesskey="U">pymatgen</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.io.abinit.qadapters</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="c1"># Copyright (c) Pymatgen Development Team.</span>
<span class="c1"># Distributed under the terms of the MIT License.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The initial version of this module was based on a similar implementation</span>
<span class="sd">present in FireWorks (https://pypi.python.org/pypi/FireWorks).</span>
<span class="sd">Work done by D. Waroquiers, A. Jain, and M. Kocher.</span>

<span class="sd">The main difference wrt the Fireworks implementation is that the QueueAdapter</span>
<span class="sd">objects provide a programmatic interface for setting important attributes</span>
<span class="sd">such as the number of MPI nodes, the number of OMP threads and the memory requirements.</span>
<span class="sd">This programmatic interface is used by the `TaskManager` for optimizing the parameters</span>
<span class="sd">of the run before submitting the job (Abinit provides the autoparal option that</span>
<span class="sd">allows one to get a list of parallel configuration and their expected efficiency).</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">getpass</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">qutils</span> <span class="k">as</span> <span class="n">qu</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">subprocess</span> <span class="k">import</span> <span class="n">Popen</span><span class="p">,</span> <span class="n">PIPE</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.io_utils</span> <span class="k">import</span> <span class="n">AtomicFile</span>
<span class="kn">from</span> <span class="nn">monty.string</span> <span class="k">import</span> <span class="n">is_string</span><span class="p">,</span> <span class="n">list_strings</span>
<span class="kn">from</span> <span class="nn">monty.collections</span> <span class="k">import</span> <span class="n">AttrDict</span>
<span class="kn">from</span> <span class="nn">monty.functools</span> <span class="k">import</span> <span class="n">lazy_property</span>
<span class="kn">from</span> <span class="nn">monty.inspect</span> <span class="k">import</span> <span class="n">all_subclasses</span>
<span class="kn">from</span> <span class="nn">monty.io</span> <span class="k">import</span> <span class="n">FileLock</span>
<span class="kn">from</span> <span class="nn">monty.json</span> <span class="k">import</span> <span class="n">MSONable</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.units</span> <span class="k">import</span> <span class="n">Memory</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">Condition</span>
<span class="kn">from</span> <span class="nn">.launcher</span> <span class="k">import</span> <span class="n">ScriptEditor</span>
<span class="kn">from</span> <span class="nn">.qjobs</span> <span class="k">import</span> <span class="n">QueueJob</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;make_qadapter&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Matteo Giantomassi&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2013, The Materials Project&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.1&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Matteo Giantomassi&quot;</span>


<span class="k">class</span> <span class="nc">SubmitResults</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;SubmitResult&quot;</span><span class="p">,</span> <span class="s2">&quot;qid, out, err, process&quot;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    named tuple createc by the concrete implementation of _submit_to_que to pass the results of the process of</span>
<span class="sd">    submitting the jobfile to the que.</span>
<span class="sd">    qid: queue id of the submission</span>
<span class="sd">    out: stdout of the submission</span>
<span class="sd">    err: stdrr of the submisison</span>
<span class="sd">    process: process object of the submission</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">MpiRunner</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object provides an abstraction for the mpirunner provided</span>
<span class="sd">    by the different MPI libraries. It&#39;s main task is handling the</span>
<span class="sd">    different syntax and options supported by the different mpirunners.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            name (str): Name of the mpirunner e.g. mpirun, mpiexec, srun ...</span>
<span class="sd">            type: Type of the mpirunner (not used at present)</span>
<span class="sd">            options (str): String with options passed to the mpi runner e.g. &quot;--bind-to None&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">string_to_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qad</span><span class="p">,</span> <span class="n">executable</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exec_args</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return a string with the command required to launch `executable` with the qadapter `qad`.</span>

<span class="sd">        Args</span>
<span class="sd">            qad: Qadapter instance.</span>
<span class="sd">            executable (str): Executable name or path</span>
<span class="sd">            stdin (str): Name of the file to be used as standard input. None means no redirection.</span>
<span class="sd">            stdout (str): Name of the file to be used as standard output. None means no redirection.</span>
<span class="sd">            stderr (str): Name of the file to be used as standard error. None means no redirection.</span>
<span class="sd">            exec_args: Optional list of strings with options passed to `executable`.</span>

<span class="sd">        Return:</span>
<span class="sd">            String with command to execute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stdin</span> <span class="o">=</span> <span class="s2">&quot;&lt; &quot;</span> <span class="o">+</span> <span class="n">stdin</span> <span class="k">if</span> <span class="n">stdin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">stdout</span> <span class="o">=</span> <span class="s2">&quot;&gt; &quot;</span> <span class="o">+</span> <span class="n">stdout</span> <span class="k">if</span> <span class="n">stdout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">stderr</span> <span class="o">=</span> <span class="s2">&quot;2&gt; &quot;</span> <span class="o">+</span> <span class="n">stderr</span> <span class="k">if</span> <span class="n">stderr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="n">exec_args</span><span class="p">:</span>
            <span class="n">executable</span> <span class="o">=</span> <span class="n">executable</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">list_strings</span><span class="p">(</span><span class="n">exec_args</span><span class="p">))</span>

        <span class="n">basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">basename</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mpirun&quot;</span><span class="p">,</span> <span class="s2">&quot;mpiexec&quot;</span><span class="p">,</span> <span class="s2">&quot;srun&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># $MPIRUN -n $MPI_PROCS $EXECUTABLE &lt; $STDIN &gt; $STDOUT 2&gt; $STDERR</span>
                <span class="n">num_opt</span> <span class="o">=</span> <span class="s2">&quot;-n &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">qad</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">)</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">num_opt</span><span class="p">,</span> <span class="n">executable</span><span class="p">,</span> <span class="n">stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;type </span><span class="si">%s</span><span class="s2"> is not supported!&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">basename</span> <span class="o">==</span> <span class="s2">&quot;runjob&quot;</span><span class="p">:</span>
            <span class="c1">#runjob --ranks-per-node 2 --exp-env OMP_NUM_THREADS --exe $ABINIT &lt; $STDIN &gt; $STDOUT 2&gt; $STDERR</span>
            <span class="c1">#runjob -n 2 --exp-env=OMP_NUM_THREADS --exe $ABINIT &lt; $STDIN &gt; $STDOUT 2&gt; $STDERR</span>
            <span class="c1"># exe must be absolute path or relative to cwd.</span>
            <span class="n">bg_size</span><span class="p">,</span> <span class="n">rpn</span> <span class="o">=</span> <span class="n">qad</span><span class="o">.</span><span class="n">bgsize_rankspernode</span><span class="p">()</span>
            <span class="c1">#num_opt = &quot;-n &quot; + str(qad.mpi_procs)</span>
            <span class="n">num_opt</span> <span class="o">=</span> <span class="s2">&quot;--ranks-per-node &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rpn</span><span class="p">)</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">num_opt</span><span class="p">,</span> <span class="s2">&quot;--exp-env OMP_NUM_THREADS&quot;</span><span class="p">,</span>
                           <span class="s2">&quot;--exe `which &quot;</span> <span class="o">+</span> <span class="n">executable</span> <span class="o">+</span> <span class="s2">&quot;` &quot;</span><span class="p">,</span> <span class="n">stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use mpi_procs &gt; when mpi_runner basename=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">basename</span><span class="p">)</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">executable</span><span class="p">,</span> <span class="n">stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">cmd</span>

    <span class="c1">#@property</span>
    <span class="c1">#def has_mpirun(self):</span>
    <span class="c1">#    &quot;&quot;&quot;True if we are running via mpirun, mpiexec ...&quot;&quot;&quot;</span>
    <span class="c1">#    return self.name in (&quot;mpirun&quot;, &quot;mpiexec&quot;, &quot;srun&quot;, &quot;runjob&quot;)</span>


<span class="k">class</span> <span class="nc">OmpEnv</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dictionary with the OpenMP environment variables</span>
<span class="sd">    see https://computing.llnl.gov/tutorials/openMP/#EnvironmentVariables</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_KEYS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;OMP_SCHEDULE&quot;</span><span class="p">,</span>
        <span class="s2">&quot;OMP_NUM_THREADS&quot;</span><span class="p">,</span>
        <span class="s2">&quot;OMP_DYNAMIC&quot;</span><span class="p">,</span>
        <span class="s2">&quot;OMP_PROC_BIND&quot;</span><span class="p">,</span>
        <span class="s2">&quot;OMP_NESTED&quot;</span><span class="p">,</span>
        <span class="s2">&quot;OMP_STACKSIZE&quot;</span><span class="p">,</span>
        <span class="s2">&quot;OMP_WAIT_POLICY&quot;</span><span class="p">,</span>
        <span class="s2">&quot;OMP_MAX_ACTIVE_LEVELS&quot;</span><span class="p">,</span>
        <span class="s2">&quot;OMP_THREAD_LIMIT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;OMP_STACKSIZE&quot;</span><span class="p">,</span>
        <span class="s2">&quot;OMP_PROC_BIND&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">as_ompenv</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert an object into a OmpEnv&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span> <span class="k">return</span> <span class="n">obj</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor method inherited from dictionary:</span>

<span class="sd">        &gt;&gt;&gt; assert OmpEnv(OMP_NUM_THREADS=1).OMP_NUM_THREADS == 1</span>

<span class="sd">        To create an instance from an INI file, use:</span>
<span class="sd">           OmpEnv.from_file(filename)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OmpEnv</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KEYS</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;unknown option </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span>

        <span class="k">if</span> <span class="n">err_msg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">export_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string with the bash statements needed to setup the OMP env.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;export </span><span class="si">%s</span><span class="s2">=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">Hardware</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object collects information on the hardware available in a given queue.</span>

<span class="sd">    Basic definitions:</span>

<span class="sd">        - A node refers to the physical box, i.e. cpu sockets with north/south switches connecting memory systems</span>
<span class="sd">          and extension cards, e.g. disks, nics, and accelerators</span>

<span class="sd">        - A cpu socket is the connector to these systems and the cpu cores</span>

<span class="sd">        - A cpu core is an independent computing with its own computing pipeline, logical units, and memory controller.</span>
<span class="sd">          Each cpu core will be able to service a number of cpu threads, each having an independent instruction stream</span>
<span class="sd">          but sharing the cores memory controller and other logical units.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;num_nodes&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sockets_per_node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sockets_per_node&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cores_per_socket</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;cores_per_socket&quot;</span><span class="p">))</span>

        <span class="c1"># Convert memory to megabytes.</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;mem_per_node&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Memory</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;Mb&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_node</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sockets_per_node</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">cores_per_socket</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid parameters: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found invalid keywords in the partition section:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;   num_nodes: </span><span class="si">%d</span><span class="s2">, sockets_per_node: </span><span class="si">%d</span><span class="s2">, cores_per_socket: </span><span class="si">%d</span><span class="s2">, mem_per_node </span><span class="si">%s</span><span class="s2">,&quot;</span> <span class="o">%</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sockets_per_node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cores_per_socket</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of cores available&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cores_per_socket</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sockets_per_node</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cores_per_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of cores per node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cores_per_socket</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sockets_per_node</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mem_per_core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Memory available on a single node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_node</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cores_per_node</span>

    <span class="k">def</span> <span class="nf">can_use_omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if omp_threads fit in a node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cores_per_node</span> <span class="o">&gt;=</span> <span class="n">omp_threads</span>

    <span class="k">def</span> <span class="nf">divmod_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Use divmod to compute (num_nodes, rest_cores)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="n">omp_threads</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cores_per_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;num_nodes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span>
                <span class="s1">&#39;sockets_per_node&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sockets_per_node</span><span class="p">,</span>
                <span class="s1">&#39;cores_per_socket&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cores_per_socket</span><span class="p">,</span>
                <span class="s1">&#39;mem_per_node&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">Memory</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;Mb&#39;</span><span class="p">))}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dd</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="n">dd</span><span class="p">[</span><span class="s1">&#39;num_nodes&#39;</span><span class="p">],</span>
                   <span class="n">sockets_per_node</span><span class="o">=</span><span class="n">dd</span><span class="p">[</span><span class="s1">&#39;sockets_per_node&#39;</span><span class="p">],</span>
                   <span class="n">cores_per_socket</span><span class="o">=</span><span class="n">dd</span><span class="p">[</span><span class="s1">&#39;cores_per_socket&#39;</span><span class="p">],</span>
                   <span class="n">mem_per_node</span><span class="o">=</span><span class="n">dd</span><span class="p">[</span><span class="s1">&#39;mem_per_node&#39;</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">_ExcludeNodesFile</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This file contains the list of nodes to be excluded.</span>
<span class="sd">    Nodes are indexed by queue name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DIRPATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">),</span> <span class="s2">&quot;.abinit&quot;</span><span class="p">,</span> <span class="s2">&quot;abipy&quot;</span><span class="p">)</span>
    <span class="n">FILEPATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">DIRPATH</span><span class="p">,</span> <span class="s2">&quot;exclude_nodes.json&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FILEPATH</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DIRPATH</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DIRPATH</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">FileLock</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FILEPATH</span><span class="p">):</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FILEPATH</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                    <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">({},</span> <span class="n">fh</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qname</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FILEPATH</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">qname</span><span class="p">,</span> <span class="p">[])</span>

    <span class="k">def</span> <span class="nf">add_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qname</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">(</span><span class="n">nodes</span><span class="p">,)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="k">else</span> <span class="n">nodes</span>
        <span class="k">with</span> <span class="n">FileLock</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FILEPATH</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">AtomicFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FILEPATH</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">qname</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="s2">&quot;qname&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
                    <span class="n">d</span><span class="p">[</span><span class="s2">&quot;qname&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;qname&quot;</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="s2">&quot;qname&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes</span>
                <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">fh</span><span class="p">)</span>

<span class="n">_EXCL_NODES_FILE</span> <span class="o">=</span> <span class="n">_ExcludeNodesFile</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">show_qparams</span><span class="p">(</span><span class="n">qtype</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Print to the given stream the template of the :class:`QueueAdapter` of type `qtype`.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">all_subclasses</span><span class="p">(</span><span class="n">QueueAdapter</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">QTYPE</span> <span class="o">==</span> <span class="n">qtype</span><span class="p">:</span> <span class="k">return</span> <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">QTEMPLATE</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find class associated to qtype </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">qtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">all_qtypes</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return sorted list with all qtypes supported.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="bp">cls</span><span class="o">.</span><span class="n">QTYPE</span> <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">all_subclasses</span><span class="p">(</span><span class="n">QueueAdapter</span><span class="p">)])</span>


<div class="viewcode-block" id="make_qadapter"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.qadapters.html#pymatgen.io.abinit.qadapters.make_qadapter">[docs]</a><span class="k">def</span> <span class="nf">make_qadapter</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the concrete :class:`QueueAdapter` class from a string.</span>
<span class="sd">    Note that one can register a customized version with:</span>

<span class="sd">    .. example::</span>

<span class="sd">        from qadapters import SlurmAdapter</span>

<span class="sd">        class MyAdapter(SlurmAdapter):</span>
<span class="sd">            QTYPE = &quot;myslurm&quot;</span>
<span class="sd">            # Add your customized code here</span>

<span class="sd">        # Register your class.</span>
<span class="sd">        SlurmAdapter.register(MyAdapter)</span>

<span class="sd">        make_qadapter(qtype=&quot;myslurm&quot;, **kwargs)</span>

<span class="sd">    .. warning::</span>

<span class="sd">        MyAdapter should be pickleable, hence one should declare it</span>
<span class="sd">        at the module level so that pickle can import it at run-time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get all known subclasses of QueueAdapter.</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="n">QTYPE</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">all_subclasses</span><span class="p">(</span><span class="n">QueueAdapter</span><span class="p">)}</span>

    <span class="c1"># Preventive copy before pop</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">qtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;queue&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;qtype&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">qtype</span><span class="p">](</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">QScriptTemplate</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">Template</span><span class="p">):</span>
    <span class="n">delimiter</span> <span class="o">=</span> <span class="s1">&#39;$$&#39;</span>


<span class="k">class</span> <span class="nc">QueueAdapterError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base Error class for exceptions raise by QueueAdapter.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">MaxNumLaunchesError</span><span class="p">(</span><span class="n">QueueAdapterError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised by `submit_to_queue` if we try to submit more than `max_num_launches` times.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">QueueAdapter</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">,</span> <span class="n">MSONable</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The `QueueAdapter` is responsible for all interactions with a specific queue management system.</span>
<span class="sd">    This includes handling all details of queue script format as well as queue submission and management.</span>

<span class="sd">    This is the **abstract** base class defining the methods that must be implemented by the concrete classes.</span>
<span class="sd">    Concrete classes should extend this class with implementations that work on specific queue systems.</span>

<span class="sd">    .. note::</span>

<span class="sd">        A `QueueAdapter` has a handler (:class:`QueueJob`) defined in qjobs.py that allows one</span>
<span class="sd">        to contact the resource manager to get info about the status of the job.</span>
<span class="sd">        Each concrete implementation of `QueueAdapter` should have a corresponding `QueueJob`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">QueueAdapterError</span>

    <span class="n">MaxNumLaunchesError</span> <span class="o">=</span> <span class="n">MaxNumLaunchesError</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">all_qtypes</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return sorted list with all qtypes supported.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">subcls</span><span class="o">.</span><span class="n">QTYPE</span> <span class="k">for</span> <span class="n">subcls</span> <span class="ow">in</span> <span class="n">all_subclasses</span><span class="p">(</span><span class="bp">cls</span><span class="p">)])</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autodoc</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2"># Dictionary with info on the hardware available on this queue.</span>
<span class="s2">hardware:</span>
<span class="s2">    num_nodes:           # Number of nodes available on this queue (integer, MANDATORY).</span>
<span class="s2">    sockets_per_node:    # Number of sockets per node (integer, MANDATORY).</span>
<span class="s2">    cores_per_socket:    # Number of cores per socket (integer, MANDATORY).</span>
<span class="s2">                         # The total number of cores available on this queue is</span>
<span class="s2">                         # `num_nodes * sockets_per_node * cores_per_socket`.</span>

<span class="s2"># Dictionary with the options used to prepare the enviroment before submitting the job</span>
<span class="s2">job:</span>
<span class="s2">    setup:                # List of commands (strings) executed before running (DEFAULT: empty)</span>
<span class="s2">    omp_env:              # Dictionary with OpenMP environment variables (DEFAULT: empty i.e. no OpenMP)</span>
<span class="s2">    modules:              # List of modules to be imported before running the code (DEFAULT: empty).</span>
<span class="s2">                          # NB: Error messages produced by module load are redirected to mods.err</span>
<span class="s2">    shell_env:            # Dictionary with shell environment variables.</span>
<span class="s2">    mpi_runner:           # MPI runner. Possible values in [&quot;mpirun&quot;, &quot;mpiexec&quot;, &quot;srun&quot;, None]</span>
<span class="s2">                          # DEFAULT: None i.e. no mpirunner is used.</span>
<span class="s2">    mpi_runner_options    # String with optional options passed to the `mpi_runner` e.g. &quot;--bind-to None&quot;</span>
<span class="s2">    shell_runner:         # Used for running small sequential jobs on the front-end. Set it to None</span>
<span class="s2">                          # if mpirun or mpiexec are not available on the fron-end. If not</span>
<span class="s2">                          # given, small sequential jobs are executed with `mpi_runner`.</span>
<span class="s2">    shell_runner_options  # Similar to mpi_runner_options but for the runner used on the front-end.</span>
<span class="s2">    pre_run:              # List of commands (strings) executed before the run (DEFAULT: empty)</span>
<span class="s2">    post_run:             # List of commands (strings) executed after the run (DEFAULT: empty)</span>

<span class="s2"># dictionary with the name of the queue and optional parameters</span>
<span class="s2"># used to build/customize the header of the submission script.</span>
<span class="s2">queue:</span>
<span class="s2">    qtype:                # String defining the qapapter type e.g. slurm, shell ...</span>
<span class="s2">    qname:                # Name of the submission queue (string, MANDATORY)</span>
<span class="s2">    qparams:              # Dictionary with values used to generate the header of the job script</span>
<span class="s2">                          # We use the *normalized* version of the options i.e dashes in the official name</span>
<span class="s2">                          # are replaced by underscores e.g. ``--mail-type`` becomes ``mail_type``</span>
<span class="s2">                          # See pymatgen.io.abinit.qadapters.py for the list of supported values.</span>
<span class="s2">                          # Use ``qverbatim`` to pass additional options that are not included in the template.</span>

<span class="s2"># dictionary with the constraints that must be fulfilled in order to run on this queue.</span>
<span class="s2">limits:</span>
<span class="s2">    min_cores:             # Minimum number of cores (integer, DEFAULT: 1)</span>
<span class="s2">    max_cores:             # Maximum number of cores (integer, MANDATORY). Hard limit to hint_cores:</span>
<span class="s2">                           # it&#39;s the limit beyond which the scheduler will not accept the job (MANDATORY).</span>
<span class="s2">    hint_cores:            # The limit used in the initial setup of jobs.</span>
<span class="s2">                           # Fix_Critical method may increase this number until max_cores is reached</span>
<span class="s2">    min_mem_per_proc:      # Minimum memory per MPI process in Mb, units can be specified e.g. 1.4 Gb</span>
<span class="s2">                           # (DEFAULT: hardware.mem_per_core)</span>
<span class="s2">    max_mem_per_proc:      # Maximum memory per MPI process in Mb, units can be specified e.g. `1.4Gb`</span>
<span class="s2">                           # (DEFAULT: hardware.mem_per_node)</span>
<span class="s2">    timelimit:             # Initial time-limit. Accepts time according to slurm-syntax i.e:</span>
<span class="s2">                           # &quot;days-hours&quot; or &quot;days-hours:minutes&quot; or &quot;days-hours:minutes:seconds&quot; or</span>
<span class="s2">                           # &quot;minutes&quot; or &quot;minutes:seconds&quot; or &quot;hours:minutes:seconds&quot;,</span>
<span class="s2">    timelimit_hard:        # The hard time-limit for this queue. Same format as timelimit.</span>
<span class="s2">                           # Error handlers could try to submit jobs with increased timelimit</span>
<span class="s2">                           # up to timelimit_hard. If not specified, timelimit_hard == timelimit</span>
<span class="s2">    condition:             # MongoDB-like condition (DEFAULT: empty, i.e. not used)</span>
<span class="s2">    allocation:            # String defining the policy used to select the optimal number of CPUs.</span>
<span class="s2">                           # possible values are in [&quot;nodes&quot;, &quot;force_nodes&quot;, &quot;shared&quot;]</span>
<span class="s2">                           # &quot;nodes&quot; means that we should try to allocate entire nodes if possible.</span>
<span class="s2">                           # This is a soft limit, in the sense that the qadapter may use a configuration</span>
<span class="s2">                           # that does not fulfill this requirement. In case of failure, it will try to use the</span>
<span class="s2">                           # smallest number of nodes compatible with the optimal configuration.</span>
<span class="s2">                           # Use `force_nodes` to enfore entire nodes allocation.</span>
<span class="s2">                           # `shared` mode does not enforce any constraint (DEFAULT: shared).</span>
<span class="s2">    max_num_launches:      # Limit to the number of times a specific task can be restarted (integer, DEFAULT: 5)</span>
<span class="s2">&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            qname: Name of the queue.</span>
<span class="sd">            qparams: Dictionary with the parameters used in the template.</span>
<span class="sd">            setup: String or list of commands to execute during the initial setup.</span>
<span class="sd">            modules: String or list of modules to load before running the application.</span>
<span class="sd">            shell_env: Dictionary with the environment variables to export before running the application.</span>
<span class="sd">            omp_env: Dictionary with the OpenMP variables.</span>
<span class="sd">            pre_run: String or list of commands to execute before launching the calculation.</span>
<span class="sd">            post_run: String or list of commands to execute once the calculation is completed.</span>
<span class="sd">            mpi_runner: Path to the MPI runner or :class:`MpiRunner` instance. None if not used</span>
<span class="sd">            mpi_runner_options: Optional string with options passed to the mpi_runner.</span>
<span class="sd">            max_num_launches: Maximum number of submissions that can be done for a specific task. Defaults to 5</span>
<span class="sd">            qverbatim:</span>
<span class="sd">            min_cores, max_cores, hint_cores: Minimum, maximum, and hint limits of number of cores that can be used</span>
<span class="sd">            min_mem_per_proc=Minimum memory per process in megabytes.</span>
<span class="sd">            max_mem_per_proc=Maximum memory per process in megabytes.</span>
<span class="sd">            timelimit: initial time limit in seconds</span>
<span class="sd">            timelimit_hard: hard limelimit for this queue</span>
<span class="sd">            priority: Priority level, integer number &gt; 0</span>
<span class="sd">            condition: Condition object (dictionary)</span>

<span class="sd">        .. note::</span>

<span class="sd">            priority is a non-negative integer used to order the qadapters. The :class:`TaskManager` will</span>
<span class="sd">                try to run jobs on the qadapter with the highest priority if possible</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO</span>
        <span class="c1">#task_classes</span>

        <span class="c1"># Make defensive copies so that we can change the values at runtime.</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;priority&quot;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hw</span> <span class="o">=</span> <span class="n">Hardware</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;hardware&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_queue</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;queue&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_limits</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;limits&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_job</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;job&quot;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_master_mem_overhead</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;master_mem_overhead&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="c1"># List of dictionaries with the parameters used to submit jobs</span>
        <span class="c1"># The launcher will use this information to increase the resources</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">launches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found unknown keywords:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">validate_qparams</span><span class="p">()</span>

        <span class="c1"># Initialize some values from the info reported in the partition.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_cores</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_mem_per_proc</span><span class="p">)</span>

        <span class="c1"># Final consistency check.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_qparams</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a simple though not complete dict serialization of the object (OMP missing, not all limits are</span>
<span class="sd">        kept in the dictionary, ... other things to be checked)</span>

<span class="sd">        Raise:</span>
<span class="sd">            `ValueError` if errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;as_dict method of QueueAdapter not yet implemented when OpenMP is activated&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;@module&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                <span class="s1">&#39;@class&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="s1">&#39;priority&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">,</span>
                <span class="s1">&#39;hardware&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
                <span class="s1">&#39;queue&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;qtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">QTYPE</span><span class="p">,</span>
                          <span class="s1">&#39;qname&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qname</span><span class="p">,</span>
                          <span class="s1">&#39;qnodes&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">qnodes</span><span class="p">,</span>
                          <span class="s1">&#39;qparams&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qparams</span><span class="p">},</span>
                <span class="s1">&#39;limits&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;timelimit_hard&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timelimit_hard</span><span class="p">,</span>
                           <span class="s1">&#39;timelimit&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timelimit</span><span class="p">,</span>
                           <span class="s1">&#39;min_cores&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_cores</span><span class="p">,</span>
                           <span class="s1">&#39;max_cores&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span><span class="p">,</span>
                           <span class="s1">&#39;min_mem_per_proc&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_mem_per_proc</span><span class="p">,</span>
                           <span class="s1">&#39;max_mem_per_proc&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_mem_per_proc</span><span class="p">,</span>
                           <span class="s1">&#39;memory_policy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_policy</span>
                           <span class="p">},</span>
                <span class="s1">&#39;job&#39;</span><span class="p">:</span> <span class="p">{},</span>
                <span class="s1">&#39;mpi_procs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mpi_procs</span><span class="p">,</span>
                <span class="s1">&#39;mem_per_proc&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mem_per_proc</span><span class="p">,</span>
                <span class="s1">&#39;master_mem_overhead&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_master_mem_overhead</span>
                <span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dd</span><span class="p">):</span>
        <span class="n">priority</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;priority&#39;</span><span class="p">)</span>
        <span class="n">hardware</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;hardware&#39;</span><span class="p">)</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;queue&#39;</span><span class="p">)</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;limits&#39;</span><span class="p">)</span>
        <span class="n">job</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;job&#39;</span><span class="p">)</span>
        <span class="n">qa</span> <span class="o">=</span> <span class="n">make_qadapter</span><span class="p">(</span><span class="n">priority</span><span class="o">=</span><span class="n">priority</span><span class="p">,</span> <span class="n">hardware</span><span class="o">=</span><span class="n">hardware</span><span class="p">,</span> <span class="n">queue</span><span class="o">=</span><span class="n">queue</span><span class="p">,</span> <span class="n">limits</span><span class="o">=</span><span class="n">limits</span><span class="p">,</span> <span class="n">job</span><span class="o">=</span><span class="n">job</span><span class="p">)</span>
        <span class="n">qa</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;mpi_procs&#39;</span><span class="p">))</span>
        <span class="n">qa</span><span class="o">.</span><span class="n">set_mem_per_proc</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;mem_per_proc&#39;</span><span class="p">))</span>
        <span class="n">qa</span><span class="o">.</span><span class="n">set_master_mem_overhead</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;master_mem_overhead&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">timelimit</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;timelimit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">timelimit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qa</span><span class="o">.</span><span class="n">set_timelimit</span><span class="p">(</span><span class="n">timelimit</span><span class="o">=</span><span class="n">timelimit</span><span class="p">)</span>
        <span class="n">dd</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;@module&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">dd</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;@class&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dd</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found unknown keywords:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">dd</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">qa</span>

    <span class="k">def</span> <span class="nf">validate_qparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the keys specified by the user in qparams are supported.</span>

<span class="sd">        Raise:</span>
<span class="sd">            `ValueError` if errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># No validation for ShellAdapter.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ShellAdapter</span><span class="p">):</span> <span class="k">return</span>

        <span class="c1"># Parse the template so that we know the list of supported options.</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">supported_qparams</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;Unsupported QUEUE parameter name </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">param</span>
                <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;Supported parameters:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">param_sup</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">supported_qparams</span><span class="p">:</span>
                    <span class="n">err_msg</span> <span class="o">+=</span> <span class="s2">&quot;    </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">param_sup</span>

        <span class="k">if</span> <span class="n">err_msg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parse_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="c1"># Time limits.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_timelimit</span><span class="p">(</span><span class="n">qu</span><span class="o">.</span><span class="n">timelimit_parser</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;timelimit&quot;</span><span class="p">)))</span>
        <span class="n">tl_hard</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;timelimit_hard&quot;</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">tl_hard</span> <span class="o">=</span> <span class="n">qu</span><span class="o">.</span><span class="n">timelimit_parser</span><span class="p">(</span><span class="n">tl_hard</span><span class="p">)</span> <span class="k">if</span> <span class="n">tl_hard</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">timelimit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_timelimit_hard</span><span class="p">(</span><span class="n">tl_hard</span><span class="p">)</span>

        <span class="c1"># Cores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_cores</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;min_cores&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;max_cores&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hint_cores</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;hint_cores&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory_policy</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;memory_policy&quot;</span><span class="p">,</span> <span class="s2">&quot;mem&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_cores</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_cores </span><span class="si">%s</span><span class="s2"> cannot be greater than max_cores </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_cores</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span><span class="p">))</span>

        <span class="c1"># Memory</span>
        <span class="c1"># FIXME: Neeed because autoparal 1 with paral_kgb 1 is not able to estimate memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_mem_per_proc</span> <span class="o">=</span> <span class="n">qu</span><span class="o">.</span><span class="n">any2mb</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;min_mem_per_proc&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_core</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_mem_per_proc</span> <span class="o">=</span> <span class="n">qu</span><span class="o">.</span><span class="n">any2mb</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;max_mem_per_proc&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">))</span>

        <span class="c1"># Misc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_num_launches</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;max_num_launches&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;condition&quot;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocation</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;allocation&quot;</span><span class="p">,</span> <span class="s2">&quot;shared&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;nodes&quot;</span><span class="p">,</span> <span class="s2">&quot;force_nodes&quot;</span><span class="p">,</span> <span class="s2">&quot;shared&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong value for `allocation` option&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found unknown keyword(s) in limits section:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_parse_job</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">setup</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;setup&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">setup</span><span class="p">):</span> <span class="n">setup</span> <span class="o">=</span> <span class="p">[</span><span class="n">setup</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup</span> <span class="o">=</span> <span class="n">setup</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">setup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="n">omp_env</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;omp_env&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omp_env</span> <span class="o">=</span> <span class="n">omp_env</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">omp_env</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>

        <span class="n">modules</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;modules&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">modules</span><span class="p">):</span> <span class="n">modules</span> <span class="o">=</span> <span class="p">[</span><span class="n">modules</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modules</span> <span class="o">=</span> <span class="n">modules</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">modules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="n">shell_env</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;shell_env&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shell_env</span> <span class="o">=</span> <span class="n">shell_env</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">shell_env</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>

        <span class="n">mpi_options</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;mpi_runner_options&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mpi_runner</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;mpi_runner&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_runner</span><span class="p">,</span> <span class="n">MpiRunner</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpi_runner</span> <span class="o">=</span> <span class="n">MpiRunner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_runner</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">mpi_options</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shell_runner</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;shell_runner&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">shell_runner_options</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;shell_runner_options&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shell_runner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shell_runner</span> <span class="o">=</span> <span class="n">MpiRunner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shell_runner</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">shell_runner_options</span><span class="p">)</span>

        <span class="n">pre_run</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;pre_run&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">pre_run</span><span class="p">):</span> <span class="n">pre_run</span> <span class="o">=</span> <span class="p">[</span><span class="n">pre_run</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_run</span> <span class="o">=</span> <span class="n">pre_run</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">pre_run</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="n">post_run</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;post_run&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">post_run</span><span class="p">):</span> <span class="n">post_run</span> <span class="o">=</span> <span class="p">[</span><span class="n">post_run</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">post_run</span> <span class="o">=</span> <span class="n">post_run</span><span class="p">[:]</span> <span class="k">if</span> <span class="n">post_run</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found unknown keyword(s) in job section:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_parse_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="c1"># Init params</span>
        <span class="n">qparams</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;qparams&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qparams</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">qparams</span><span class="p">)</span> <span class="k">if</span> <span class="n">qparams</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_qname</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;qname&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qnodes</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;qnodes&quot;</span><span class="p">,</span> <span class="s2">&quot;standard&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qnodes</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;standard&quot;</span><span class="p">,</span> <span class="s2">&quot;shared&quot;</span><span class="p">,</span> <span class="s2">&quot;exclusive&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nodes must be either in standard, shared or exclusive mode &quot;</span>
                             <span class="s2">&quot;while qnodes parameter was </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qnodes</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found unknown keyword(s) in queue section:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qname</span><span class="p">)]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Hardware:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="p">))</span>
        <span class="c1">#lines.extend([&quot;qparams:\n&quot;, str(self.qparams)])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omp_env</span><span class="p">))</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dictionary with the parameters used to construct the header.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qparams</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">supported_qparams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dictionary with the supported parameters that can be passed to the</span>
<span class="sd">        queue manager (obtained by parsing QTEMPLATE).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">re</span>
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\$\$\{(\w+)\}&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">QTEMPLATE</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_mpi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are using MPI&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_runner</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_omp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are using OpenMP threads&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;omp_env&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;omp_env&quot;</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of cores employed&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of OpenMP threads.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_env</span><span class="p">[</span><span class="s2">&quot;OMP_NUM_THREADS&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pure_mpi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if only MPI is used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_mpi</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pure_omp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if only OpenMP is used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_mpi</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hybrid_mpi_omp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are running in MPI+Openmp mode.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_mpi</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">run_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with info on the run.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;MPI: </span><span class="si">%d</span><span class="s2">, OMP: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy of the object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">record_launch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue_id</span><span class="p">):</span> <span class="c1"># retcode):</span>
        <span class="sd">&quot;&quot;&quot;Save submission&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">launches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">AttrDict</span><span class="p">(</span><span class="n">queue_id</span><span class="o">=</span><span class="n">queue_id</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="n">omp_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span><span class="p">,</span>
                     <span class="n">mem_per_proc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">,</span> <span class="n">timelimit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timelimit</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">launches</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_launch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove launch with the given index.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">launches</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_launches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of submission tried with this adapter so far.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">launches</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">last_launch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the last launch.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">launches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">launches</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Validate the parameters of the run. Raises self.Error if invalid parameters.&quot;&quot;&quot;</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">append</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hint_cores</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_cores</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;self.hint_cores &gt;= mpi_procs * omp_threads &gt;= self.min_cores not satisfied&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;omp_threads &gt; hw.cores_per_node&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;mem_mb &gt;= self.hw.mem_per_node&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_mem_per_proc</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_mem_per_proc</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;self.max_mem_per_proc &gt;= mem_mb &gt;= self.min_mem_per_proc not satisfied&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;priority must be &gt; 0&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_cores</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">num_cores</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hint_cores</span><span class="p">):</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;1 &lt;= min_cores &lt;= hardware num_cores &gt;= hint_cores not satisfied&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of OpenMP threads.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omp_env</span><span class="p">[</span><span class="s2">&quot;OMP_NUM_THREADS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">omp_threads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of CPUs used for MPI.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mpi_procs</span>

    <span class="k">def</span> <span class="nf">set_mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of MPI processes to mpi_procs&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mpi_procs</span> <span class="o">=</span> <span class="n">mpi_procs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of the queue.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qname</span>

    <span class="k">def</span> <span class="nf">set_qname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qname</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the name of the queue.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qname</span> <span class="o">=</span> <span class="n">qname</span>

    <span class="c1"># todo this assumes only one wall time. i.e. the one in the mananager file is the one always used.</span>
    <span class="c1"># we should use the standard walltime to start with but also allow to increase the walltime</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timelimit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the walltime in seconds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timelimit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timelimit_hard</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the walltime in seconds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timelimit_hard</span>

    <span class="k">def</span> <span class="nf">set_timelimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timelimit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the start walltime in seconds, fix method may increase this one until timelimit_hard is reached.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timelimit</span> <span class="o">=</span> <span class="n">timelimit</span>

    <span class="k">def</span> <span class="nf">set_timelimit_hard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timelimit_hard</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the maximal possible walltime in seconds.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timelimit_hard</span> <span class="o">=</span> <span class="n">timelimit_hard</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The memory per process in megabytes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mem_per_proc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">master_mem_overhead</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The memory overhead for the master process in megabytes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_master_mem_overhead</span>

    <span class="k">def</span> <span class="nf">set_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem_mb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the memory per process in megabytes. If mem_mb &lt;=0, min_mem_per_proc is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Hack needed because abinit is still not able to estimate memory.</span>
        <span class="c1"># COMMENTED by David.</span>
        <span class="c1"># This is not needed anymore here because the &quot;hack&quot; is performed directly in select_qadapter/_use_qadpos_pconf</span>
        <span class="c1"># methods of TaskManager. Moreover, this hack should be performed somewhere else (this part should be</span>
        <span class="c1"># independent of abinit ... and if we want to have less memory than the average memory available per node, we</span>
        <span class="c1"># have to allow it!)</span>
        <span class="c1">#if mem_mb &lt;= self.min_mem_per_proc: mem_mb = self.min_mem_per_proc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mem_per_proc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mem_mb</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_master_mem_overhead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem_mb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the memory overhead for the master process in megabytes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mem_mb</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Memory overhead for the master process should be &gt;= 0&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_master_mem_overhead</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mem_mb</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">total_mem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total memory required by the job in megabytes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Memory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">master_mem_overhead</span><span class="p">,</span> <span class="s2">&quot;Mb&quot;</span><span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cancel the job.</span>

<span class="sd">        Args:</span>
<span class="sd">            job_id: Job identifier.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Exit status.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">can_run_pconf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pconf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the qadapter in principle is able to run the :class:`ParalConf` pconf&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hint_cores</span> <span class="o">&gt;=</span> <span class="n">pconf</span><span class="o">.</span><span class="n">num_cores</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_cores</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">can_use_omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span><span class="p">):</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">pconf</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocation</span> <span class="o">==</span> <span class="s2">&quot;force_nodes&quot;</span> <span class="ow">and</span> <span class="n">pconf</span><span class="o">.</span><span class="n">num_cores</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">pconf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">distribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">,</span> <span class="n">mem_per_proc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns (num_nodes, mpi_per_node)</span>

<span class="sd">        Aggressive: When Open MPI thinks that it is in an exactly- or under-subscribed mode</span>
<span class="sd">        (i.e., the number of running processes is equal to or less than the number of available processors),</span>
<span class="sd">        MPI processes will automatically run in aggressive mode, meaning that they will never voluntarily give</span>
<span class="sd">        up the processor to other processes. With some network transports, this means that Open MPI will spin</span>
<span class="sd">        in tight loops attempting to make message passing progress, effectively causing other processes to not get</span>
<span class="sd">        any CPU cycles (and therefore never make any progress)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">class</span> <span class="nc">Distrib</span><span class="p">(</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Distrib&quot;</span><span class="p">,</span> <span class="s2">&quot;num_nodes mpi_per_node exact&quot;</span><span class="p">)):</span>
            <span class="k">pass</span>
            <span class="c1">#@property</span>
            <span class="c1">#def mem_per_node</span>
            <span class="c1">#    return self.mpi_per_node * mem_per_proc</span>
            <span class="c1">#def set_nodes(self, nodes):</span>

        <span class="n">hw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span>

        <span class="c1"># TODO: Add check on user-memory</span>
        <span class="k">if</span> <span class="n">mem_per_proc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;mem_per_proc &lt;= 0&quot;</span><span class="p">)</span>
            <span class="n">mem_per_proc</span> <span class="o">=</span> <span class="n">hw</span><span class="o">.</span><span class="n">mem_per_core</span>

        <span class="k">if</span> <span class="n">mem_per_proc</span> <span class="o">&gt;</span> <span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span>
                <span class="s2">&quot;mem_per_proc &gt; mem_per_node.</span><span class="se">\n</span><span class="s2"> Cannot distribute mpi_procs </span><span class="si">%d</span><span class="s2">, omp_threads </span><span class="si">%d</span><span class="s2">, mem_per_proc </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">,</span> <span class="n">mem_per_proc</span><span class="p">))</span>

        <span class="c1"># Try to use all then cores in the node.</span>
        <span class="n">num_nodes</span><span class="p">,</span> <span class="n">rest_cores</span> <span class="o">=</span> <span class="n">hw</span><span class="o">.</span><span class="n">divmod_node</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_nodes</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">mpi_procs</span> <span class="o">*</span> <span class="n">mem_per_proc</span> <span class="o">&lt;=</span> <span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">:</span>
            <span class="c1"># One node is enough</span>
            <span class="k">return</span> <span class="n">Distrib</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mpi_per_node</span><span class="o">=</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_nodes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">num_nodes</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">mpi_per_node</span> <span class="o">=</span> <span class="n">mpi_procs</span> <span class="o">//</span> <span class="n">num_nodes</span>
        <span class="k">if</span> <span class="n">mpi_per_node</span> <span class="o">*</span> <span class="n">mem_per_proc</span> <span class="o">&lt;=</span> <span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span> <span class="ow">and</span> <span class="n">rest_cores</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Commensurate with nodes.</span>
            <span class="k">return</span> <span class="n">Distrib</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">mpi_per_node</span><span class="o">=</span><span class="n">mpi_per_node</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1">#if mode == &quot;block&quot;, &quot;cyclic&quot;</span>

        <span class="c1"># Try first to pack MPI processors in a node as much as possible</span>
        <span class="n">mpi_per_node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span> <span class="o">/</span> <span class="n">mem_per_proc</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">mpi_per_node</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">num_nodes</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="n">omp_threads</span><span class="p">)</span> <span class="o">//</span> <span class="n">mpi_per_node</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;exact --&gt; false&quot;</span><span class="p">,</span> <span class="n">num_nodes</span><span class="p">,</span> <span class="n">mpi_per_node</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mpi_per_node</span> <span class="o">*</span> <span class="n">omp_threads</span> <span class="o">&lt;=</span> <span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span> <span class="ow">and</span> <span class="n">mem_per_proc</span> <span class="o">&lt;=</span> <span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Distrib</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">mpi_per_node</span><span class="o">=</span><span class="n">mpi_per_node</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="n">omp_threads</span><span class="p">)</span> <span class="o">%</span> <span class="n">mpi_per_node</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Have to reduce the number of MPI procs per node</span>
            <span class="k">for</span> <span class="n">mpi_per_node</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mpi_per_node</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">mpi_per_node</span> <span class="o">&gt;</span> <span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">num_nodes</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="n">omp_threads</span><span class="p">)</span> <span class="o">//</span> <span class="n">mpi_per_node</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="n">omp_threads</span><span class="p">)</span> <span class="o">%</span> <span class="n">mpi_per_node</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">mpi_per_node</span> <span class="o">*</span> <span class="n">mem_per_proc</span> <span class="o">&lt;=</span> <span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Distrib</span><span class="p">(</span><span class="n">num_nodes</span><span class="o">=</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">mpi_per_node</span><span class="o">=</span><span class="n">mpi_per_node</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Cannot distribute mpi_procs </span><span class="si">%d</span><span class="s2">, omp_threads </span><span class="si">%d</span><span class="s2">, mem_per_proc </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">,</span> <span class="n">mem_per_proc</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">optimize_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qnodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called in get_subs_dict. Return a dict with parameters to be added to qparams</span>
<span class="sd">        Subclasses may provide a specialized version.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#logger.debug(&quot;optimize_params of baseclass --&gt; no optimization available!!!&quot;)</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">get_subs_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qnodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return substitution dict for replacements into the template</span>
<span class="sd">        Subclasses may want to customize this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#d = self.qparams.copy()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimize_params</span><span class="p">(</span><span class="n">qnodes</span><span class="o">=</span><span class="n">qnodes</span><span class="p">))</span>
        <span class="c1"># clean null values</span>
        <span class="n">subs_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="c1">#print(&quot;subs_dict:&quot;, subs_dict)</span>
        <span class="k">return</span> <span class="n">subs_dict</span>

    <span class="k">def</span> <span class="nf">_make_qheader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_name</span><span class="p">,</span> <span class="n">qout_path</span><span class="p">,</span> <span class="n">qerr_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a string with the options that are passed to the resource manager.&quot;&quot;&quot;</span>
        <span class="c1"># get substitution dict for replacements into the template</span>
        <span class="n">subs_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subs_dict</span><span class="p">()</span>

        <span class="c1"># Set job_name and the names for the stderr and stdout of the</span>
        <span class="c1"># queue manager (note the use of the extensions .qout and .qerr</span>
        <span class="c1"># so that we can easily locate this file.</span>
        <span class="n">subs_dict</span><span class="p">[</span><span class="s1">&#39;job_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">job_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="n">subs_dict</span><span class="p">[</span><span class="s1">&#39;_qout_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qout_path</span>
        <span class="n">subs_dict</span><span class="p">[</span><span class="s1">&#39;_qerr_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qerr_path</span>

        <span class="n">qtemplate</span> <span class="o">=</span> <span class="n">QScriptTemplate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">QTEMPLATE</span><span class="p">)</span>
        <span class="c1"># might contain unused parameters as leftover $$.</span>
        <span class="n">unclean_template</span> <span class="o">=</span> <span class="n">qtemplate</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="n">subs_dict</span><span class="p">)</span>

        <span class="c1"># Remove lines with leftover $$.</span>
        <span class="n">clean_template</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">unclean_template</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;$$&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">clean_template</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">clean_template</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_script_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_name</span><span class="p">,</span> <span class="n">launch_dir</span><span class="p">,</span> <span class="n">executable</span><span class="p">,</span> <span class="n">qout_path</span><span class="p">,</span> <span class="n">qerr_path</span><span class="p">,</span>
                       <span class="n">stdin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exec_args</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a (multi-line) String representing the queue script, e.g. PBS script.</span>
<span class="sd">        Uses the template_file along with internal parameters to create the script.</span>

<span class="sd">        Args:</span>
<span class="sd">            job_name: Name of the job.</span>
<span class="sd">            launch_dir: (str) The directory the job will be launched in.</span>
<span class="sd">            executable: String with the name of the executable to be executed or list of commands</span>
<span class="sd">            qout_path Path of the Queue manager output file.</span>
<span class="sd">            qerr_path: Path of the Queue manager error file.</span>
<span class="sd">            exec_args: List of arguments passed to executable (used only if executable is a string, default: empty)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># PbsPro does not accept job_names longer than 15 chars.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">job_name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">14</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">PbsProAdapter</span><span class="p">):</span>
            <span class="n">job_name</span> <span class="o">=</span> <span class="n">job_name</span><span class="p">[:</span><span class="mi">14</span><span class="p">]</span>

        <span class="c1"># Construct the header for the Queue Manager.</span>
        <span class="n">qheader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_qheader</span><span class="p">(</span><span class="n">job_name</span><span class="p">,</span> <span class="n">qout_path</span><span class="p">,</span> <span class="n">qerr_path</span><span class="p">)</span>

        <span class="c1"># Add the bash section.</span>
        <span class="n">se</span> <span class="o">=</span> <span class="n">ScriptEditor</span><span class="p">()</span>

        <span class="c1"># Cd to launch_dir immediately.</span>
        <span class="n">se</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="s2">&quot;cd &quot;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">launch_dir</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">:</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_comment</span><span class="p">(</span><span class="s2">&quot;Setup section&quot;</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_lines</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_emptyline</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
            <span class="c1"># stderr is redirected to mods.err file.</span>
            <span class="c1"># module load 2&gt;&gt; mods.err</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_comment</span><span class="p">(</span><span class="s2">&quot;Load Modules&quot;</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="s2">&quot;module purge&quot;</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">load_modules</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modules</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_emptyline</span><span class="p">()</span>

        <span class="n">se</span><span class="o">.</span><span class="n">add_comment</span><span class="p">(</span><span class="s2">&quot;OpenMp Environment&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span><span class="p">:</span>
            <span class="n">se</span><span class="o">.</span><span class="n">declare_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omp_env</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_emptyline</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">se</span><span class="o">.</span><span class="n">declare_vars</span><span class="p">({</span><span class="s2">&quot;OMP_NUM_THREADS&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shell_env</span><span class="p">:</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_comment</span><span class="p">(</span><span class="s2">&quot;Shell Environment&quot;</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">declare_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shell_env</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_emptyline</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_run</span><span class="p">:</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_comment</span><span class="p">(</span><span class="s2">&quot;Commands before execution&quot;</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_lines</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pre_run</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_emptyline</span><span class="p">()</span>

        <span class="c1"># Construct the string to run the executable with MPI and mpi_procs.</span>
        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">executable</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_runner</span><span class="o">.</span><span class="n">string_to_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">executable</span><span class="p">,</span>
                                                 <span class="n">stdin</span><span class="o">=</span><span class="n">stdin</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">stderr</span><span class="p">,</span> <span class="n">exec_args</span><span class="o">=</span><span class="n">exec_args</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">executable</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_lines</span><span class="p">(</span><span class="n">executable</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">post_run</span><span class="p">:</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_emptyline</span><span class="p">()</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_comment</span><span class="p">(</span><span class="s2">&quot;Commands after execution&quot;</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">add_lines</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">post_run</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">qheader</span> <span class="o">+</span> <span class="n">se</span><span class="o">.</span><span class="n">get_script_str</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">submit_to_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">script_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Public API: wraps the concrete implementation _submit_to_queue</span>

<span class="sd">        Raises:</span>
<span class="sd">            `self.MaxNumLaunchesError` if we have already tried to submit the job max_num_launches</span>
<span class="sd">            `self.Error` if generic error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">script_file</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;Cannot find script file located at: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">script_file</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_launches</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_launches</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">MaxNumLaunchesError</span><span class="p">(</span><span class="s2">&quot;num_launches </span><span class="si">%s</span><span class="s2"> == max_num_launches </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_launches</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_num_launches</span><span class="p">))</span>

        <span class="c1"># Call the concrete implementation.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_submit_to_queue</span><span class="p">(</span><span class="n">script_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record_launch</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">qid</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">qid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Error in job submission with </span><span class="si">%s</span><span class="s2">. file </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">script_file</span><span class="p">)</span> <span class="o">+</span>
                             <span class="s2">&quot;The error response reads:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">s</span><span class="o">.</span><span class="n">err</span> <span class="o">+</span>
                             <span class="s2">&quot;The out response reads:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">s</span><span class="o">.</span><span class="n">out</span><span class="p">)</span>

        <span class="c1"># Here we create a concrete instance of QueueJob</span>
        <span class="k">return</span> <span class="n">QueueJob</span><span class="o">.</span><span class="n">from_qtype_and_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">QTYPE</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">qid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qname</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">process</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_submit_to_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">script_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Submits the job to the queue, probably using subprocess or shutil</span>
<span class="sd">        This method must be provided by the concrete classes and will be called by submit_to_queue</span>

<span class="sd">        Args:</span>
<span class="sd">            script_file:  (str) name of the script file to use (String)</span>

<span class="sd">        Returns:</span>
<span class="sd">            queue_id, process</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_njobs_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the number of jobs in the queue, probably using subprocess or shutil to</span>
<span class="sd">        call a command like &#39;qstat&#39;. returns None when the number of jobs cannot be determined.</span>

<span class="sd">        Args:</span>
<span class="sd">            username: (str) the username of the jobs to count (default is to autodetect)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">username</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">username</span> <span class="o">=</span> <span class="n">getpass</span><span class="o">.</span><span class="n">getuser</span><span class="p">()</span>
        <span class="n">njobs</span><span class="p">,</span> <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_njobs_in_queue</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">username</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">process</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">process</span><span class="o">.</span><span class="n">returncode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># there&#39;s a problem talking to squeue server?</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Error trying to get the number of jobs in the queue&#39;</span> <span class="o">+</span>
                       <span class="s1">&#39;The error response reads:</span><span class="se">\n</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">process</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">read</span><span class="p">()))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ShellAdapter</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;The number of jobs currently in the queue is: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">njobs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">njobs</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_get_njobs_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concrete Subclasses must implement this method. Return (njobs, process)</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="c1"># Methods to fix problems</span>
    <span class="k">def</span> <span class="nf">add_exclude_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_EXCL_NODES_FILE</span><span class="o">.</span><span class="n">add_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qname</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_exclude_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_EXCL_NODES_FILE</span><span class="o">.</span><span class="n">read_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qname</span><span class="p">)</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">exclude_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to exclude nodes in the calculation. Return True if nodes have been excluded&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">more_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to increase the amount of memory asked for, by factor.</span>
<span class="sd">        Return: new memory if success, 0 if memory cannot be increased.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_increase</span> <span class="o">=</span> <span class="mi">2000</span>
        <span class="n">old_mem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span>
        <span class="n">new_mem</span> <span class="o">=</span> <span class="n">old_mem</span> <span class="o">+</span> <span class="n">factor</span><span class="o">*</span><span class="n">base_increase</span>

        <span class="k">if</span> <span class="n">new_mem</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_mem_per_proc</span><span class="p">(</span><span class="n">new_mem</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_mem</span>

        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;could not increase mem_per_proc further&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">more_master_mem_overhead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem_increase_mb</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to increase the amount of memory overheaded asked for the master node.</span>
<span class="sd">        Return: new master memory overhead if success, 0 if it cannot be increased.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_master_mem_overhead</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">master_mem_overhead</span>
        <span class="n">new_master_mem_overhead</span> <span class="o">=</span> <span class="n">old_master_mem_overhead</span> <span class="o">+</span> <span class="n">mem_increase_mb</span>
        <span class="k">if</span> <span class="n">new_master_mem_overhead</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_master_mem_overhead</span><span class="p">(</span><span class="n">new_master_mem_overhead</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_master_mem_overhead</span>

        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;could not increase master_mem_overhead further&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">more_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to increase the number of MPI procs.</span>
<span class="sd">        Return: new number of processors if success, 0 if processors cannot be increased.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO : find a formula that works for all max_cores</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span> <span class="o">&gt;</span> <span class="mi">40</span><span class="p">:</span>
          <span class="n">base_increase</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span> <span class="o">/</span> <span class="mi">40</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">base_increase</span> <span class="o">=</span> <span class="mi">4</span>

        <span class="n">new_cores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hint_cores</span> <span class="o">+</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">base_increase</span>

        <span class="k">if</span> <span class="n">new_cores</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hint_cores</span> <span class="o">=</span> <span class="n">new_cores</span>
            <span class="k">return</span> <span class="n">new_cores</span>

        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> hint_cores reached limit on max_core </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">new_cores</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">more_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to increase the wall time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_increase</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timelimit_hard</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>

        <span class="n">new_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timelimit</span> <span class="o">+</span> <span class="n">base_increase</span><span class="o">*</span><span class="n">factor</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;qadapter: trying to increase time&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_time</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">timelimit_hard</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_timelimit</span><span class="p">(</span><span class="n">new_time</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;new time set: &#39;</span><span class="p">,</span> <span class="n">new_time</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_time</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;increasing time is not possible, the hard limit has been reached&quot;</span><span class="p">)</span>

<span class="c1">####################</span>
<span class="c1"># Concrete classes #</span>
<span class="c1">####################</span>


<span class="k">class</span> <span class="nc">ShellAdapter</span><span class="p">(</span><span class="n">QueueAdapter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple Adapter used to submit runs through the shell.&quot;&quot;&quot;</span>
    <span class="n">QTYPE</span> <span class="o">=</span> <span class="s2">&quot;shell&quot;</span>

    <span class="n">QTEMPLATE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">#!/bin/bash</span>
<span class="s2">$$</span><span class="si">{qverbatim}</span><span class="s2"></span>
<span class="s2">&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;kill -9 </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">job_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_submit_to_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">script_file</span><span class="p">):</span>
        <span class="c1"># submit the job, return process and pid.</span>
        <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">((</span><span class="s2">&quot;/bin/bash&quot;</span><span class="p">,</span> <span class="n">script_file</span><span class="p">),</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SubmitResults</span><span class="p">(</span><span class="n">qid</span><span class="o">=</span><span class="n">process</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s1">&#39;no out in shell submission&#39;</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="s1">&#39;no err in shell submission&#39;</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="n">process</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_njobs_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">exclude_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">SlurmAdapter</span><span class="p">(</span><span class="n">QueueAdapter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adapter for SLURM.&quot;&quot;&quot;</span>
    <span class="n">QTYPE</span> <span class="o">=</span> <span class="s2">&quot;slurm&quot;</span>

    <span class="n">QTEMPLATE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">#!/bin/bash</span>

<span class="s2">#SBATCH --partition=$$</span><span class="si">{partition}</span><span class="s2"></span>
<span class="s2">#SBATCH --job-name=$$</span><span class="si">{job_name}</span><span class="s2"></span>
<span class="s2">#SBATCH --nodes=$$</span><span class="si">{nodes}</span><span class="s2"></span>
<span class="s2">#SBATCH --total_tasks=$$</span><span class="si">{total_tasks}</span><span class="s2"></span>
<span class="s2">#SBATCH --ntasks=$$</span><span class="si">{ntasks}</span><span class="s2"></span>
<span class="s2">#SBATCH --ntasks-per-node=$$</span><span class="si">{ntasks_per_node}</span><span class="s2"></span>
<span class="s2">#SBATCH --cpus-per-task=$$</span><span class="si">{cpus_per_task}</span><span class="s2"></span>
<span class="s2">#####SBATCH --mem=$$</span><span class="si">{mem}</span><span class="s2"></span>
<span class="s2">#SBATCH --mem-per-cpu=$$</span><span class="si">{mem_per_cpu}</span><span class="s2"></span>
<span class="s2">#SBATCH --hint=$$</span><span class="si">{hint}</span><span class="s2"></span>
<span class="s2">#SBATCH --time=$$</span><span class="si">{time}</span><span class="s2"></span>
<span class="s2">#SBATCH	--exclude=$$</span><span class="si">{exclude_nodes}</span><span class="s2"></span>
<span class="s2">#SBATCH --account=$$</span><span class="si">{account}</span><span class="s2"></span>
<span class="s2">#SBATCH --mail-user=$$</span><span class="si">{mail_user}</span><span class="s2"></span>
<span class="s2">#SBATCH --mail-type=$$</span><span class="si">{mail_type}</span><span class="s2"></span>
<span class="s2">#SBATCH --constraint=$$</span><span class="si">{constraint}</span><span class="s2"></span>
<span class="s2">#SBATCH --gres=$$</span><span class="si">{gres}</span><span class="s2"></span>
<span class="s2">#SBATCH --requeue=$$</span><span class="si">{requeue}</span><span class="s2"></span>
<span class="s2">#SBATCH --nodelist=$$</span><span class="si">{nodelist}</span><span class="s2"></span>
<span class="s2">#SBATCH --propagate=$$</span><span class="si">{propagate}</span><span class="s2"></span>
<span class="s2">#SBATCH --licenses=$$</span><span class="si">{licenses}</span><span class="s2"></span>
<span class="s2">#SBATCH --output=$$</span><span class="si">{_qout_path}</span><span class="s2"></span>
<span class="s2">#SBATCH --error=$$</span><span class="si">{_qerr_path}</span><span class="s2"></span>
<span class="s2">#SBATCH --qos=$$</span><span class="si">{qos}</span><span class="s2"></span>
<span class="s2">$$</span><span class="si">{qverbatim}</span><span class="s2"></span>
<span class="s2">&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_qname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qname</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SlurmAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_qname</span><span class="p">(</span><span class="n">qname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">qname</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;partition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qname</span>

    <span class="k">def</span> <span class="nf">set_mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of CPUs used for MPI.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SlurmAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;ntasks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi_procs</span>

    <span class="k">def</span> <span class="nf">set_omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SlurmAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_omp_threads</span><span class="p">(</span><span class="n">omp_threads</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;cpus_per_task&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">omp_threads</span>

    <span class="k">def</span> <span class="nf">set_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem_mb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the memory per process in megabytes&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SlurmAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_mem_per_proc</span><span class="p">(</span><span class="n">mem_mb</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;mem_per_cpu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span>
        <span class="c1"># Remove mem if it&#39;s defined.</span>
        <span class="c1">#self.qparams.pop(&quot;mem&quot;, None)</span>

    <span class="k">def</span> <span class="nf">set_timelimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timelimit</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SlurmAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_timelimit</span><span class="p">(</span><span class="n">timelimit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qu</span><span class="o">.</span><span class="n">time2slurm</span><span class="p">(</span><span class="n">timelimit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;scancel </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">job_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">optimize_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qnodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocation</span> <span class="o">==</span> <span class="s2">&quot;nodes&quot;</span><span class="p">:</span>
            <span class="c1"># run on the smallest number of nodes compatible with the configuration</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span><span class="p">)),</span>
                                  <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_mem</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">params</span>

        <span class="c1">#dist = self.distribute(self.mpi_procs, self.omp_threads, self.mem_per_proc)</span>
        <span class="c1">##print(dist)</span>

        <span class="c1">#if False and dist.exact:</span>
        <span class="c1">#    # Can optimize parameters</span>
        <span class="c1">#    self.qparams[&quot;nodes&quot;] = dist.num_nodes</span>
        <span class="c1">#    self.qparams.pop(&quot;ntasks&quot;, None)</span>
        <span class="c1">#    self.qparams[&quot;ntasks_per_node&quot;] = dist.mpi_per_node</span>
        <span class="c1">#    self.qparams[&quot;cpus_per_task&quot;] = self.omp_threads</span>
        <span class="c1">#    self.qparams[&quot;mem&quot;] = dist.mpi_per_node * self.mem_per_proc</span>
        <span class="c1">#    self.qparams.pop(&quot;mem_per_cpu&quot;, None)</span>
        <span class="c1">#else:</span>
        <span class="c1">#    # Delegate to slurm.</span>
        <span class="c1">#    self.qparams[&quot;ntasks&quot;] = self.mpi_procs</span>
        <span class="c1">#    self.qparams.pop(&quot;nodes&quot;, None)</span>
        <span class="c1">#    self.qparams.pop(&quot;ntasks_per_node&quot;, None)</span>
        <span class="c1">#    self.qparams[&quot;cpus_per_task&quot;] = self.omp_threads</span>
        <span class="c1">#    self.qparams[&quot;mem_per_cpu&quot;] = self.mem_per_proc</span>
        <span class="c1">#    self.qparams.pop(&quot;mem&quot;, None)</span>
        <span class="c1">#return {}</span>

    <span class="k">def</span> <span class="nf">_submit_to_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">script_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Submit a job script to the queue.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;sbatch&#39;</span><span class="p">,</span> <span class="n">script_file</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need string not bytes so must use universal_newlines</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;sbatch&#39;</span><span class="p">,</span> <span class="n">script_file</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>

        <span class="c1"># grab the returncode. SLURM returns 0 if the job was successful</span>
        <span class="n">queue_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">process</span><span class="o">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># output should of the form &#39;2561553.sdb&#39; or &#39;352353.jessup&#39; - just grab the first part for job id</span>
                <span class="n">queue_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Job submission was successful and queue_id is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">queue_id</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># probably error parsing job code</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s1">&#39;Could not parse job id following slurm...&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SubmitResults</span><span class="p">(</span><span class="n">qid</span><span class="o">=</span><span class="n">queue_id</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="n">process</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exclude_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;exclude_nodes&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;exclude_nodes&#39;</span><span class="p">:</span> <span class="s1">&#39;node&#39;</span> <span class="o">+</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;excluded node </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s1">&#39;exclude_nodes&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;,node&#39;</span> <span class="o">+</span> <span class="n">node</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;excluded node </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">node</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;qadapter failed to exclude nodes&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_njobs_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;squeue&#39;</span><span class="p">,</span> <span class="s1">&#39;-o &quot;</span><span class="si">%u</span><span class="s1">&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;-u&#39;</span><span class="p">,</span> <span class="n">username</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need string not bytes so must use universal_newlines</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;squeue&#39;</span><span class="p">,</span> <span class="s1">&#39;-o &quot;</span><span class="si">%u</span><span class="s1">&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;-u&#39;</span><span class="p">,</span> <span class="n">username</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span>
                            <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
        <span class="n">njobs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">process</span><span class="o">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># parse the result. lines should have this form:</span>
            <span class="c1"># username</span>
            <span class="c1"># count lines that include the username in it</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
            <span class="n">njobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">outs</span> <span class="k">if</span> <span class="n">username</span> <span class="ow">in</span> <span class="n">line</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">njobs</span><span class="p">,</span> <span class="n">process</span>


<span class="k">class</span> <span class="nc">PbsProAdapter</span><span class="p">(</span><span class="n">QueueAdapter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adapter for PbsPro&quot;&quot;&quot;</span>
    <span class="n">QTYPE</span> <span class="o">=</span> <span class="s2">&quot;pbspro&quot;</span>

<span class="c1">#PBS -l select=$${select}:ncpus=$${ncpus}:mem=$${mem}mb:mpiprocs=$${mpiprocs}:ompthreads=$${ompthreads}</span>
<span class="c1">#PBS -l select=$${select}:ncpus=1:mem=$${mem}mb:mpiprocs=1:ompthreads=$${ompthreads}</span>

    <span class="n">QTEMPLATE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">#!/bin/bash</span>

<span class="s2">#PBS -q $$</span><span class="si">{queue}</span><span class="s2"></span>
<span class="s2">#PBS -N $$</span><span class="si">{job_name}</span><span class="s2"></span>
<span class="s2">#PBS -A $$</span><span class="si">{account}</span><span class="s2"></span>
<span class="s2">#PBS -l select=$$</span><span class="si">{select}</span><span class="s2"></span>
<span class="s2">#PBS -l walltime=$$</span><span class="si">{walltime}</span><span class="s2"></span>
<span class="s2">#PBS -l model=$$</span><span class="si">{model}</span><span class="s2"></span>
<span class="s2">#PBS -l place=$$</span><span class="si">{place}</span><span class="s2"></span>
<span class="s2">#PBS -W group_list=$$</span><span class="si">{group_list}</span><span class="s2"></span>
<span class="s2">#PBS -M $$</span><span class="si">{mail_user}</span><span class="s2"></span>
<span class="s2">#PBS -m $$</span><span class="si">{mail_type}</span><span class="s2"></span>
<span class="s2">#PBS -o $$</span><span class="si">{_qout_path}</span><span class="s2"></span>
<span class="s2">#PBS -e $$</span><span class="si">{_qerr_path}</span><span class="s2"></span>
<span class="s2">$$</span><span class="si">{qverbatim}</span><span class="s2"></span>
<span class="s2">&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_qname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qname</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PbsProAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_qname</span><span class="p">(</span><span class="n">qname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">qname</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;queue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qname</span>

    <span class="k">def</span> <span class="nf">set_timelimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timelimit</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PbsProAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_timelimit</span><span class="p">(</span><span class="n">timelimit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;walltime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qu</span><span class="o">.</span><span class="n">time2pbspro</span><span class="p">(</span><span class="n">timelimit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem_mb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the memory per process in megabytes&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PbsProAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_mem_per_proc</span><span class="p">(</span><span class="n">mem_mb</span><span class="p">)</span>
        <span class="c1">#self.qparams[&quot;mem&quot;] = self.mem_per_proc</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;qdel </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">job_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">optimize_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qnodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;select&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_select</span><span class="p">(</span><span class="n">qnodes</span><span class="o">=</span><span class="n">qnodes</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">get_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ret_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">qnodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">memory_policy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select is not the most intuitive command. For more info see:</span>

<span class="sd">            * http://www.cardiff.ac.uk/arcca/services/equipment/User-Guide/pbs.html</span>
<span class="sd">            * https://portal.ivec.org/docs/Supercomputers/PBS_Pro</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hw</span><span class="p">,</span> <span class="n">mem_per_proc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">)</span>
        <span class="c1">#dist = self.distribute(self.mpi_procs, self.omp_threads, mem_per_proc)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        if self.pure_mpi:</span>
<span class="sd">            num_nodes, rest_cores = hw.divmod_node(self.mpi_procs, self.omp_threads)</span>

<span class="sd">            if num_nodes == 0:</span>
<span class="sd">                logger.info(&quot;IN_CORE PURE MPI: %s&quot; % self.run_info)</span>
<span class="sd">                chunks = 1</span>
<span class="sd">                ncpus = rest_cores</span>
<span class="sd">                mpiprocs = rest_cores</span>
<span class="sd">                mem = mem_per_proc * ncpus</span>
<span class="sd">                ompthreads = 1</span>

<span class="sd">            elif rest_cores == 0:</span>
<span class="sd">                # Can allocate entire nodes because self.mpi_procs is divisible by cores_per_node.</span>
<span class="sd">                logger.info(&quot;PURE MPI run commensurate with cores_per_node %s&quot; % self.run_info)</span>
<span class="sd">                chunks = num_nodes</span>
<span class="sd">                ncpus = hw.cores_per_node</span>
<span class="sd">                mpiprocs = hw.cores_per_node</span>
<span class="sd">                mem = ncpus * mem_per_proc</span>
<span class="sd">                ompthreads = 1</span>

<span class="sd">            else:</span>
<span class="sd">                logger.info(&quot;OUT-OF-CORE PURE MPI (not commensurate with cores_per_node): %s&quot; % self.run_info)</span>
<span class="sd">                chunks = self.mpi_procs</span>
<span class="sd">                ncpus = 1</span>
<span class="sd">                mpiprocs = 1</span>
<span class="sd">                mem = mem_per_proc</span>
<span class="sd">                ompthreads = 1</span>

<span class="sd">        elif self.pure_omp:</span>
<span class="sd">            # Pure OMP run.</span>
<span class="sd">            logger.info(&quot;PURE OPENMP run: %s&quot; % self.run_info)</span>
<span class="sd">            assert hw.can_use_omp_threads(self.omp_threads)</span>
<span class="sd">            chunks = 1</span>
<span class="sd">            ncpus = self.omp_threads</span>
<span class="sd">            mpiprocs = 1</span>
<span class="sd">            mem = mem_per_proc</span>
<span class="sd">            ompthreads = self.omp_threads</span>

<span class="sd">        elif self.hybrid_mpi_omp:</span>
<span class="sd">            assert hw.can_use_omp_threads(self.omp_threads)</span>
<span class="sd">            num_nodes, rest_cores = hw.divmod_node(self.mpi_procs, self.omp_threads)</span>
<span class="sd">            #print(num_nodes, rest_cores)</span>
<span class="sd">            # TODO: test this</span>

<span class="sd">            if rest_cores == 0 or num_nodes == 0:</span>
<span class="sd">                logger.info(&quot;HYBRID MPI-OPENMP run, perfectly divisible among nodes: %s&quot; % self.run_info)</span>
<span class="sd">                chunks = max(num_nodes, 1)</span>
<span class="sd">                mpiprocs = self.mpi_procs // chunks</span>

<span class="sd">                chunks = chunks</span>
<span class="sd">                ncpus = mpiprocs * self.omp_threads</span>
<span class="sd">                mpiprocs = mpiprocs</span>
<span class="sd">                mem = mpiprocs * mem_per_proc</span>
<span class="sd">                ompthreads = self.omp_threads</span>

<span class="sd">            else:</span>
<span class="sd">                logger.info(&quot;HYBRID MPI-OPENMP, NOT commensurate with nodes: %s&quot; % self.run_info)</span>
<span class="sd">                chunks=self.mpi_procs</span>
<span class="sd">                ncpus=self.omp_threads</span>
<span class="sd">                mpiprocs=1</span>
<span class="sd">                mem= mem_per_proc</span>
<span class="sd">                ompthreads=self.omp_threads</span>

<span class="sd">        else:</span>
<span class="sd">            raise RuntimeError(&quot;You should not be here&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">memory_policy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memory_policy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory_policy</span>
        <span class="k">if</span> <span class="n">qnodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qnodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qnodes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">qnodes</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;standard&quot;</span><span class="p">,</span> <span class="s2">&quot;shared&quot;</span><span class="p">,</span> <span class="s2">&quot;exclusive&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nodes must be either in standard, shared or exclusive mode &quot;</span>
                                 <span class="s2">&quot;while qnodes parameter was </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qnodes</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">qnodes</span> <span class="o">==</span> <span class="s2">&quot;standard&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_select_standard</span><span class="p">(</span><span class="n">ret_dict</span><span class="o">=</span><span class="n">ret_dict</span><span class="p">,</span> <span class="n">memory_policy</span><span class="o">=</span><span class="n">memory_policy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_select_with_master_mem_overhead</span><span class="p">(</span><span class="n">ret_dict</span><span class="o">=</span><span class="n">ret_dict</span><span class="p">,</span> <span class="n">qnodes</span><span class="o">=</span><span class="n">qnodes</span><span class="p">,</span>
                                                             <span class="n">memory_policy</span><span class="o">=</span><span class="n">memory_policy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_select_with_master_mem_overhead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ret_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">qnodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">memory_policy</span><span class="o">=</span><span class="s1">&#39;mem&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;select with master mem overhead not yet implemented with has_omp&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">qnodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qnodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qnodes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">qnodes</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;standard&quot;</span><span class="p">,</span> <span class="s2">&quot;shared&quot;</span><span class="p">,</span> <span class="s2">&quot;exclusive&quot;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Nodes must be either in standard, shared or exclusive mode &quot;</span>
                                 <span class="s2">&quot;while qnodes parameter was </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qnodes</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">qnodes</span> <span class="o">==</span> <span class="s2">&quot;exclusive&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_select_with_master_mem_overhead_exclusive</span><span class="p">(</span><span class="n">ret_dict</span><span class="o">=</span><span class="n">ret_dict</span><span class="p">,</span> <span class="n">memory_policy</span><span class="o">=</span><span class="n">memory_policy</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">qnodes</span> <span class="o">==</span> <span class="s2">&quot;shared&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_select_with_master_mem_overhead_shared</span><span class="p">(</span><span class="n">ret_dict</span><span class="o">=</span><span class="n">ret_dict</span><span class="p">,</span> <span class="n">memory_policy</span><span class="o">=</span><span class="n">memory_policy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong value of qnodes parameter : </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qnodes</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_select_with_master_mem_overhead_shared</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ret_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">memory_policy</span><span class="o">=</span><span class="s1">&#39;mem&#39;</span><span class="p">):</span>
        <span class="n">chunk_master</span><span class="p">,</span> <span class="n">ncpus_master</span><span class="p">,</span> <span class="n">vmem_master</span><span class="p">,</span> <span class="n">mpiprocs_master</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">master_mem_overhead</span><span class="p">,</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">chunks_slaves</span><span class="p">,</span> <span class="n">ncpus_slaves</span><span class="p">,</span> <span class="n">vmem_slaves</span><span class="p">,</span> <span class="n">mpiprocs_slaves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">,</span> <span class="mi">1</span>
            <span class="n">select_params</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">chunk_master</span><span class="o">=</span><span class="n">chunk_master</span><span class="p">,</span> <span class="n">ncpus_master</span><span class="o">=</span><span class="n">ncpus_master</span><span class="p">,</span>
                                     <span class="n">mpiprocs_master</span><span class="o">=</span><span class="n">mpiprocs_master</span><span class="p">,</span> <span class="n">vmem_master</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">vmem_master</span><span class="p">),</span>
                                     <span class="n">chunks_slaves</span><span class="o">=</span><span class="n">chunks_slaves</span><span class="p">,</span> <span class="n">ncpus_slaves</span><span class="o">=</span><span class="n">ncpus_slaves</span><span class="p">,</span>
                                     <span class="n">mpiprocs_slaves</span><span class="o">=</span><span class="n">mpiprocs_slaves</span><span class="p">,</span> <span class="n">vmem_slaves</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">vmem_slaves</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;vmem&#39;</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunk_master}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_master}</span><span class="s2">:vmem=</span><span class="si">{vmem_master}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs_master}</span><span class="s2">+&quot;</span> \
                    <span class="s2">&quot;</span><span class="si">{chunks_slaves}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_slaves}</span><span class="s2">:vmem=</span><span class="si">{vmem_slaves}</span><span class="s2">mb:&quot;</span> \
                    <span class="s2">&quot;mpiprocs=</span><span class="si">{mpiprocs_slaves}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;mem&#39;</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunk_master}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_master}</span><span class="s2">:mem=</span><span class="si">{vmem_master}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs_master}</span><span class="s2">+&quot;</span> \
                    <span class="s2">&quot;</span><span class="si">{chunks_slaves}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_slaves}</span><span class="s2">:mem=</span><span class="si">{vmem_slaves}</span><span class="s2">mb:&quot;</span> \
                    <span class="s2">&quot;mpiprocs=</span><span class="si">{mpiprocs_slaves}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
            <span class="n">tot_ncpus</span> <span class="o">=</span> <span class="n">chunk_master</span><span class="o">*</span><span class="n">ncpus_master</span> <span class="o">+</span> <span class="n">chunks_slaves</span><span class="o">*</span><span class="n">ncpus_slaves</span>
            <span class="k">if</span> <span class="n">tot_ncpus</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Total number of cpus is different from mpi_procs ...&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">select_params</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">chunk_master</span><span class="o">=</span><span class="n">chunk_master</span><span class="p">,</span> <span class="n">ncpus_master</span><span class="o">=</span><span class="n">ncpus_master</span><span class="p">,</span>
                                     <span class="n">mpiprocs_master</span><span class="o">=</span><span class="n">mpiprocs_master</span><span class="p">,</span> <span class="n">vmem_master</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">vmem_master</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;vmem&#39;</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunk_master}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_master}</span><span class="s2">:vmem=</span><span class="si">{vmem_master}</span><span class="s2">mb:&quot;</span> \
                    <span class="s2">&quot;mpiprocs=</span><span class="si">{mpiprocs_master}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;mem&#39;</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunk_master}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_master}</span><span class="s2">:mem=</span><span class="si">{vmem_master}</span><span class="s2">mb:&quot;</span> \
                    <span class="s2">&quot;mpiprocs=</span><span class="si">{mpiprocs_master}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">select_params</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">_get_select_with_master_mem_overhead_exclusive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ret_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">memory_policy</span><span class="o">=</span><span class="s1">&#39;mem&#39;</span><span class="p">):</span>
        <span class="n">max_ncpus_master</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span><span class="p">,</span>
                               <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">master_mem_overhead</span><span class="p">)</span>
                                   <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_ncpus_master</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">:</span>
            <span class="n">chunk</span><span class="p">,</span> <span class="n">ncpus</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">mpiprocs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span>
            <span class="k">if</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;vmem&#39;</span><span class="p">:</span>
                <span class="n">select_params</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">chunks</span><span class="o">=</span><span class="n">chunk</span><span class="p">,</span> <span class="n">ncpus</span><span class="o">=</span><span class="n">ncpus</span><span class="p">,</span> <span class="n">mpiprocs</span><span class="o">=</span><span class="n">mpiprocs</span><span class="p">,</span> <span class="n">vmem</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunks}</span><span class="s2">:ncpus=</span><span class="si">{ncpus}</span><span class="s2">:vmem=</span><span class="si">{vmem}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;mem&#39;</span><span class="p">:</span>
                <span class="n">select_params</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">chunks</span><span class="o">=</span><span class="n">chunk</span><span class="p">,</span> <span class="n">ncpus</span><span class="o">=</span><span class="n">ncpus</span><span class="p">,</span> <span class="n">mpiprocs</span><span class="o">=</span><span class="n">mpiprocs</span><span class="p">,</span> <span class="n">mem</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunks}</span><span class="s2">:ncpus=</span><span class="si">{ncpus}</span><span class="s2">:mem=</span><span class="si">{mem}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
            <span class="n">tot_ncpus</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">*</span><span class="n">ncpus</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ncpus_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="o">-</span><span class="n">max_ncpus_master</span>
            <span class="n">max_ncpus_per_slave_node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">))</span>
            <span class="n">nslaves_float</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ncpus_left</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">max_ncpus_per_slave_node</span><span class="p">)</span>
            <span class="n">ncpus_per_slave</span> <span class="o">=</span> <span class="n">max_ncpus_per_slave_node</span>
            <span class="n">mpiprocs_slaves</span> <span class="o">=</span> <span class="n">max_ncpus_per_slave_node</span>
            <span class="n">chunk_master</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">mem_slaves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span>
            <span class="n">explicit_last_slave</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">chunk_last_slave</span><span class="p">,</span> <span class="n">ncpus_last_slave</span><span class="p">,</span> <span class="n">mem_last_slave</span><span class="p">,</span> <span class="n">mpiprocs_last_slave</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">nslaves_float</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">nslaves_float</span><span class="p">):</span>
                <span class="n">chunks_slaves</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nslaves_float</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">pot_ncpus_all_slaves</span> <span class="o">=</span> <span class="n">chunks_slaves</span><span class="o">*</span><span class="n">ncpus_per_slave</span>
                <span class="k">if</span> <span class="n">pot_ncpus_all_slaves</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">explicit_last_slave</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">chunks_slaves</span> <span class="o">=</span> <span class="n">chunks_slaves</span><span class="o">-</span><span class="mi">1</span>
                    <span class="n">chunk_last_slave</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">ncpus_master</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">ncpus_last_slave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">chunks_slaves</span><span class="o">*</span><span class="n">ncpus_per_slave</span>
                    <span class="n">mem_last_slave</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span>
                    <span class="n">mpiprocs_last_slave</span> <span class="o">=</span> <span class="n">ncpus_last_slave</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ncpus_master</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="o">-</span><span class="n">pot_ncpus_all_slaves</span>
                <span class="k">if</span> <span class="n">ncpus_master</span> <span class="o">&gt;</span> <span class="n">max_ncpus_master</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ncpus for the master node exceeds the maximum ncpus for the master ... this&#39;</span>
                                     <span class="s1">&#39;should not happen ...&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ncpus_master</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ncpus for the master node is 0 ... this should not happen ...&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nslaves_float</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">nslaves_float</span><span class="p">):</span>
                <span class="n">chunks_slaves</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nslaves_float</span><span class="p">)</span>
                <span class="n">ncpus_master</span> <span class="o">=</span> <span class="n">max_ncpus_master</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;nslaves_float &lt; int(nslaves_float) ...&#39;</span><span class="p">)</span>
            <span class="n">mem_master</span><span class="p">,</span> <span class="n">mpiprocs_master</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">mem_per_node</span><span class="p">,</span> <span class="n">ncpus_master</span>
            <span class="k">if</span> <span class="n">explicit_last_slave</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;vmem&#39;</span><span class="p">:</span>
                    <span class="n">select_params</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">chunk_master</span><span class="o">=</span><span class="n">chunk_master</span><span class="p">,</span> <span class="n">ncpus_master</span><span class="o">=</span><span class="n">ncpus_master</span><span class="p">,</span>
                                             <span class="n">mpiprocs_master</span><span class="o">=</span><span class="n">mpiprocs_master</span><span class="p">,</span> <span class="n">vmem_master</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem_master</span><span class="p">),</span>
                                             <span class="n">chunks_slaves</span><span class="o">=</span><span class="n">chunks_slaves</span><span class="p">,</span> <span class="n">ncpus_per_slave</span><span class="o">=</span><span class="n">ncpus_per_slave</span><span class="p">,</span>
                                             <span class="n">mpiprocs_slaves</span><span class="o">=</span><span class="n">mpiprocs_slaves</span><span class="p">,</span> <span class="n">vmem_slaves</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem_slaves</span><span class="p">),</span>
                                             <span class="n">chunk_last_slave</span><span class="o">=</span><span class="n">chunk_last_slave</span><span class="p">,</span> <span class="n">ncpus_last_slave</span><span class="o">=</span><span class="n">ncpus_last_slave</span><span class="p">,</span>
                                             <span class="n">vmem_last_slave</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem_last_slave</span><span class="p">),</span>
                                             <span class="n">mpiprocs_last_slave</span><span class="o">=</span><span class="n">mpiprocs_last_slave</span><span class="p">)</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunk_master}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_master}</span><span class="s2">:vmem=</span><span class="si">{vmem_master}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs_master}</span><span class="s2">+&quot;</span> \
                        <span class="s2">&quot;</span><span class="si">{chunks_slaves}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_per_slave}</span><span class="s2">:vmem=</span><span class="si">{vmem_slaves}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs_slaves}</span><span class="s2">+&quot;</span> \
                        <span class="s2">&quot;</span><span class="si">{chunk_last_slave}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_last_slave}</span><span class="s2">:vmem=</span><span class="si">{vmem_last_slave}</span><span class="s2">mb:&quot;</span> \
                        <span class="s2">&quot;mpiprocs=</span><span class="si">{mpiprocs_last_slave}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;mem&#39;</span><span class="p">:</span>
                    <span class="n">select_params</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">chunk_master</span><span class="o">=</span><span class="n">chunk_master</span><span class="p">,</span> <span class="n">ncpus_master</span><span class="o">=</span><span class="n">ncpus_master</span><span class="p">,</span>
                                             <span class="n">mpiprocs_master</span><span class="o">=</span><span class="n">mpiprocs_master</span><span class="p">,</span> <span class="n">mem_master</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem_master</span><span class="p">),</span>
                                             <span class="n">chunks_slaves</span><span class="o">=</span><span class="n">chunks_slaves</span><span class="p">,</span> <span class="n">ncpus_per_slave</span><span class="o">=</span><span class="n">ncpus_per_slave</span><span class="p">,</span>
                                             <span class="n">mpiprocs_slaves</span><span class="o">=</span><span class="n">mpiprocs_slaves</span><span class="p">,</span> <span class="n">mem_slaves</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem_slaves</span><span class="p">),</span>
                                             <span class="n">chunk_last_slave</span><span class="o">=</span><span class="n">chunk_last_slave</span><span class="p">,</span> <span class="n">ncpus_last_slave</span><span class="o">=</span><span class="n">ncpus_last_slave</span><span class="p">,</span>
                                             <span class="n">mem_last_slave</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem_last_slave</span><span class="p">),</span>
                                             <span class="n">mpiprocs_last_slave</span><span class="o">=</span><span class="n">mpiprocs_last_slave</span><span class="p">)</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunk_master}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_master}</span><span class="s2">:mem=</span><span class="si">{mem_master}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs_master}</span><span class="s2">+&quot;</span> \
                        <span class="s2">&quot;</span><span class="si">{chunks_slaves}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_per_slave}</span><span class="s2">:mem=</span><span class="si">{mem_slaves}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs_slaves}</span><span class="s2">+&quot;</span> \
                        <span class="s2">&quot;</span><span class="si">{chunk_last_slave}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_last_slave}</span><span class="s2">:mem=</span><span class="si">{mem_last_slave}</span><span class="s2">mb:&quot;</span> \
                        <span class="s2">&quot;mpiprocs=</span><span class="si">{mpiprocs_last_slave}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
                <span class="n">tot_ncpus</span> <span class="o">=</span> <span class="n">chunk_master</span><span class="o">*</span><span class="n">ncpus_master</span><span class="o">+</span><span class="n">chunks_slaves</span><span class="o">*</span><span class="n">ncpus_per_slave</span><span class="o">+</span><span class="n">chunk_last_slave</span><span class="o">*</span><span class="n">ncpus_last_slave</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;vmem&#39;</span><span class="p">:</span>
                    <span class="n">select_params</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">chunk_master</span><span class="o">=</span><span class="n">chunk_master</span><span class="p">,</span> <span class="n">ncpus_master</span><span class="o">=</span><span class="n">ncpus_master</span><span class="p">,</span>
                                             <span class="n">mpiprocs_master</span><span class="o">=</span><span class="n">mpiprocs_master</span><span class="p">,</span> <span class="n">vmem_master</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem_master</span><span class="p">),</span>
                                             <span class="n">chunks_slaves</span><span class="o">=</span><span class="n">chunks_slaves</span><span class="p">,</span> <span class="n">ncpus_per_slave</span><span class="o">=</span><span class="n">ncpus_per_slave</span><span class="p">,</span>
                                             <span class="n">mpiprocs_slaves</span><span class="o">=</span><span class="n">mpiprocs_slaves</span><span class="p">,</span> <span class="n">vmem_slaves</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem_slaves</span><span class="p">))</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunk_master}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_master}</span><span class="s2">:vmem=</span><span class="si">{vmem_master}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs_master}</span><span class="s2">+&quot;</span> \
                        <span class="s2">&quot;</span><span class="si">{chunks_slaves}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_per_slave}</span><span class="s2">:vmem=</span><span class="si">{vmem_slaves}</span><span class="s2">mb:&quot;</span> \
                        <span class="s2">&quot;mpiprocs=</span><span class="si">{mpiprocs_slaves}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;mem&#39;</span><span class="p">:</span>
                    <span class="n">select_params</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">chunk_master</span><span class="o">=</span><span class="n">chunk_master</span><span class="p">,</span> <span class="n">ncpus_master</span><span class="o">=</span><span class="n">ncpus_master</span><span class="p">,</span>
                                             <span class="n">mpiprocs_master</span><span class="o">=</span><span class="n">mpiprocs_master</span><span class="p">,</span> <span class="n">mem_master</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem_master</span><span class="p">),</span>
                                             <span class="n">chunks_slaves</span><span class="o">=</span><span class="n">chunks_slaves</span><span class="p">,</span> <span class="n">ncpus_per_slave</span><span class="o">=</span><span class="n">ncpus_per_slave</span><span class="p">,</span>
                                             <span class="n">mpiprocs_slaves</span><span class="o">=</span><span class="n">mpiprocs_slaves</span><span class="p">,</span> <span class="n">mem_slaves</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem_slaves</span><span class="p">))</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunk_master}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_master}</span><span class="s2">:mem=</span><span class="si">{mem_master}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs_master}</span><span class="s2">+&quot;</span> \
                        <span class="s2">&quot;</span><span class="si">{chunks_slaves}</span><span class="s2">:ncpus=</span><span class="si">{ncpus_per_slave}</span><span class="s2">:mem=</span><span class="si">{mem_slaves}</span><span class="s2">mb:&quot;</span> \
                        <span class="s2">&quot;mpiprocs=</span><span class="si">{mpiprocs_slaves}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
                <span class="n">tot_ncpus</span> <span class="o">=</span> <span class="n">chunk_master</span><span class="o">*</span><span class="n">ncpus_master</span> <span class="o">+</span> <span class="n">chunks_slaves</span><span class="o">*</span><span class="n">ncpus_per_slave</span>

        <span class="k">if</span> <span class="n">tot_ncpus</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Total number of cpus is different from mpi_procs ...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">select_params</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">_get_select_standard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ret_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">memory_policy</span><span class="o">=</span><span class="s1">&#39;mem&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span><span class="p">:</span>
            <span class="n">chunks</span><span class="p">,</span> <span class="n">ncpus</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">mpiprocs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">,</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;vmem&#39;</span><span class="p">:</span>
                <span class="n">select_params</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span> <span class="n">ncpus</span><span class="o">=</span><span class="n">ncpus</span><span class="p">,</span> <span class="n">mpiprocs</span><span class="o">=</span><span class="n">mpiprocs</span><span class="p">,</span> <span class="n">vmem</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunks}</span><span class="s2">:ncpus=</span><span class="si">{ncpus}</span><span class="s2">:vmem=</span><span class="si">{vmem}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;mem&#39;</span><span class="p">:</span>
                <span class="n">select_params</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span> <span class="n">ncpus</span><span class="o">=</span><span class="n">ncpus</span><span class="p">,</span> <span class="n">mpiprocs</span><span class="o">=</span><span class="n">mpiprocs</span><span class="p">,</span> <span class="n">mem</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunks}</span><span class="s2">:ncpus=</span><span class="si">{ncpus}</span><span class="s2">:mem=</span><span class="si">{mem}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chunks</span><span class="p">,</span> <span class="n">ncpus</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">mpiprocs</span><span class="p">,</span> <span class="n">ompthreads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span>
            <span class="k">if</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;vmem&#39;</span><span class="p">:</span>
                <span class="n">select_params</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span> <span class="n">ncpus</span><span class="o">=</span><span class="n">ncpus</span><span class="p">,</span> <span class="n">mpiprocs</span><span class="o">=</span><span class="n">mpiprocs</span><span class="p">,</span> <span class="n">vmem</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem</span><span class="p">),</span>
                                         <span class="n">ompthreads</span><span class="o">=</span><span class="n">ompthreads</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunks}</span><span class="s2">:ncpus=</span><span class="si">{ncpus}</span><span class="s2">:vmem=</span><span class="si">{vmem}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs}</span><span class="s2">:ompthreads=</span><span class="si">{ompthreads}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">select_params</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">memory_policy</span> <span class="o">==</span> <span class="s1">&#39;mem&#39;</span><span class="p">:</span>
                <span class="n">select_params</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span> <span class="n">ncpus</span><span class="o">=</span><span class="n">ncpus</span><span class="p">,</span> <span class="n">mpiprocs</span><span class="o">=</span><span class="n">mpiprocs</span><span class="p">,</span> <span class="n">mem</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mem</span><span class="p">),</span>
                                         <span class="n">ompthreads</span><span class="o">=</span><span class="n">ompthreads</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{chunks}</span><span class="s2">:ncpus=</span><span class="si">{ncpus}</span><span class="s2">:mem=</span><span class="si">{mem}</span><span class="s2">mb:mpiprocs=</span><span class="si">{mpiprocs}</span><span class="s2">:ompthreads=</span><span class="si">{ompthreads}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="o">**</span><span class="n">select_params</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ret_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">select_params</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">_submit_to_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">script_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Submit a job script to the queue.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;qsub&#39;</span><span class="p">,</span> <span class="n">script_file</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need string not bytes so must use universal_newlines</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;qsub&#39;</span><span class="p">,</span> <span class="n">script_file</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
        <span class="c1"># grab the return code. PBS returns 0 if the job was successful</span>
        <span class="n">queue_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">process</span><span class="o">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># output should of the form &#39;2561553.sdb&#39; or &#39;352353.jessup&#39; - just grab the first part for job id</span>
                <span class="n">queue_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># probably error parsing job code</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Could not parse job id following qsub...&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SubmitResults</span><span class="p">(</span><span class="n">qid</span><span class="o">=</span><span class="n">queue_id</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="n">process</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_njobs_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;qstat&#39;</span><span class="p">,</span> <span class="s1">&#39;-a&#39;</span><span class="p">,</span> <span class="s1">&#39;-u&#39;</span><span class="p">,</span> <span class="n">username</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need string not bytes so must use universal_newlines</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;qstat&#39;</span><span class="p">,</span> <span class="s1">&#39;-a&#39;</span><span class="p">,</span> <span class="s1">&#39;-u&#39;</span><span class="p">,</span> <span class="n">username</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
        <span class="n">njobs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">process</span><span class="o">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># parse the result</span>
            <span class="c1"># lines should have this form</span>
            <span class="c1"># &#39;1339044.sdb          username  queuename    2012-02-29-16-43  20460   --   --    --  00:20 C 00:09&#39;</span>
            <span class="c1"># count lines that include the username in it</span>

            <span class="c1"># TODO: only count running or queued jobs. or rather, *don&#39;t* count jobs that are &#39;C&#39;.</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">njobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">outs</span> <span class="k">if</span> <span class="n">username</span> <span class="ow">in</span> <span class="n">line</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">njobs</span><span class="p">,</span> <span class="n">process</span>

    <span class="k">def</span> <span class="nf">exclude_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">TorqueAdapter</span><span class="p">(</span><span class="n">PbsProAdapter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adapter for Torque.&quot;&quot;&quot;</span>
    <span class="n">QTYPE</span> <span class="o">=</span> <span class="s2">&quot;torque&quot;</span>

    <span class="n">QTEMPLATE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">#!/bin/bash</span>

<span class="s2">#PBS -q $$</span><span class="si">{queue}</span><span class="s2"></span>
<span class="s2">#PBS -N $$</span><span class="si">{job_name}</span><span class="s2"></span>
<span class="s2">#PBS -A $$</span><span class="si">{account}</span><span class="s2"></span>
<span class="s2">####PBS -l mppwidth=$$</span><span class="si">{mppwidth}</span><span class="s2"></span>
<span class="s2">#PBS -l nodes=$$</span><span class="si">{nodes}</span><span class="s2">:ppn=$$</span><span class="si">{ppn}</span><span class="s2"></span>
<span class="s2">#PBS -l walltime=$$</span><span class="si">{walltime}</span><span class="s2"></span>
<span class="s2">#PBS -l model=$$</span><span class="si">{model}</span><span class="s2"></span>
<span class="s2">#PBS -l place=$$</span><span class="si">{place}</span><span class="s2"></span>
<span class="s2">#PBS -W group_list=$$</span><span class="si">{group_list}</span><span class="s2"></span>
<span class="s2">#PBS -M $$</span><span class="si">{mail_user}</span><span class="s2"></span>
<span class="s2">#PBS -m $$</span><span class="si">{mail_type}</span><span class="s2"></span>
<span class="s2"># Submission environment</span>
<span class="s2">#PBS -V</span>
<span class="s2">#PBS -o $$</span><span class="si">{_qout_path}</span><span class="s2"></span>
<span class="s2">#PBS -e $$</span><span class="si">{_qerr_path}</span><span class="s2"></span>
<span class="s2">$$</span><span class="si">{qverbatim}</span><span class="s2"></span>
<span class="s2">&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem_mb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the memory per process in megabytes&quot;&quot;&quot;</span>
        <span class="n">QueueAdapter</span><span class="o">.</span><span class="n">set_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem_mb</span><span class="p">)</span>
        <span class="c1">#self.qparams[&quot;mem&quot;] = self.mem_per_proc</span>

    <span class="k">def</span> <span class="nf">set_mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of CPUs used for MPI.&quot;&quot;&quot;</span>
        <span class="n">QueueAdapter</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">)</span>

        <span class="n">num_nodes</span><span class="p">,</span> <span class="n">rest_cores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">divmod_node</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="n">omp_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_nodes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;ppn&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi_procs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rest_cores</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Pack cores as much as possible.</span>
                <span class="n">num_nodes</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_nodes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;ppn&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span>

    <span class="k">def</span> <span class="nf">exclude_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;qadapter failed to exclude nodes, not implemented yet in torque&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SGEAdapter</span><span class="p">(</span><span class="n">QueueAdapter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adapter for Sun Grid Engine (SGE) task submission software.</span>

<span class="sd">    See also:</span>

<span class="sd">        * https://www.wiki.ed.ac.uk/display/EaStCHEMresearchwiki/How+to+write+a+SGE+job+submission+script</span>
<span class="sd">        * http://www.uibk.ac.at/zid/systeme/hpc-systeme/common/tutorials/sge-howto.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">QTYPE</span> <span class="o">=</span> <span class="s2">&quot;sge&quot;</span>

    <span class="n">QTEMPLATE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">#!/bin/bash</span>

<span class="s2">#$ -account_name $$</span><span class="si">{account_name}</span><span class="s2"></span>
<span class="s2">#$ -N $$</span><span class="si">{job_name}</span><span class="s2"></span>
<span class="s2">#$ -q $$</span><span class="si">{queue_name}</span><span class="s2"></span>
<span class="s2">#$ -pe $$</span><span class="si">{parallel_environment}</span><span class="s2"> $$</span><span class="si">{ncpus}</span><span class="s2"></span>
<span class="s2">#$ -l h_rt=$$</span><span class="si">{walltime}</span><span class="s2"></span>
<span class="s2"># request a per slot memory limit of size bytes.</span>
<span class="s2">##$ -l h_vmem=$$</span><span class="si">{mem_per_slot}</span><span class="s2"></span>
<span class="s2">##$ -l mf=$$</span><span class="si">{mem_per_slot}</span><span class="s2"></span>
<span class="s2">###$ -j no</span>
<span class="s2">#$ -M $$</span><span class="si">{mail_user}</span><span class="s2"></span>
<span class="s2">#$ -m $$</span><span class="si">{mail_type}</span><span class="s2"></span>
<span class="s2"># Submission environment</span>
<span class="s2">##$ -S /bin/bash</span>
<span class="s2">###$ -cwd                       # Change to current working directory</span>
<span class="s2">###$ -V                         # Export environment variables into script</span>
<span class="s2">#$ -e $$</span><span class="si">{_qerr_path}</span><span class="s2"></span>
<span class="s2">#$ -o $$</span><span class="si">{_qout_path}</span><span class="s2"></span>
<span class="s2">$$</span><span class="si">{qverbatim}</span><span class="s2"></span>
<span class="s2">&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">set_qname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qname</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SGEAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_qname</span><span class="p">(</span><span class="n">qname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">qname</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;queue_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qname</span>

    <span class="k">def</span> <span class="nf">set_mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of CPUs used for MPI.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SGEAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;ncpus&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi_procs</span>

    <span class="k">def</span> <span class="nf">set_omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SGEAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_omp_threads</span><span class="p">(</span><span class="n">omp_threads</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot use omp_threads with SGE&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem_mb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the memory per process in megabytes&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SGEAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_mem_per_proc</span><span class="p">(</span><span class="n">mem_mb</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;mem_per_slot&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;M&quot;</span>

    <span class="k">def</span> <span class="nf">set_timelimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timelimit</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SGEAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_timelimit</span><span class="p">(</span><span class="n">timelimit</span><span class="p">)</span>
        <span class="c1"># Same convention as pbspro e.g. [hours:minutes:]seconds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;walltime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qu</span><span class="o">.</span><span class="n">time2pbspro</span><span class="p">(</span><span class="n">timelimit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;qdel </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">job_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_submit_to_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">script_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Submit a job script to the queue.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;qsub&#39;</span><span class="p">,</span> <span class="n">script_file</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need string not bytes so must use universal_newlines</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;qsub&#39;</span><span class="p">,</span> <span class="n">script_file</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
        <span class="c1"># grab the returncode. SGE returns 0 if the job was successful</span>
        <span class="n">queue_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">process</span><span class="o">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># output should of the form</span>
                <span class="c1"># Your job 1659048 (&quot;NAME_OF_JOB&quot;) has been submitted</span>
                <span class="n">queue_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># probably error parsing job code</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Could not parse job id following qsub...&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SubmitResults</span><span class="p">(</span><span class="n">qid</span><span class="o">=</span><span class="n">queue_id</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="n">process</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">exclude_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to exclude nodes in the calculation&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;qadapter failed to exclude nodes, not implemented yet in sge&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_njobs_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;qstat&#39;</span><span class="p">,</span> <span class="s1">&#39;-u&#39;</span><span class="p">,</span> <span class="n">username</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need string not bytes so must use universal_newlines</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;qstat&#39;</span><span class="p">,</span> <span class="s1">&#39;-u&#39;</span><span class="p">,</span> <span class="n">username</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
        <span class="n">njobs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">process</span><span class="o">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># parse the result</span>
            <span class="c1"># lines should contain username</span>
            <span class="c1"># count lines that include the username in it</span>

            <span class="c1"># TODO: only count running or queued jobs. or rather, *don&#39;t* count jobs that are &#39;C&#39;.</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
            <span class="n">njobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">outs</span> <span class="k">if</span> <span class="n">username</span> <span class="ow">in</span> <span class="n">line</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">njobs</span><span class="p">,</span> <span class="n">process</span>


<span class="k">class</span> <span class="nc">MOABAdapter</span><span class="p">(</span><span class="n">QueueAdapter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adapter for MOAB. See https://computing.llnl.gov/tutorials/moab/&quot;&quot;&quot;</span>
    <span class="n">QTYPE</span> <span class="o">=</span> <span class="s2">&quot;moab&quot;</span>

    <span class="n">QTEMPLATE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">#!/bin/bash</span>

<span class="s2">#MSUB -a $$</span><span class="si">{eligible_date}</span><span class="s2"></span>
<span class="s2">#MSUB -A $$</span><span class="si">{account}</span><span class="s2"></span>
<span class="s2">#MSUB -c $$</span><span class="si">{checkpoint_interval}</span><span class="s2"></span>
<span class="s2">#MSUB -l feature=$$</span><span class="si">{feature}</span><span class="s2"></span>
<span class="s2">#MSUB -l gres=$$</span><span class="si">{gres}</span><span class="s2"></span>
<span class="s2">#MSUB -l nodes=$$</span><span class="si">{nodes}</span><span class="s2"></span>
<span class="s2">#MSUB -l partition=$$</span><span class="si">{partition}</span><span class="s2"></span>
<span class="s2">#MSUB -l procs=$$</span><span class="si">{procs}</span><span class="s2"></span>
<span class="s2">#MSUB -l ttc=$$</span><span class="si">{ttc}</span><span class="s2"></span>
<span class="s2">#MSUB -l walltime=$$</span><span class="si">{walltime}</span><span class="s2"></span>
<span class="s2">#MSUB -l $$</span><span class="si">{resources}</span><span class="s2"></span>
<span class="s2">#MSUB -p $$</span><span class="si">{priority}</span><span class="s2"></span>
<span class="s2">#MSUB -q $$</span><span class="si">{queue}</span><span class="s2"></span>
<span class="s2">#MSUB -S $$</span><span class="si">{shell}</span><span class="s2"></span>
<span class="s2">#MSUB -N $$</span><span class="si">{job_name}</span><span class="s2"></span>
<span class="s2">#MSUB -v $$</span><span class="si">{variable_list}</span><span class="s2"></span>

<span class="s2">#MSUB -o $$</span><span class="si">{_qout_path}</span><span class="s2"></span>
<span class="s2">#MSUB -e $$</span><span class="si">{_qerr_path}</span><span class="s2"></span>
<span class="s2">$$</span><span class="si">{qverbatim}</span><span class="s2"></span>
<span class="s2">&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of CPUs used for MPI.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MOABAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;procs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi_procs</span>

    <span class="k">def</span> <span class="nf">set_timelimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timelimit</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MOABAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_timelimit</span><span class="p">(</span><span class="n">timelimit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;walltime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qu</span><span class="o">.</span><span class="n">time2slurm</span><span class="p">(</span><span class="n">timelimit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem_mb</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MOABAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_mem_per_proc</span><span class="p">(</span><span class="n">mem_mb</span><span class="p">)</span>
        <span class="c1">#TODO</span>
        <span class="c1">#raise NotImplementedError(&quot;set_mem_per_cpu&quot;)</span>

    <span class="k">def</span> <span class="nf">exclude_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s1">&#39;qadapter failed to exclude nodes, not implemented yet in moad&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;canceljob </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">job_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_submit_to_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">script_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Submit a job script to the queue.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;msub&#39;</span><span class="p">,</span> <span class="n">script_file</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need string not bytes so must use universal_newlines</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;msub&#39;</span><span class="p">,</span> <span class="n">script_file</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
        <span class="n">queue_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">process</span><span class="o">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># grab the returncode. MOAB returns 0 if the job was successful</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># output should be the queue_id</span>
                <span class="n">queue_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># probably error parsing job code</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s1">&#39;Could not parse job id following msub...&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SubmitResults</span><span class="p">(</span><span class="n">qid</span><span class="o">=</span><span class="n">queue_id</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="n">process</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_njobs_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;showq&#39;</span><span class="p">,</span> <span class="s1">&#39;-s -u&#39;</span><span class="p">,</span> <span class="n">username</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need string not bytes so must use universal_newlines</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;showq&#39;</span><span class="p">,</span> <span class="s1">&#39;-s -u&#39;</span><span class="p">,</span> <span class="n">username</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
        <span class="n">njobs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">process</span><span class="o">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># parse the result</span>
            <span class="c1"># lines should have this form:</span>
            <span class="c1">##</span>
            <span class="c1">## active jobs: N  eligible jobs: M  blocked jobs: P</span>
            <span class="c1">##</span>
            <span class="c1">## Total job:  1</span>
            <span class="c1">##</span>
            <span class="c1"># Split the output string and return the last element.</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">njobs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">njobs</span><span class="p">,</span> <span class="n">process</span>


<span class="k">class</span> <span class="nc">BlueGeneAdapter</span><span class="p">(</span><span class="n">QueueAdapter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adapter for LoadLever on BlueGene architectures.</span>

<span class="sd">    See:</span>
<span class="sd">        http://www.prace-ri.eu/best-practice-guide-blue-gene-q-html/#id-1.5.4.8</span>
<span class="sd">        https://www.lrz.de/services/compute/supermuc/loadleveler/</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">QTYPE</span> <span class="o">=</span> <span class="s2">&quot;bluegene&quot;</span>

    <span class="n">QTEMPLATE</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">#!/bin/bash</span>
<span class="s2"># @ job_name = $$</span><span class="si">{job_name}</span><span class="s2"></span>
<span class="s2"># @ class = $$</span><span class="si">{class}</span><span class="s2"></span>
<span class="s2"># @ error = $$</span><span class="si">{_qout_path}</span><span class="s2"></span>
<span class="s2"># @ output = $$</span><span class="si">{_qerr_path}</span><span class="s2"></span>
<span class="s2"># @ wall_clock_limit = $$</span><span class="si">{wall_clock_limit}</span><span class="s2"></span>
<span class="s2"># @ notification = $$</span><span class="si">{notification}</span><span class="s2"></span>
<span class="s2"># @ notify_user = $$</span><span class="si">{mail_user}</span><span class="s2"></span>
<span class="s2"># @ environment = $$</span><span class="si">{environment}</span><span class="s2"></span>
<span class="s2"># @ account_no = $$</span><span class="si">{account_no}</span><span class="s2"></span>
<span class="s2"># @ job_type = bluegene</span>
<span class="s2"># @ bg_connectivity = $$</span><span class="si">{bg_connectivity}</span><span class="s2"></span>
<span class="s2"># @ bg_size = $$</span><span class="si">{bg_size}</span><span class="s2"></span>
<span class="s2">$$</span><span class="si">{qverbatim}</span><span class="s2"></span>
<span class="s2"># @ queue</span>
<span class="s2">&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_qname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qname</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BlueGeneAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_qname</span><span class="p">(</span><span class="n">qname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">qname</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qname</span>

    <span class="c1">#def set_mpi_procs(self, mpi_procs):</span>
    <span class="c1">#    &quot;&quot;&quot;Set the number of CPUs used for MPI.&quot;&quot;&quot;</span>
    <span class="c1">#    super(BlueGeneAdapter, self).set_mpi_procs(mpi_procs)</span>
    <span class="c1">#    #self.qparams[&quot;ntasks&quot;] = mpi_procs</span>

    <span class="c1">#def set_omp_threads(self, omp_threads):</span>
    <span class="c1">#    super(BlueGeneAdapter, self).set_omp_threads(omp_threads)</span>
    <span class="c1">#    #self.qparams[&quot;cpus_per_task&quot;] = omp_threads</span>

    <span class="c1">#def set_mem_per_proc(self, mem_mb):</span>
    <span class="c1">#    &quot;&quot;&quot;Set the memory per process in megabytes&quot;&quot;&quot;</span>
    <span class="c1">#    super(BlueGeneAdapter, self).set_mem_per_proc(mem_mb)</span>
    <span class="c1">#    #self.qparams[&quot;mem_per_cpu&quot;] = self.mem_per_proc</span>

    <span class="k">def</span> <span class="nf">set_timelimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timelimit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Limits are specified with the format hh:mm:ss (hours:minutes:seconds)&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BlueGeneAdapter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_timelimit</span><span class="p">(</span><span class="n">timelimit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qparams</span><span class="p">[</span><span class="s2">&quot;wall_clock_limit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qu</span><span class="o">.</span><span class="n">time2loadlever</span><span class="p">(</span><span class="n">timelimit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;llcancel </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">job_id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bgsize_rankspernode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	    <span class="sd">&quot;&quot;&quot;Return (bg_size, ranks_per_node) from mpi_procs and omp_threads.&quot;&quot;&quot;</span>
	    <span class="n">bg_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span><span class="p">)</span><span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span><span class="p">))</span>
	    <span class="n">bg_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">bg_size</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="c1"># TODO hardcoded</span>
	    <span class="n">ranks_per_node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">/</span> <span class="n">bg_size</span><span class="p">))</span>

	    <span class="k">return</span> <span class="n">bg_size</span><span class="p">,</span> <span class="n">ranks_per_node</span>

    <span class="k">def</span> <span class="nf">optimize_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qnodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">bg_size</span><span class="p">,</span> <span class="n">rpn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bgsize_rankspernode</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;in optimize params&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mpi_procs:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="s2">&quot;omp_threads:&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bg_size:&quot;</span><span class="p">,</span><span class="n">bg_size</span><span class="p">,</span><span class="s2">&quot;ranks_per_node&quot;</span><span class="p">,</span><span class="n">rpn</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;bg_size&quot;</span><span class="p">:</span> <span class="n">bg_size</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_submit_to_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">script_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Submit a job script to the queue.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;llsubmit&#39;</span><span class="p">,</span> <span class="n">script_file</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need string not bytes so must use universal_newlines</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;llsubmit&#39;</span><span class="p">,</span> <span class="n">script_file</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
        <span class="c1"># grab the return code. llsubmit returns 0 if the job was successful</span>
        <span class="n">queue_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">process</span><span class="o">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># on JUQUEEN, output should of the form</span>
                <span class="c1">#llsubmit: The job &quot;juqueen1c1.zam.kfa-juelich.de.281506&quot; has been submitted.</span>
                <span class="n">token</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">queue_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># probably error parsing job code</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Could not parse job id following llsubmit...&quot;</span><span class="p">)</span>
                <span class="k">raise</span>

        <span class="k">return</span> <span class="n">SubmitResults</span><span class="p">(</span><span class="n">qid</span><span class="o">=</span><span class="n">queue_id</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="n">err</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="n">process</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_njobs_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;llq&#39;</span><span class="p">,</span> <span class="s1">&#39;-u&#39;</span><span class="p">,</span> <span class="n">username</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># need string not bytes so must use universal_newlines</span>
            <span class="n">process</span> <span class="o">=</span> <span class="n">Popen</span><span class="p">([</span><span class="s1">&#39;llq&#39;</span><span class="p">,</span> <span class="s1">&#39;-u&#39;</span><span class="p">,</span> <span class="n">username</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">out</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
        <span class="n">njobs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">process</span><span class="o">.</span><span class="n">returncode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># parse the result. lines should have this form:</span>
            <span class="c1">#</span>
            <span class="c1"># Id                       Owner      Submitted   ST PRI Class        Running On</span>
            <span class="c1"># ------------------------ ---------- ----------- -- --- ------------ -----------</span>
            <span class="c1"># juqueen1c1.281508.0      paj15530    1/23 13:20 I  50  n001</span>
            <span class="c1"># 1 job step(s) in query, 1 waiting, 0 pending, 0 running, 0 held, 0 preempted</span>
            <span class="c1">#</span>
            <span class="c1"># count lines that include the username in it</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">njobs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">outs</span> <span class="k">if</span> <span class="n">username</span> <span class="ow">in</span> <span class="n">line</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">njobs</span><span class="p">,</span> <span class="n">process</span>

    <span class="k">def</span> <span class="nf">exclude_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 2018.9.12 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../pymatgen.html" >pymatgen</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2011, Pymatgen Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.0.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>