
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pymatgen.io.abinit.works &#8212; pymatgen 2019.1.24 documentation</title>
    <link rel="stylesheet" href="../../../../_static/proBlue.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 2019.1.24 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../pymatgen.html" accesskey="U">pymatgen</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.io.abinit.works</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="c1"># Copyright (c) Pymatgen Development Team.</span>
<span class="c1"># Distributed under the terms of the MIT License.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Works for Abinit</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">monty.collections</span> <span class="k">import</span> <span class="n">AttrDict</span>
<span class="kn">from</span> <span class="nn">monty.itertools</span> <span class="k">import</span> <span class="n">chunks</span>
<span class="kn">from</span> <span class="nn">monty.functools</span> <span class="k">import</span> <span class="n">lazy_property</span>
<span class="kn">from</span> <span class="nn">monty.fnmatch</span> <span class="k">import</span> <span class="n">WildCard</span>
<span class="kn">from</span> <span class="nn">pydispatch</span> <span class="k">import</span> <span class="n">dispatcher</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.units</span> <span class="k">import</span> <span class="n">EnergyArray</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">wrappers</span>
<span class="kn">from</span> <span class="nn">.nodes</span> <span class="k">import</span> <span class="n">Dependency</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">NodeError</span><span class="p">,</span> <span class="n">NodeResults</span><span class="p">,</span> <span class="n">FileNode</span><span class="p">,</span> <span class="n">check_spectator</span>
<span class="kn">from</span> <span class="nn">.tasks</span> <span class="k">import</span> <span class="p">(</span><span class="n">Task</span><span class="p">,</span> <span class="n">AbinitTask</span><span class="p">,</span> <span class="n">ScfTask</span><span class="p">,</span> <span class="n">NscfTask</span><span class="p">,</span> <span class="n">DfptTask</span><span class="p">,</span> <span class="n">PhononTask</span><span class="p">,</span> <span class="n">ElasticTask</span><span class="p">,</span> <span class="n">DdkTask</span><span class="p">,</span>
                    <span class="n">BseTask</span><span class="p">,</span> <span class="n">RelaxTask</span><span class="p">,</span> <span class="n">DdeTask</span><span class="p">,</span> <span class="n">BecTask</span><span class="p">,</span> <span class="n">ScrTask</span><span class="p">,</span> <span class="n">SigmaTask</span><span class="p">,</span> <span class="n">TaskManager</span><span class="p">,</span>
                    <span class="n">DteTask</span><span class="p">,</span> <span class="n">EphTask</span><span class="p">,</span> <span class="n">CollinearThenNonCollinearScfTask</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">Directory</span>
<span class="kn">from</span> <span class="nn">.netcdf</span> <span class="k">import</span> <span class="n">ETSF_Reader</span><span class="p">,</span> <span class="n">NetcdfReader</span>
<span class="kn">from</span> <span class="nn">.abitimer</span> <span class="k">import</span> <span class="n">AbinitTimerParser</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Matteo Giantomassi&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2013, The Materials Project&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.1&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Matteo Giantomassi&quot;</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Work&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BandStructureWork&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RelaxWork&quot;</span><span class="p">,</span>
    <span class="s2">&quot;G0W0Work&quot;</span><span class="p">,</span>
    <span class="s2">&quot;QptdmWork&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SigmaConvWork&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BseMdfWork&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PhononWork&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PhononWfkqWork&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GKKPWork&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BecWork&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DteWork&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">class</span> <span class="nc">WorkResults</span><span class="p">(</span><span class="n">NodeResults</span><span class="p">):</span>
    <span class="n">JSON_SCHEMA</span> <span class="o">=</span> <span class="n">NodeResults</span><span class="o">.</span><span class="n">JSON_SCHEMA</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_node</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">work</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance from a :class:`Work` instance.&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">WorkResults</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_node</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>

        <span class="c1"># Will put all files found in outdir in GridFs</span>
        <span class="c1"># Warning: assuming binary files.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">f</span><span class="p">):</span> <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">work</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()}</span>
        <span class="n">new</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span>


<span class="k">class</span> <span class="nc">WorkError</span><span class="p">(</span><span class="n">NodeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for the exceptions raised by Work objects.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">BaseWork</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">WorkError</span>

    <span class="n">Results</span> <span class="o">=</span> <span class="n">WorkResults</span>

    <span class="c1"># interface modeled after subprocess.Popen</span>
    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">processes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of objects that support the `subprocess.Popen` protocol.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if all child processes have terminated. Set and return returncode attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wait for child processed to terminate. Set and return returncode attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">communicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interact with processes: Send data to stdin. Read data from stdout and</span>
<span class="sd">        stderr, until end-of-file is reached.</span>
<span class="sd">        Wait for process to terminate. The optional input argument should be a</span>
<span class="sd">        string to be sent to the child processed, or None, if no data should be</span>
<span class="sd">        sent to the children.</span>

<span class="sd">        communicate() returns a list of tuples (stdoutdata, stderrdata).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">returncodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The children return codes, set by poll() and wait() (and indirectly by communicate()).</span>
<span class="sd">        A None value indicates that the process hasn&#39;t terminated yet.</span>
<span class="sd">        A negative value -N indicates that the child was terminated by signal N (Unix only).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">returncode</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ncores_reserved</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of cores reserved in this moment.</span>
<span class="sd">        A core is reserved if it&#39;s still not running but</span>
<span class="sd">        we have submitted the task to the queue manager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">num_cores</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">task</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ncores_allocated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of CPUs allocated in this moment.</span>
<span class="sd">        A core is allocated if it&#39;s running a task or if we have</span>
<span class="sd">        submitted a task to the queue manager but the job is still pending.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">num_cores</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">S_RUN</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ncores_used</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of cores used in this moment.</span>
<span class="sd">        A core is used if there&#39;s a job that is running on it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">num_cores</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">task</span><span class="o">.</span><span class="n">S_RUN</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fetch_task_to_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first task that is ready to run or</span>
<span class="sd">        None if no task can be submitted at present&quot;</span>

<span class="sd">        Raises:</span>
<span class="sd">            `StopIteration` if all tasks are done.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># All the tasks are done so raise an exception</span>
        <span class="c1"># that will be handled by the client code.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">is_completed</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">(</span><span class="s2">&quot;All tasks completed.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">can_run</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">task</span>

        <span class="c1"># No task found, this usually happens when we have dependencies.</span>
        <span class="c1"># Beware of possible deadlocks here!</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Possible deadlock in fetch_task_to_run!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">fetch_alltasks_to_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list with all the tasks that can be submitted.</span>
<span class="sd">        Empty list if not task has been found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">task</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">can_run</span><span class="p">]</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method called before submitting the calculations.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connect_signals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect the signals within the work.</span>
<span class="sd">        The :class:`Work` is responsible for catching the important signals raised from</span>
<span class="sd">        its task and raise new signals when some particular condition occurs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">dispatcher</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_ok</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">S_OK</span><span class="p">,</span> <span class="n">sender</span><span class="o">=</span><span class="n">task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">disconnect_signals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disable the signals within the work. This function reverses the process of `connect_signals`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dispatcher</span><span class="o">.</span><span class="n">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_ok</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">S_OK</span><span class="p">,</span> <span class="n">sender</span><span class="o">=</span><span class="n">task</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">dispatcher</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">DispatcherKeyError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">task</span><span class="o">.</span><span class="n">S_OK</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This callback is called when one task reaches status `S_OK`.</span>
<span class="sd">        It executes on_all_ok when all tasks in self have reached `S_OK`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;in on_ok with sender </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">sender</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_ok</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">returncode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Work has been already finalized&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Set finalized here, because on_all_ok might change it (e.g. Relax + EOS in a single work)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">on_all_ok</span><span class="p">())</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;on_all_ok raises </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">raise</span>

                <span class="c1"># Signal to possible observers that the `Work` reached S_OK</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Work </span><span class="si">%s</span><span class="s2"> is finalized and broadcasts signal S_OK&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">results</span>

        <span class="k">return</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">returncode</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Not all tasks are OK!&quot;</span><span class="p">)</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">on_all_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called once the `Work` is completed i.e. when all tasks</span>
<span class="sd">        have reached status S_OK. Subclasses should provide their own implementation</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary that must contain at least the following entries:</span>
<span class="sd">                returncode:</span>
<span class="sd">                    0 on success.</span>
<span class="sd">                message:</span>
<span class="sd">                    a string that should provide a human-readable description of what has been performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">returncode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Calling on_all_ok of the base class!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method called once the calculations are completed.</span>
<span class="sd">        The base version returns a dictionary task_name: TaskResults for each task in self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Results</span><span class="o">.</span><span class="n">from_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">get_graphviz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;automatic&quot;</span><span class="p">,</span> <span class="n">graph_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate task graph in the DOT language (only parents and children of this work).</span>

<span class="sd">        Args:</span>
<span class="sd">            engine: Layout command used. [&#39;dot&#39;, &#39;neato&#39;, &#39;twopi&#39;, &#39;circo&#39;, &#39;fdp&#39;, &#39;sfdp&#39;, &#39;patchwork&#39;, &#39;osage&#39;]</span>
<span class="sd">            graph_attr: Mapping of (attribute, value) pairs for the graph.</span>
<span class="sd">            node_attr: Mapping of (attribute, value) pairs set for all nodes.</span>
<span class="sd">            edge_attr: Mapping of (attribute, value) pairs set for all edges.</span>

<span class="sd">        Returns: graphviz.Digraph &lt;https://graphviz.readthedocs.io/en/stable/api.html#digraph&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">graphviz</span> <span class="k">import</span> <span class="n">Digraph</span>
        <span class="n">fg</span> <span class="o">=</span> <span class="n">Digraph</span><span class="p">(</span><span class="s2">&quot;work&quot;</span><span class="p">,</span> <span class="c1">#filename=&quot;work_%s.gv&quot; % os.path.basename(self.workdir),</span>
            <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;fdp&quot;</span> <span class="k">if</span> <span class="n">engine</span> <span class="o">==</span> <span class="s2">&quot;automatic&quot;</span> <span class="k">else</span> <span class="n">engine</span><span class="p">)</span>

        <span class="c1"># Set graph attributes.</span>
        <span class="c1"># https://www.graphviz.org/doc/info/</span>
        <span class="c1">#fg.attr(label=&quot;%s@%s&quot; % (self.__class__.__name__, self.relworkdir))</span>
        <span class="n">fg</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="c1">#fg.attr(fontcolor=&quot;white&quot;, bgcolor=&#39;purple:pink&#39;)</span>
        <span class="n">fg</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">rankdir</span><span class="o">=</span><span class="s2">&quot;LR&quot;</span><span class="p">,</span> <span class="n">pagedir</span><span class="o">=</span><span class="s2">&quot;BL&quot;</span><span class="p">)</span>
        <span class="c1">#fg.attr(constraint=&quot;false&quot;, pack=&quot;true&quot;, packMode=&quot;clust&quot;)</span>
        <span class="n">fg</span><span class="o">.</span><span class="n">node_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightblue2&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;filled&#39;</span><span class="p">)</span>
        <span class="c1">#fg.node_attr.update(ranksep=&#39;equally&#39;)</span>

        <span class="c1"># Add input attributes.</span>
        <span class="k">if</span> <span class="n">graph_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fg</span><span class="o">.</span><span class="n">graph_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">graph_attr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fg</span><span class="o">.</span><span class="n">node_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">node_attr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fg</span><span class="o">.</span><span class="n">edge_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">edge_attr</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">node_kwargs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="c1">#shape=&quot;circle&quot;,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">color_hex</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;pos_str&quot;</span><span class="p">)</span> <span class="k">else</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">pos_str</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="n">edge_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">arrowType</span><span class="o">=</span><span class="s2">&quot;vee&quot;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s2">&quot;solid&quot;</span><span class="p">)</span>
        <span class="n">cluster_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rankdir</span><span class="o">=</span><span class="s2">&quot;LR&quot;</span><span class="p">,</span> <span class="n">pagedir</span><span class="o">=</span><span class="s2">&quot;BL&quot;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s2">&quot;rounded&quot;</span><span class="p">,</span> <span class="n">bgcolor</span><span class="o">=</span><span class="s2">&quot;azure2&quot;</span><span class="p">)</span>

        <span class="c1"># Build cluster with tasks in *this* work</span>
        <span class="n">cluster_name</span> <span class="o">=</span> <span class="s2">&quot;cluster</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">with</span> <span class="n">fg</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">cluster_name</span><span class="p">)</span> <span class="k">as</span> <span class="n">wg</span><span class="p">:</span>
            <span class="n">wg</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="o">**</span><span class="n">cluster_kwargs</span><span class="p">)</span>
            <span class="n">wg</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">wg</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">node_kwargs</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
                <span class="c1"># Connect task to children</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">task</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
                    <span class="c1"># Test if child is in this cluster (self).</span>
                    <span class="n">myg</span> <span class="o">=</span> <span class="n">wg</span> <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">else</span> <span class="n">fg</span>
                    <span class="n">myg</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">node_kwargs</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
                    <span class="c1"># Find file extensions required by this task</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">dep</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
                    <span class="n">edge_label</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
                    <span class="n">myg</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">edge_label</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">color_hex</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">edge_kwargs</span><span class="p">)</span>

                <span class="c1"># Connect task to parents</span>
                <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">task</span><span class="o">.</span><span class="n">get_parents</span><span class="p">():</span>
                    <span class="c1"># Test if parent is in this cluster (self).</span>
                    <span class="n">myg</span> <span class="o">=</span> <span class="n">wg</span> <span class="k">if</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">else</span> <span class="n">fg</span>
                    <span class="n">myg</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">node_kwargs</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
                    <span class="c1"># Find file extensions required by this task</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">dep</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">task</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                    <span class="n">edge_label</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">deps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
                    <span class="n">myg</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">edge_label</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">color_hex</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">edge_kwargs</span><span class="p">)</span>

        <span class="c1"># Treat the case in which we have a work producing output for tasks in *this* work.</span>
        <span class="c1">#for work in self.flow:</span>
        <span class="c1">#    children = work.get_children()</span>
        <span class="c1">#    if not children or all(child not in self for child in children):</span>
        <span class="c1">#        continue</span>
        <span class="c1">#    cluster_name = &quot;cluster%s&quot; % work.name</span>
        <span class="c1">#    seen = set()</span>
        <span class="c1">#    for child in children:</span>
        <span class="c1">#        if child not in self: continue</span>
        <span class="c1">#        # This is not needed, too much confusing</span>
        <span class="c1">#        #fg.edge(cluster_name, child.name, color=work.color_hex, **edge_kwargs)</span>
        <span class="c1">#        # Find file extensions required by work</span>
        <span class="c1">#        i = [dep.node for dep in child.deps].index(work)</span>
        <span class="c1">#        for ext in child.deps[i].exts:</span>
        <span class="c1">#            out = &quot;%s (%s)&quot; % (ext, work.name)</span>
        <span class="c1">#            fg.node(out)</span>
        <span class="c1">#            fg.edge(out, child.name, **edge_kwargs)</span>
        <span class="c1">#            key = (cluster_name, out)</span>
        <span class="c1">#            if key not in seen:</span>
        <span class="c1">#                fg.edge(cluster_name, out, color=work.color_hex, **edge_kwargs)</span>
        <span class="c1">#                seen.add(key)</span>

        <span class="k">return</span> <span class="n">fg</span>


<span class="k">class</span> <span class="nc">NodeContainer</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin classes for `Work` and `Flow` objects providing helper functions</span>
<span class="sd">    to register tasks in the container. The helper function call the</span>
<span class="sd">    `register` method of the container.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Abstract protocol for containers</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">register_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register a task in the container.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: shall flow.register_task return a Task or a Work?</span>

    <span class="c1"># Helper functions</span>
    <span class="k">def</span> <span class="nf">register_scf_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a Scf task.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ScfTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_collinear_then_noncollinear_scf_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a Scf task that perform a SCF run first with nsppol = 2 and then nspinor = 2&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">CollinearThenNonCollinearScfTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_nscf_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a nscf task.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NscfTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_relax_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a task for structural optimization.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">RelaxTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_phonon_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a phonon task.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">PhononTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_elastic_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register an elastic task.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ElasticTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_ddk_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a ddk task.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DdkTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_scr_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a screening task.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ScrTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_sigma_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a sigma task.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SigmaTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_dde_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a Dde task.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DdeTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_dte_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a Dte task.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DteTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_bec_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a BEC task.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">BecTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_bse_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a Bethe-Salpeter task.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">BseTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_eph_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register an electron-phonon task.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;task_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">EphTask</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_task</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">walknset_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the values of the ABINIT variables in the input files of the nodes</span>

<span class="sd">        Args:</span>
<span class="sd">            task_class: If not None, only the input files of the tasks belonging</span>
<span class="sd">                to class `task_class` are modified.</span>

<span class="sd">        Example:</span>

<span class="sd">            flow.walknset_vars(ecut=10, kptopt=4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">change_task</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">task_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">task</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">task_class</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_work</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">change_task</span><span class="p">(</span><span class="n">task</span><span class="p">):</span> <span class="k">continue</span>
                <span class="n">task</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_flow</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iflat_tasks</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">change_task</span><span class="p">(</span><span class="n">task</span><span class="p">):</span> <span class="k">continue</span>
                <span class="n">task</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to set variables for object class </span><span class="si">%s</span><span class="s2">&quot;</span>  <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="Work"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work">[docs]</a><span class="k">class</span> <span class="nc">Work</span><span class="p">(</span><span class="n">BaseWork</span><span class="p">,</span> <span class="n">NodeContainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Work is a list of (possibly connected) tasks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            workdir: Path to the working directory.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Work</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">workdir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_workdir</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_manager</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>

<div class="viewcode-block" id="Work.set_manager"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.set_manager">[docs]</a>    <span class="k">def</span> <span class="nf">set_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the :class:`TaskManager` to use to launch the :class:`Task`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">set_manager</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The flow containing this :class:`Work`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flow</span>

<div class="viewcode-block" id="Work.set_flow"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.set_flow">[docs]</a>    <span class="k">def</span> <span class="nf">set_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the flow associated to this :class:`Work`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_flow&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flow</span> <span class="o">=</span> <span class="n">flow</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flow</span> <span class="o">!=</span> <span class="n">flow</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;self._flow != flow&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Work.pos"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.pos">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The position of self in the :class:`Flow`&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">work</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">work</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find the position of </span><span class="si">%s</span><span class="s2"> in flow </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation of self.pos&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;w&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>

<div class="viewcode-block" id="Work.set_workdir"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.set_workdir">[docs]</a>    <span class="k">def</span> <span class="nf">set_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="p">,</span> <span class="n">chroot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the working directory. Cannot be set more than once unless chroot is True&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">chroot</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;workdir&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">workdir</span> <span class="o">!=</span> <span class="n">workdir</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;self.workdir != workdir: </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span>  <span class="n">workdir</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">workdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>

        <span class="c1"># Directories with (input|output|temporary) data.</span>
        <span class="c1"># The work will use these directories to connect</span>
        <span class="c1"># itself to other works and/or to produce new data</span>
        <span class="c1"># that will be used by its children.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;indata&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;outdata&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;tmpdata&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span></div>

<div class="viewcode-block" id="Work.chroot"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.chroot">[docs]</a>    <span class="k">def</span> <span class="nf">chroot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_workdir</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_workdir</span><span class="p">(</span><span class="n">new_workdir</span><span class="p">,</span> <span class="n">chroot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">new_tdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">task</span><span class="o">.</span><span class="n">set_workdir</span><span class="p">(</span><span class="n">new_tdir</span><span class="p">,</span> <span class="n">chroot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="p">[</span><span class="nb">slice</span><span class="p">]</span>

<div class="viewcode-block" id="Work.chunks"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.chunks">[docs]</a>    <span class="k">def</span> <span class="nf">chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield successive chunks of tasks of lenght chunk_size.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tasks</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">tasks</span></div>

    <span class="k">def</span> <span class="nf">opath_from_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the path of the output file with extension ext.</span>
<span class="sd">        Use it when the file does not exist yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;in_&quot;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>

<div class="viewcode-block" id="Work.opath_from_ext"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.opath_from_ext">[docs]</a>    <span class="k">def</span> <span class="nf">opath_from_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the path of the output file with extension ext.</span>
<span class="sd">        Use it when the file does not exist yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;out_&quot;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">processes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">process</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if all the :class:`Task` objects in the :class:`Work` are done.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="n">task</span><span class="o">.</span><span class="n">S_DONE</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isnc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if norm-conserving calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">isnc</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ispaw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if PAW calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">ispaw</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">status_counter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a `Counter` object that counts the number of task with</span>
<span class="sd">        given status (use the string representation of the status as key).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">counter</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">status</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">counter</span>

<div class="viewcode-block" id="Work.allocate"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.allocate">[docs]</a>    <span class="k">def</span> <span class="nf">allocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is called once we have completed the initialization</span>
<span class="sd">        of the :class:`Work`. It sets the manager of each task (if not already done)</span>
<span class="sd">        and defines the working directories of the tasks.</span>

<span class="sd">        Args:</span>
<span class="sd">            manager: :class:`TaskManager` object or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="s2">&quot;manager&quot;</span><span class="p">):</span>
                <span class="c1"># Set the manager</span>
                <span class="c1"># Use the one provided in input else the one of the work/flow.</span>
                <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">task</span><span class="o">.</span><span class="n">set_manager</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Look first in work and then in the flow.</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;manager&quot;</span><span class="p">):</span>
                        <span class="n">task</span><span class="o">.</span><span class="n">set_manager</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">task</span><span class="o">.</span><span class="n">set_manager</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">manager</span><span class="p">)</span>

            <span class="n">task_workdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="s2">&quot;workdir&quot;</span><span class="p">):</span>
                <span class="n">task</span><span class="o">.</span><span class="n">set_workdir</span><span class="p">(</span><span class="n">task_workdir</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">workdir</span> <span class="o">!=</span> <span class="n">task_workdir</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;task.workdir != task_workdir: </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">task_workdir</span><span class="p">))</span></div>

<div class="viewcode-block" id="Work.register"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">required_files</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">task_class</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers a new :class:`Task` and add it to the internal list, taking into account possible dependencies.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj: :class:`AbinitInput` instance or `Task` object.</span>
<span class="sd">            deps: Dictionary specifying the dependency of this node or list of dependencies</span>
<span class="sd">                  None means that this obj has no dependency.</span>
<span class="sd">            required_files: List of strings with the path of the files used by the task.</span>
<span class="sd">                Note that the files must exist when the task is registered.</span>
<span class="sd">                Use the standard approach based on Works, Tasks and deps</span>
<span class="sd">                if the files will be produced in the future.</span>
<span class="sd">            manager:</span>
<span class="sd">                The :class:`TaskManager` responsible for the submission of the task. If manager is None, we use</span>
<span class="sd">                the `TaskManager` specified during the creation of the :class:`Work`.</span>
<span class="sd">            task_class: Task subclass to instantiate. Default: :class:`AbinitTask`</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`Task` object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task_workdir</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;workdir&quot;</span><span class="p">):</span>
            <span class="n">task_workdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Task</span><span class="p">):</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">obj</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Set the class</span>
            <span class="k">if</span> <span class="n">task_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">task_class</span> <span class="o">=</span> <span class="n">AbinitTask</span>

            <span class="n">task</span> <span class="o">=</span> <span class="n">task_class</span><span class="o">.</span><span class="n">from_input</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">task_workdir</span><span class="p">,</span> <span class="n">manager</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

        <span class="c1"># Handle possible dependencies given either as dict or list.</span>
        <span class="k">if</span> <span class="n">deps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">deps</span><span class="p">,</span> <span class="s2">&quot;items&quot;</span><span class="p">):</span>
                <span class="n">deps</span> <span class="o">=</span> <span class="p">[</span><span class="n">Dependency</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">exts</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">exts</span> <span class="ow">in</span> <span class="n">deps</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">task</span><span class="o">.</span><span class="n">add_deps</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>

        <span class="c1"># Handle possible dependencies.</span>
        <span class="k">if</span> <span class="n">required_files</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">add_required_files</span><span class="p">(</span><span class="n">required_files</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">task</span></div>

    <span class="c1"># Needed by NodeContainer</span>
    <span class="n">register_task</span> <span class="o">=</span> <span class="n">register</span>

<div class="viewcode-block" id="Work.path_in_workdir"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.path_in_workdir">[docs]</a>    <span class="k">def</span> <span class="nf">path_in_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the absolute path of filename in the working directory.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>

<div class="viewcode-block" id="Work.setup"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method called before running the calculations.</span>
<span class="sd">        The default implementation is empty.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="Work.build"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.build">[docs]</a>    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates the top level directory.&quot;&quot;&quot;</span>
        <span class="c1"># Create the directories of the work.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>

        <span class="c1"># Build dirs and files of each task.</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Connect signals within the work.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect_signals</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the status of the work i.e. the minimum of the status of the tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_status</span><span class="p">(</span><span class="n">only_min</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="Work.get_all_status"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.get_all_status">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">only_min</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list with the status of the tasks in self.</span>

<span class="sd">        Args:</span>
<span class="sd">            only_min: If True, the minimum of the status is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># The work will be created in the future.</span>
            <span class="k">if</span> <span class="n">only_min</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_status</span><span class="p">()</span>
        <span class="n">status_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">only_min</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">status_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">status_list</span></div>

<div class="viewcode-block" id="Work.check_status"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.check_status">[docs]</a>    <span class="k">def</span> <span class="nf">check_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check the status of the tasks.&quot;&quot;&quot;</span>
        <span class="c1"># Recompute the status of the tasks</span>
        <span class="c1"># Ignore OK and LOCKED tasks.</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="ow">in</span> <span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">S_OK</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">S_LOCKED</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">task</span><span class="o">.</span><span class="n">check_status</span><span class="p">()</span>

        <span class="c1"># Take into account possible dependencies. Use a list instead of generators</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">task</span><span class="o">.</span><span class="n">S_LOCKED</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="n">task</span><span class="o">.</span><span class="n">S_SUB</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">task</span><span class="o">.</span><span class="n">S_OK</span> <span class="k">for</span> <span class="n">status</span> <span class="ow">in</span> <span class="n">task</span><span class="o">.</span><span class="n">deps_status</span><span class="p">):</span>
                <span class="n">task</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="s2">&quot;Status set to Ready&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Work.rmtree"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.rmtree">[docs]</a>    <span class="k">def</span> <span class="nf">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_wildcard</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all files and directories in the working directory</span>

<span class="sd">        Args:</span>
<span class="sd">            exclude_wildcard: Optional string with regular expressions separated by `|`.</span>
<span class="sd">                Files matching one of the regular expressions will be preserved.</span>
<span class="sd">                example: exclude_wildard=&quot;*.nc|*.txt&quot; preserves all the files</span>
<span class="sd">                whose extension is in [&quot;nc&quot;, &quot;txt&quot;].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_wildcard</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">WildCard</span><span class="p">(</span><span class="n">exclude_wildcard</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">dirnames</span><span class="p">,</span> <span class="n">filenames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">w</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Work.rm_indatadir"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.rm_indatadir">[docs]</a>    <span class="k">def</span> <span class="nf">rm_indatadir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all the indata directories.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">rm_indatadir</span><span class="p">()</span></div>

<div class="viewcode-block" id="Work.rm_outdatadir"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.rm_outdatadir">[docs]</a>    <span class="k">def</span> <span class="nf">rm_outdatadir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all the indata directories.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">rm_outatadir</span><span class="p">()</span></div>

<div class="viewcode-block" id="Work.rm_tmpdatadir"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.rm_tmpdatadir">[docs]</a>    <span class="k">def</span> <span class="nf">rm_tmpdatadir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all the tmpdata directories.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">rm_tmpdatadir</span><span class="p">()</span></div>

<div class="viewcode-block" id="Work.move"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">isabspath</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively move self.workdir to another location. This is similar to the Unix &quot;mv&quot; command.</span>
<span class="sd">        The destination path must not already exist. If the destination already exists</span>
<span class="sd">        but is not a directory, it may be overwritten depending on os.rename() semantics.</span>

<span class="sd">        Be default, dest is located in the parent directory of self.workdir, use isabspath=True</span>
<span class="sd">        to specify an absolute path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isabspath</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">),</span> <span class="n">dest</span><span class="p">)</span>

        <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span></div>

<div class="viewcode-block" id="Work.submit_tasks"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.submit_tasks">[docs]</a>    <span class="k">def</span> <span class="nf">submit_tasks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Submits the task in self and wait.</span>
<span class="sd">        TODO: change name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">wait</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span> <span class="n">task</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span></div>

<div class="viewcode-block" id="Work.start"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start the work. Calls build and _setup first, then submit the tasks.</span>
<span class="sd">        Non-blocking call unless wait is set to True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wait</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;wait&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Initial setup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Build dirs and files.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Submit tasks (does not block)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">submit_tasks</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="n">wait</span><span class="p">)</span></div>

<div class="viewcode-block" id="Work.read_etotals"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.read_etotals">[docs]</a>    <span class="k">def</span> <span class="nf">read_etotals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;Ha&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the total energy from the GSR file produced by the task.</span>

<span class="sd">        Return a numpy array with the total energies in Hartree</span>
<span class="sd">        The array element is set to np.inf if an exception is raised while reading the GSR file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_done</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Some task is still in running/submitted state&quot;</span><span class="p">)</span>

        <span class="n">etotals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># Open the GSR file and read etotal (Hartree)</span>
            <span class="n">gsr_path</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;GSR&quot;</span><span class="p">)</span>
            <span class="n">etot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">if</span> <span class="n">gsr_path</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">ETSF_Reader</span><span class="p">(</span><span class="n">gsr_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">etot</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;etotal&quot;</span><span class="p">)</span>

            <span class="n">etotals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">etot</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">EnergyArray</span><span class="p">(</span><span class="n">etotals</span><span class="p">,</span> <span class="s2">&quot;Ha&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span></div>

<div class="viewcode-block" id="Work.parse_timers"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.Work.parse_timers">[docs]</a>    <span class="k">def</span> <span class="nf">parse_timers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the TIMER section reported in the ABINIT output files.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`AbinitTimerParser` object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filenames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">,</span> <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]))</span>

        <span class="n">parser</span> <span class="o">=</span> <span class="n">AbinitTimerParser</span><span class="p">()</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">parser</span></div></div>


<div class="viewcode-block" id="BandStructureWork"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.BandStructureWork">[docs]</a><span class="k">class</span> <span class="nc">BandStructureWork</span><span class="p">(</span><span class="n">Work</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Work for band structure calculations.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scf_input</span><span class="p">,</span> <span class="n">nscf_input</span><span class="p">,</span> <span class="n">dos_inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            scf_input: Input for the SCF run</span>
<span class="sd">            nscf_input: Input for the NSCF run defining the band structure calculation.</span>
<span class="sd">            dos_inputs: Input(s) for the DOS. DOS is computed only if dos_inputs is not None.</span>
<span class="sd">            workdir: Working directory.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BandStructureWork</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="c1"># Register the GS-SCF run.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scf_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_scf_task</span><span class="p">(</span><span class="n">scf_input</span><span class="p">)</span>

        <span class="c1"># Register the NSCF run and its dependency.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nscf_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_nscf_task</span><span class="p">(</span><span class="n">nscf_input</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;DEN&quot;</span><span class="p">})</span>

        <span class="c1"># Add DOS computation(s) if requested.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dos_tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">dos_inputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dos_inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">dos_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dos_inputs</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">dos_input</span> <span class="ow">in</span> <span class="n">dos_inputs</span><span class="p">:</span>
                <span class="n">dos_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_nscf_task</span><span class="p">(</span><span class="n">dos_input</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;DEN&quot;</span><span class="p">})</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dos_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dos_task</span><span class="p">)</span>

<div class="viewcode-block" id="BandStructureWork.plot_ebands"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.BandStructureWork.plot_ebands">[docs]</a>    <span class="k">def</span> <span class="nf">plot_ebands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the band structure. kwargs are passed to the plot method of :class:`ElectronBands`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `matplotlib` figure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">nscf_task</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gsr</span><span class="o">.</span><span class="n">ebands</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BandStructureWork.plot_ebands_with_edos"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.BandStructureWork.plot_ebands_with_edos">[docs]</a>    <span class="k">def</span> <span class="nf">plot_ebands_with_edos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dos_pos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the band structure and the DOS.</span>

<span class="sd">        Args:</span>
<span class="sd">            dos_pos: Index of the task from which the DOS should be obtained (note: 0 refers to the first DOS task).</span>
<span class="sd">            method: String defining the method for the computation of the DOS.</span>
<span class="sd">            step: Energy step (eV) of the linear mesh.</span>
<span class="sd">            width: Standard deviation (eV) of the gaussian.</span>
<span class="sd">            kwargs: Keyword arguments passed to `plot_with_edos` method to customize the plot.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `matplotlib` figure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">nscf_task</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="n">gs_ebands</span> <span class="o">=</span> <span class="n">gsr</span><span class="o">.</span><span class="n">ebands</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">dos_tasks</span><span class="p">[</span><span class="n">dos_pos</span><span class="p">]</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="n">dos_ebands</span> <span class="o">=</span> <span class="n">gsr</span><span class="o">.</span><span class="n">ebands</span>

        <span class="n">edos</span> <span class="o">=</span> <span class="n">dos_ebands</span><span class="o">.</span><span class="n">get_edos</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gs_ebands</span><span class="o">.</span><span class="n">plot_with_edos</span><span class="p">(</span><span class="n">edos</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BandStructureWork.plot_edoses"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.BandStructureWork.plot_edoses">[docs]</a>    <span class="k">def</span> <span class="nf">plot_edoses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dos_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the band structure and the DOS.</span>

<span class="sd">        Args:</span>
<span class="sd">            dos_pos: Index of the task from which the DOS should be obtained.</span>
<span class="sd">                     None is all DOSes should be displayed. Accepts integer or list of integers.</span>
<span class="sd">            method: String defining the method for the computation of the DOS.</span>
<span class="sd">            step: Energy step (eV) of the linear mesh.</span>
<span class="sd">            width: Standard deviation (eV) of the gaussian.</span>
<span class="sd">            kwargs: Keyword arguments passed to `plot` method to customize the plot.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `matplotlib` figure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dos_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dos_pos</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span> <span class="n">dos_pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">dos_pos</span><span class="p">]</span>

        <span class="kn">from</span> <span class="nn">abipy.electrons.ebands</span> <span class="k">import</span> <span class="n">ElectronDosPlotter</span>
        <span class="n">plotter</span> <span class="o">=</span> <span class="n">ElectronDosPlotter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dos_tasks</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dos_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dos_pos</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">with</span> <span class="n">task</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
                <span class="n">edos</span> <span class="o">=</span> <span class="n">gsr</span><span class="o">.</span><span class="n">ebands</span><span class="o">.</span><span class="n">get_edos</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>
                <span class="n">ngkpt</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">get_inpvar</span><span class="p">(</span><span class="s2">&quot;ngkpt&quot;</span><span class="p">)</span>
                <span class="n">plotter</span><span class="o">.</span><span class="n">add_edos</span><span class="p">(</span><span class="s2">&quot;ngkpt </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">ngkpt</span><span class="p">),</span> <span class="n">edos</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">plotter</span><span class="o">.</span><span class="n">combiplot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RelaxWork"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.RelaxWork">[docs]</a><span class="k">class</span> <span class="nc">RelaxWork</span><span class="p">(</span><span class="n">Work</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Work for structural relaxations. The first task relaxes the atomic position</span>
<span class="sd">    while keeping the unit cell parameters fixed. The second task uses the final</span>
<span class="sd">    structure to perform a structural relaxation in which both the atomic positions</span>
<span class="sd">    and the lattice parameters are optimized.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ion_input</span><span class="p">,</span> <span class="n">ioncell_input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_dilatmx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            ion_input: Input for the relaxation of the ions (cell is fixed)</span>
<span class="sd">            ioncell_input: Input for the relaxation of the ions and the unit cell.</span>
<span class="sd">            workdir: Working directory.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RelaxWork</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ion_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_relax_task</span><span class="p">(</span><span class="n">ion_input</span><span class="p">)</span>

        <span class="c1"># Note:</span>
        <span class="c1">#   1) It would be nice to restart from the WFK file but ABINIT crashes due to the</span>
        <span class="c1">#      different unit cell parameters if paral_kgb == 1</span>
        <span class="c1">#paral_kgb = ion_input[0][&quot;paral_kgb&quot;]</span>
        <span class="c1">#if paral_kgb == 1:</span>

        <span class="c1">#deps = {self.ion_task: &quot;WFK&quot;}  # --&gt; FIXME: Problem in rwwf</span>
        <span class="c1">#deps = {self.ion_task: &quot;DEN&quot;}</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ioncell_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_relax_task</span><span class="p">(</span><span class="n">ioncell_input</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>

        <span class="c1"># Lock ioncell_task as ion_task should communicate to ioncell_task that</span>
        <span class="c1"># the calculation is OK and pass the final structure.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ioncell_task</span><span class="o">.</span><span class="n">lock</span><span class="p">(</span><span class="n">source_node</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transfer_done</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target_dilatmx</span> <span class="o">=</span> <span class="n">target_dilatmx</span>

    <span class="c1">#@check_spectator</span>
<div class="viewcode-block" id="RelaxWork.on_ok"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.RelaxWork.on_ok">[docs]</a>    <span class="k">def</span> <span class="nf">on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This callback is called when one task reaches status S_OK.</span>
<span class="sd">        If sender == self.ion_task, we update the initial structure</span>
<span class="sd">        used by self.ioncell_task and we unlock it so that the job can be submitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;in on_ok with sender </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">sender</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sender</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ion_task</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">transfer_done</span><span class="p">:</span>
            <span class="c1"># Get the relaxed structure from ion_task</span>
            <span class="n">ion_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ion_task</span><span class="o">.</span><span class="n">get_final_structure</span><span class="p">()</span>

            <span class="c1"># Transfer it to the ioncell task (we do it only once).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ioncell_task</span><span class="o">.</span><span class="n">_change_structure</span><span class="p">(</span><span class="n">ion_structure</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transfer_done</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Unlock ioncell_task so that we can submit it.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ioncell_task</span><span class="o">.</span><span class="n">unlock</span><span class="p">(</span><span class="n">source_node</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">sender</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ioncell_task</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_dilatmx</span><span class="p">:</span>
            <span class="n">actual_dilatmx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ioncell_task</span><span class="o">.</span><span class="n">get_inpvar</span><span class="p">(</span><span class="s1">&#39;dilatmx&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_dilatmx</span> <span class="o">&lt;</span> <span class="n">actual_dilatmx</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ioncell_task</span><span class="o">.</span><span class="n">reduce_dilatmx</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">target_dilatmx</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Converging dilatmx. Value reduce from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">.&#39;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">actual_dilatmx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ioncell_task</span><span class="o">.</span><span class="n">get_inpvar</span><span class="p">(</span><span class="s1">&#39;dilatmx&#39;</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ioncell_task</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">RelaxWork</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">on_ok</span><span class="p">(</span><span class="n">sender</span><span class="p">)</span></div>

<div class="viewcode-block" id="RelaxWork.plot_ion_relaxation"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.RelaxWork.plot_ion_relaxation">[docs]</a>    <span class="k">def</span> <span class="nf">plot_ion_relaxation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the history of the ion-cell relaxation.</span>
<span class="sd">        kwargs are passed to the plot method of :class:`HistFile`</span>

<span class="sd">        Return `matplotlib` figure or None if hist file is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">ion_task</span><span class="o">.</span><span class="n">open_hist</span><span class="p">()</span> <span class="k">as</span> <span class="n">hist</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hist</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">hist</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="RelaxWork.plot_ioncell_relaxation"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.RelaxWork.plot_ioncell_relaxation">[docs]</a>    <span class="k">def</span> <span class="nf">plot_ioncell_relaxation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the history of the ion-cell relaxation.</span>
<span class="sd">        kwargs are passed to the plot method of :class:`HistFile`</span>

<span class="sd">        Return `matplotlib` figure or None if hist file is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">ioncell_task</span><span class="o">.</span><span class="n">open_hist</span><span class="p">()</span> <span class="k">as</span> <span class="n">hist</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hist</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">hist</span> <span class="k">else</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="G0W0Work"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.G0W0Work">[docs]</a><span class="k">class</span> <span class="nc">G0W0Work</span><span class="p">(</span><span class="n">Work</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Work for general G0W0 calculations.</span>
<span class="sd">    All input can be either single inputs or lists of inputs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scf_inputs</span><span class="p">,</span> <span class="n">nscf_inputs</span><span class="p">,</span> <span class="n">scr_inputs</span><span class="p">,</span> <span class="n">sigma_inputs</span><span class="p">,</span>
                 <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            scf_inputs: Input(s) for the SCF run, if it is a list add all but only link</span>
<span class="sd">                to the last input (used for convergence studies on the KS band gap)</span>
<span class="sd">            nscf_inputs: Input(s) for the NSCF run, if it is a list add all but only</span>
<span class="sd">                link to the last (i.e. addditiona DOS and BANDS)</span>
<span class="sd">            scr_inputs: Input for the screening run</span>
<span class="sd">            sigma_inputs: List of :class:AbinitInput`for the self-energy run.</span>
<span class="sd">                if scr and sigma are lists of the same length, every sigma gets its own screening.</span>
<span class="sd">                if there is only one screening all sigma inputs are linked to this one</span>
<span class="sd">            workdir: Working directory of the calculation.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">G0W0Work</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="n">spread_scr</span> <span class="o">=</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma_inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span>
                      <span class="nb">isinstance</span><span class="p">(</span><span class="n">scr_inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span>
                      <span class="nb">len</span><span class="p">(</span><span class="n">sigma_inputs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">scr_inputs</span><span class="p">))</span>
        <span class="c1">#print(&quot;spread_scr&quot;, spread_scr)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sigma_tasks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Register the GS-SCF run.</span>
        <span class="c1"># register all scf_inputs but link the nscf only the last scf in the list</span>
        <span class="c1"># multiple scf_inputs can be provided to perform convergence studies</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scf_inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">scf_input</span> <span class="ow">in</span> <span class="n">scf_inputs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scf_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_scf_task</span><span class="p">(</span><span class="n">scf_input</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scf_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_scf_task</span><span class="p">(</span><span class="n">scf_inputs</span><span class="p">)</span>

        <span class="c1"># Register the NSCF run (s).</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nscf_inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">nscf_input</span> <span class="ow">in</span> <span class="n">nscf_inputs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nscf_task</span> <span class="o">=</span> <span class="n">nscf_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_nscf_task</span><span class="p">(</span><span class="n">nscf_input</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;DEN&quot;</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nscf_task</span> <span class="o">=</span> <span class="n">nscf_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_nscf_task</span><span class="p">(</span><span class="n">nscf_inputs</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;DEN&quot;</span><span class="p">})</span>

        <span class="c1"># Register the SCR and SIGMA run(s).</span>
        <span class="k">if</span> <span class="n">spread_scr</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">scr_input</span><span class="p">,</span> <span class="n">sigma_input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">scr_inputs</span><span class="p">,</span> <span class="n">sigma_inputs</span><span class="p">):</span>
                <span class="n">scr_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_scr_task</span><span class="p">(</span><span class="n">scr_input</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">nscf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">})</span>
                <span class="n">sigma_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_sigma_task</span><span class="p">(</span><span class="n">sigma_input</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">nscf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">,</span> <span class="n">scr_task</span><span class="p">:</span> <span class="s2">&quot;SCR&quot;</span><span class="p">})</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sigma_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigma_task</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Sigma work(s) connected to the same screening.</span>
            <span class="n">scr_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_scr_task</span><span class="p">(</span><span class="n">scr_inputs</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">nscf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma_inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">sigma_inputs</span><span class="p">:</span>
                    <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_sigma_task</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">nscf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">,</span> <span class="n">scr_task</span><span class="p">:</span> <span class="s2">&quot;SCR&quot;</span><span class="p">})</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sigma_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_sigma_task</span><span class="p">(</span><span class="n">sigma_inputs</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">nscf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">,</span> <span class="n">scr_task</span><span class="p">:</span> <span class="s2">&quot;SCR&quot;</span><span class="p">})</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sigma_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="p">)</span></div>


<div class="viewcode-block" id="SigmaConvWork"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.SigmaConvWork">[docs]</a><span class="k">class</span> <span class="nc">SigmaConvWork</span><span class="p">(</span><span class="n">Work</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Work for self-energy convergence studies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wfk_node</span><span class="p">,</span> <span class="n">scr_node</span><span class="p">,</span> <span class="n">sigma_inputs</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            wfk_node: The node who has produced the WFK file or filepath pointing to the WFK file.</span>
<span class="sd">            scr_node: The node who has produced the SCR file or filepath pointing to the SCR file.</span>
<span class="sd">            sigma_inputs: List of :class:`AbinitInput` for the self-energy runs.</span>
<span class="sd">            workdir: Working directory of the calculation.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Cast to node instances.</span>
        <span class="n">wfk_node</span><span class="p">,</span> <span class="n">scr_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">wfk_node</span><span class="p">),</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">scr_node</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">SigmaConvWork</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="c1"># Register the SIGMA runs.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma_inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">sigma_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">sigma_inputs</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">sigma_input</span> <span class="ow">in</span> <span class="n">sigma_inputs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_sigma_task</span><span class="p">(</span><span class="n">sigma_input</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">wfk_node</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">,</span> <span class="n">scr_node</span><span class="p">:</span> <span class="s2">&quot;SCR&quot;</span><span class="p">})</span></div>


<div class="viewcode-block" id="BseMdfWork"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.BseMdfWork">[docs]</a><span class="k">class</span> <span class="nc">BseMdfWork</span><span class="p">(</span><span class="n">Work</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Work for simple BSE calculations in which the self-energy corrections</span>
<span class="sd">    are approximated by the scissors operator and the screening is modeled</span>
<span class="sd">    with the model dielectric function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scf_input</span><span class="p">,</span> <span class="n">nscf_input</span><span class="p">,</span> <span class="n">bse_inputs</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            scf_input: Input for the SCF run.</span>
<span class="sd">            nscf_input: Input for the NSCF run.</span>
<span class="sd">            bse_inputs: List of Inputs for the BSE run.</span>
<span class="sd">            workdir: Working directory of the calculation.</span>
<span class="sd">            manager: :class:`TaskManager`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BseMdfWork</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="c1"># Register the GS-SCF run.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scf_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_scf_task</span><span class="p">(</span><span class="n">scf_input</span><span class="p">)</span>

        <span class="c1"># Construct the input for the NSCF run.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nscf_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_nscf_task</span><span class="p">(</span><span class="n">nscf_input</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;DEN&quot;</span><span class="p">})</span>

        <span class="c1"># Construct the input(s) for the BSE run.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bse_inputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">bse_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bse_inputs</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">bse_input</span> <span class="ow">in</span> <span class="n">bse_inputs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_bse_task</span><span class="p">(</span><span class="n">bse_input</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nscf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">})</span>

<div class="viewcode-block" id="BseMdfWork.get_mdf_robot"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.BseMdfWork.get_mdf_robot">[docs]</a>    <span class="k">def</span> <span class="nf">get_mdf_robot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Builds and returns a :class:`MdfRobot` for analyzing the results in the MDF files.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abilab.robots</span> <span class="k">import</span> <span class="n">MdfRobot</span>
        <span class="n">robot</span> <span class="o">=</span> <span class="n">MdfRobot</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
            <span class="n">mdf_path</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">robot</span><span class="o">.</span><span class="n">EXT</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mdf_path</span><span class="p">:</span>
                <span class="n">robot</span><span class="o">.</span><span class="n">add_file</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">task</span><span class="p">),</span> <span class="n">mdf_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">robot</span></div></div>


<div class="viewcode-block" id="QptdmWork"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.QptdmWork">[docs]</a><span class="k">class</span> <span class="nc">QptdmWork</span><span class="p">(</span><span class="n">Work</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This work parallelizes the calculation of the q-points of the screening.</span>
<span class="sd">    It also provides the callback `on_all_ok` that calls mrgscr to merge</span>
<span class="sd">    all the partial screening files produced.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="QptdmWork.create_tasks"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.QptdmWork.create_tasks">[docs]</a>    <span class="k">def</span> <span class="nf">create_tasks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wfk_file</span><span class="p">,</span> <span class="n">scr_input</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the SCR tasks and register them in self.</span>

<span class="sd">        Args:</span>
<span class="sd">            wfk_file: Path to the ABINIT WFK file to use for the computation of the screening.</span>
<span class="sd">            scr_input: Input for the screening calculation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">wfk_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfk_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">wfk_file</span><span class="p">)</span>

        <span class="c1"># Build a temporary work in the tmpdir that will use a shell manager</span>
        <span class="c1"># to run ABINIT in order to get the list of q-points for the screening.</span>
        <span class="n">shell_manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">to_shell_manager</span><span class="p">(</span><span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">Work</span><span class="p">(</span><span class="n">workdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">path_join</span><span class="p">(</span><span class="s2">&quot;_qptdm_run&quot;</span><span class="p">),</span> <span class="n">manager</span><span class="o">=</span><span class="n">shell_manager</span><span class="p">)</span>

        <span class="n">fake_input</span> <span class="o">=</span> <span class="n">scr_input</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">fake_task</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">fake_input</span><span class="p">)</span>
        <span class="n">w</span><span class="o">.</span><span class="n">allocate</span><span class="p">()</span>
        <span class="n">w</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

        <span class="c1"># Create the symbolic link and add the magic value</span>
        <span class="c1"># nqpdm = -1 to the input to get the list of q-points.</span>
        <span class="n">fake_task</span><span class="o">.</span><span class="n">inlink_file</span><span class="p">(</span><span class="n">wfk_file</span><span class="p">)</span>
        <span class="n">fake_task</span><span class="o">.</span><span class="n">set_vars</span><span class="p">({</span><span class="s2">&quot;nqptdm&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">})</span>
        <span class="n">fake_task</span><span class="o">.</span><span class="n">start_and_wait</span><span class="p">()</span>

        <span class="c1"># Parse the section with the q-points</span>
        <span class="k">with</span> <span class="n">NetcdfReader</span><span class="p">(</span><span class="n">fake_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;qptdms.nc&quot;</span><span class="p">))</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
            <span class="n">qpoints</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="s2">&quot;reduced_coordinates_of_kpoints&quot;</span><span class="p">)</span>
        <span class="c1">#print(&quot;qpoints)</span>

        <span class="c1"># Now we can register the task for the different q-points</span>
        <span class="k">for</span> <span class="n">qpoint</span> <span class="ow">in</span> <span class="n">qpoints</span><span class="p">:</span>
            <span class="n">qptdm_input</span> <span class="o">=</span> <span class="n">scr_input</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">qptdm_input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">nqptdm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">qptdm</span><span class="o">=</span><span class="n">qpoint</span><span class="p">)</span>
            <span class="n">new_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_scr_task</span><span class="p">(</span><span class="n">qptdm_input</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="p">)</span>
            <span class="c1"># Add the garbage collector.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">gc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_task</span><span class="o">.</span><span class="n">set_gc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">gc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">allocate</span><span class="p">()</span></div>

<div class="viewcode-block" id="QptdmWork.merge_scrfiles"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.QptdmWork.merge_scrfiles">[docs]</a>    <span class="k">def</span> <span class="nf">merge_scrfiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_scrfiles</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when all the q-points have been computed.</span>
<span class="sd">        It runs `mrgscr` in sequential on the local machine to produce</span>
<span class="sd">        the final SCR file in the outdir of the `Work`.</span>
<span class="sd">        If remove_scrfiles is True, the partial SCR files are removed after the merge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scr_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;SCR&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Will call mrgscr to merge </span><span class="si">%s</span><span class="s2"> SCR files:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">scr_files</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">scr_files</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">mrgscr</span> <span class="o">=</span> <span class="n">wrappers</span><span class="o">.</span><span class="n">Mrgscr</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">manager</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">final_scr</span> <span class="o">=</span> <span class="n">mrgscr</span><span class="o">.</span><span class="n">merge_qpoints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">scr_files</span><span class="p">,</span> <span class="n">out_prefix</span><span class="o">=</span><span class="s2">&quot;out&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">remove_scrfiles</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">scr_file</span> <span class="ow">in</span> <span class="n">scr_files</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">scr_file</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">return</span> <span class="n">final_scr</span></div>

    <span class="c1">#@check_spectator</span>
<div class="viewcode-block" id="QptdmWork.on_all_ok"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.QptdmWork.on_all_ok">[docs]</a>    <span class="k">def</span> <span class="nf">on_all_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when all the q-points have been computed.</span>
<span class="sd">        It runs `mrgscr` in sequential on the local machine to produce</span>
<span class="sd">        the final SCR file in the outdir of the `Work`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">final_scr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_scrfiles</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Results</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">returncode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;mrgscr done&quot;</span><span class="p">,</span> <span class="n">final_scr</span><span class="o">=</span><span class="n">final_scr</span><span class="p">)</span></div></div>

<span class="c1"># TODO: MergeDdb --&gt; DfptWork(Work) postpone it because it may break pickle.</span>

<span class="k">class</span> <span class="nc">MergeDdb</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Mixin class for Works that have to merge the DDB files produced by the tasks.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_becs_from_scf_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scf_task</span><span class="p">,</span> <span class="n">ddk_tolerance</span><span class="p">,</span> <span class="n">ph_tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build tasks for the computation of Born effective charges and add them to the work.</span>

<span class="sd">        Args:</span>
<span class="sd">            scf_task: ScfTask object.</span>
<span class="sd">            ddk_tolerance: dict {&quot;varname&quot;: value} with the tolerance used in the DDK run.</span>
<span class="sd">                None to use AbiPy default.</span>
<span class="sd">            ph_tolerance: dict {&quot;varname&quot;: value} with the tolerance used in the phonon run.</span>
<span class="sd">                None to use AbiPy default.</span>

<span class="sd">	Return:</span>
<span class="sd">	    (ddk_tasks, bec_tasks)</span>
<span class="sd">	&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scf_task</span><span class="p">,</span> <span class="n">ScfTask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;task `</span><span class="si">%s</span><span class="s2">` does not inherit from ScfTask&quot;</span> <span class="o">%</span> <span class="n">scf_task</span><span class="p">)</span>

	<span class="c1"># DDK calculations (self-consistent to get electric field).</span>
        <span class="n">multi_ddk</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">make_ddk_inputs</span><span class="p">(</span><span class="n">tolerance</span><span class="o">=</span><span class="n">ddk_tolerance</span><span class="p">)</span>

        <span class="n">ddk_tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ddk_inp</span> <span class="ow">in</span> <span class="n">multi_ddk</span><span class="p">:</span>
            <span class="n">ddk_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_ddk_task</span><span class="p">(</span><span class="n">ddk_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">})</span>
            <span class="n">ddk_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ddk_task</span><span class="p">)</span>

        <span class="c1"># Build the list of inputs for electric field perturbation and phonons</span>
        <span class="c1"># Each BEC task is connected to all the previous DDK task and to the scf_task.</span>
        <span class="n">bec_deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">ddk_task</span><span class="p">:</span> <span class="s2">&quot;DDK&quot;</span> <span class="k">for</span> <span class="n">ddk_task</span> <span class="ow">in</span> <span class="n">ddk_tasks</span><span class="p">}</span>
        <span class="n">bec_deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">})</span>

        <span class="n">bec_inputs</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">make_bec_inputs</span><span class="p">(</span><span class="n">tolerance</span><span class="o">=</span><span class="n">ph_tolerance</span><span class="p">)</span>
        <span class="n">bec_tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bec_inp</span> <span class="ow">in</span> <span class="n">bec_inputs</span><span class="p">:</span>
             <span class="n">bec_task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_bec_task</span><span class="p">(</span><span class="n">bec_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">bec_deps</span><span class="p">)</span>
             <span class="n">bec_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bec_task</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ddk_tasks</span><span class="p">,</span> <span class="n">bec_tasks</span>

    <span class="k">def</span> <span class="nf">merge_ddb_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delete_source_ddbs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">only_dfpt_tasks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">exclude_tasks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_tasks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when all the q-points have been computed.</span>
<span class="sd">        It runs `mrgddb` in sequential on the local machine to produce</span>
<span class="sd">        the final DDB file in the outdir of the `Work`.</span>

<span class="sd">        Args:</span>
<span class="sd">            delete_source_ddbs: True if input DDB should be removed once final DDB is created.</span>
<span class="sd">            only_dfpt_tasks: False to merge all DDB files produced by the tasks of the work</span>
<span class="sd">                Useful e.g. for finite stress corrections in which the stress in the</span>
<span class="sd">                initial configuration should be merged in the final DDB.</span>
<span class="sd">            exclude_tasks: List of tasks that should be excluded when merging the partial DDB files.</span>
<span class="sd">            include_tasks: List of tasks that should be included when merging the partial DDB files.</span>
<span class="sd">                Mutually exclusive with exclude_tasks.</span>

<span class="sd">        Returns:</span>
<span class="sd">            path to the output DDB file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude_tasks</span><span class="p">:</span>
            <span class="n">my_tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">task</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_tasks</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">include_tasks</span><span class="p">:</span>
            <span class="n">my_tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">include_tasks</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">my_tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">only_dfpt_tasks</span><span class="p">:</span>
            <span class="n">ddb_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DDB&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">my_tasks</span> \
                                       <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">DfptTask</span><span class="p">)]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ddb_files</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="n">task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DDB&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">my_tasks</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Will call mrgddb to merge </span><span class="si">%s</span><span class="s2"> DDB files:&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">ddb_files</span><span class="p">))</span>
        <span class="c1"># DDB files are always produces so this should never happen!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ddb_files</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot find any DDB file to merge by the task of &quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Final DDB file will be produced in the outdir of the work.</span>
        <span class="n">out_ddb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;out_DDB&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ddb_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Avoid the merge. Just copy the DDB file to the outdir of the work.</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ddb_files</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_ddb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Call mrgddb</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="s2">&quot;DDB file merged by </span><span class="si">%s</span><span class="s2"> on </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>
            <span class="n">mrgddb</span> <span class="o">=</span> <span class="n">wrappers</span><span class="o">.</span><span class="n">Mrgddb</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">manager</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">mrgddb</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">ddb_files</span><span class="p">,</span> <span class="n">out_ddb</span><span class="o">=</span><span class="n">out_ddb</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span>
                         <span class="n">delete_source_ddbs</span><span class="o">=</span><span class="n">delete_source_ddbs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out_ddb</span>

    <span class="k">def</span> <span class="nf">merge_pot1_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delete_source</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when all the q-points have been computed.</span>
<span class="sd">        It runs `mrgdvdb` in sequential on the local machine to produce</span>
<span class="sd">        the final DVDB file in the outdir of the `Work`.</span>

<span class="sd">        Args:</span>
<span class="sd">            delete_source: True if POT1 files should be removed after (successful) merge.</span>

<span class="sd">        Returns:</span>
<span class="sd">            path to the output DVDB file. None if not DFPT POT file is found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">natom</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
        <span class="n">max_pertcase</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">natom</span>

        <span class="n">pot1_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">DfptTask</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">(</span><span class="n">wildcard</span><span class="o">=</span><span class="s2">&quot;*_POT*&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
                <span class="c1"># Include only atomic perturbations i.e. files whose ext &lt;= 3 * natom</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">rindex</span><span class="p">(</span><span class="s2">&quot;_POT&quot;</span><span class="p">)</span>
                <span class="n">pertcase</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">pertcase</span> <span class="o">&lt;=</span> <span class="n">max_pertcase</span><span class="p">:</span>
                    <span class="n">pot1_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># prtpot = 0 disables the output of the DFPT POT files so an empty list is not fatal here.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pot1_files</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Will call mrgdvdb to merge </span><span class="si">%s</span><span class="s2"> files:&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">pot1_files</span><span class="p">))</span>

        <span class="c1"># Final DDB file will be produced in the outdir of the work.</span>
        <span class="n">out_dvdb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;out_DVDB&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pot1_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Avoid the merge. Just move the DDB file to the outdir of the work</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pot1_files</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out_dvdb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># FIXME: The merge may require a non-negligible amount of memory if lots of qpts.</span>
            <span class="c1"># Besides there are machines such as lemaitre3 that are problematic when</span>
            <span class="c1"># running MPI applications on the front-end</span>
            <span class="n">mrgdvdb</span> <span class="o">=</span> <span class="n">wrappers</span><span class="o">.</span><span class="n">Mrgdvdb</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">manager</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">mrgdvdb</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">pot1_files</span><span class="p">,</span> <span class="n">out_dvdb</span><span class="p">,</span> <span class="n">delete_source</span><span class="o">=</span><span class="n">delete_source</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out_dvdb</span>


<div class="viewcode-block" id="PhononWork"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.PhononWork">[docs]</a><span class="k">class</span> <span class="nc">PhononWork</span><span class="p">(</span><span class="n">Work</span><span class="p">,</span> <span class="n">MergeDdb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This work consists of nirred Phonon tasks where nirred is</span>
<span class="sd">    the number of irreducible atomic perturbations for a given set of q-points.</span>
<span class="sd">    It provides the callback method (on_all_ok) that calls mrgddb (mrgdv) to merge</span>
<span class="sd">    all the partial DDB (POT) files produced. The two files are available in the</span>
<span class="sd">    output directory of the Work.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PhononWork.from_scf_task"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.PhononWork.from_scf_task">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_scf_task</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">scf_task</span><span class="p">,</span> <span class="n">qpoints</span><span class="p">,</span> <span class="n">is_ngqpt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_becs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">ddk_tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a `PhononWork` from a :class:`ScfTask` object.</span>
<span class="sd">        The input file for phonons is automatically generated from the input of the ScfTask.</span>
<span class="sd">        Each phonon task depends on the WFK file produced by the `scf_task`.</span>

<span class="sd">        Args:</span>
<span class="sd">            scf_task: ScfTask object.</span>
<span class="sd">            qpoints: q-points in reduced coordinates. Accepts single q-point, list of q-points</span>
<span class="sd">                or three integers defining the q-mesh if `is_ngqpt`.</span>
<span class="sd">            is_ngqpt: True if `qpoints` should be interpreted as divisions instead of q-points.</span>
<span class="sd">            tolerance: dict {&quot;varname&quot;: value} with the tolerance to be used in the phonon run.</span>
<span class="sd">                None to use AbiPy default.</span>
<span class="sd">            with_becs: Activate calculation of Electric field and Born effective charges.</span>
<span class="sd">            ddk_tolerance: dict {&quot;varname&quot;: value} with the tolerance used in the DDK run if with_becs.</span>
<span class="sd">                None to use AbiPy default.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scf_task</span><span class="p">,</span> <span class="n">ScfTask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;task `</span><span class="si">%s</span><span class="s2">` does not inherit from ScfTask&quot;</span> <span class="o">%</span> <span class="n">scf_task</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_ngqpt</span><span class="p">:</span>
            <span class="n">qpoints</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">abiget_ibz</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="n">qpoints</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">points</span>
        <span class="n">qpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">qpoints</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">with_becs</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">add_becs_from_scf_task</span><span class="p">(</span><span class="n">scf_task</span><span class="p">,</span> <span class="n">ddk_tolerance</span><span class="p">,</span> <span class="n">ph_tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">qpt</span> <span class="ow">in</span> <span class="n">qpoints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">with_becs</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qpt</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">multi</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">make_ph_inputs_qpoint</span><span class="p">(</span><span class="n">qpt</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ph_inp</span> <span class="ow">in</span> <span class="n">multi</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">register_phonon_task</span><span class="p">(</span><span class="n">ph_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="PhononWork.from_scf_input"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.PhononWork.from_scf_input">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_scf_input</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">scf_input</span><span class="p">,</span> <span class="n">qpoints</span><span class="p">,</span> <span class="n">is_ngqpt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">with_becs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ddk_tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to `from_scf_task`, the difference is that this method requires</span>
<span class="sd">        an input for SCF calculation. A new ScfTask is created and added to the Work.</span>
<span class="sd">        This API should be used if the DDB of the GS task should be merged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_ngqpt</span><span class="p">:</span>
            <span class="n">qpoints</span> <span class="o">=</span> <span class="n">scf_input</span><span class="o">.</span><span class="n">abiget_ibz</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="n">qpoints</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">points</span>

        <span class="n">qpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">qpoints</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="c1"># Create ScfTask</span>
        <span class="n">scf_task</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">register_scf_task</span><span class="p">(</span><span class="n">scf_input</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">with_becs</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">add_becs_from_scf_task</span><span class="p">(</span><span class="n">scf_task</span><span class="p">,</span> <span class="n">ddk_tolerance</span><span class="p">,</span> <span class="n">ph_tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">qpt</span> <span class="ow">in</span> <span class="n">qpoints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">with_becs</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qpt</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-12</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">multi</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">make_ph_inputs_qpoint</span><span class="p">(</span><span class="n">qpt</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ph_inp</span> <span class="ow">in</span> <span class="n">multi</span><span class="p">:</span>
                <span class="n">new</span><span class="o">.</span><span class="n">register_phonon_task</span><span class="p">(</span><span class="n">ph_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">new</span></div>

    <span class="c1">#@check_spectator</span>
<div class="viewcode-block" id="PhononWork.on_all_ok"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.PhononWork.on_all_ok">[docs]</a>    <span class="k">def</span> <span class="nf">on_all_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when all the q-points have been computed.</span>
<span class="sd">        Ir runs `mrgddb` in sequential on the local machine to produce</span>
<span class="sd">        the final DDB file in the outdir of the `Work`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Merge DDB files.</span>
        <span class="n">out_ddb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_ddb_files</span><span class="p">()</span>

        <span class="c1"># Merge DVDB files.</span>
        <span class="n">out_dvdb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_pot1_files</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Results</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">returncode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;DDB merge done&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PhononWfkqWork"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.PhononWfkqWork">[docs]</a><span class="k">class</span> <span class="nc">PhononWfkqWork</span><span class="p">(</span><span class="n">Work</span><span class="p">,</span> <span class="n">MergeDdb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This work computes phonons with DFPT on an arbitrary q-mesh (usually denser than the k-mesh for electrons)</span>
<span class="sd">    by computing WKQ files for each q-point.</span>
<span class="sd">    The number of irreducible atomic perturbations for each q-point are taken into account.</span>
<span class="sd">    It provides the callback method (on_all_ok) that calls mrgddb (mrgdv) to merge</span>
<span class="sd">    all the partial DDB (POT) files produced. The two files are available in the</span>
<span class="sd">    output directory of the Work. The WKQ files are removed at runtime.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PhononWfkqWork.from_scf_task"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.PhononWfkqWork.from_scf_task">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_scf_task</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">scf_task</span><span class="p">,</span> <span class="n">ngqpt</span><span class="p">,</span> <span class="n">ph_tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolwfr</span><span class="o">=</span><span class="mf">1.0e-22</span><span class="p">,</span> <span class="n">nband</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">with_becs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ddk_tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shiftq</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">is_ngqpt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">remove_wfkq</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a `PhononWfkqWork` from a :class:`ScfTask` object.</span>
<span class="sd">        The input files for WFQ and phonons are automatically generated from the input of the ScfTask.</span>
<span class="sd">        Each phonon task depends on the WFK file produced by scf_task and the associated WFQ file.</span>

<span class="sd">        Args:</span>
<span class="sd">            scf_task: ScfTask object.</span>
<span class="sd">            ngqpt: three integers defining the q-mesh</span>
<span class="sd">            with_becs: Activate calculation of Electric field and Born effective charges.</span>
<span class="sd">            ph_tolerance: dict {&quot;varname&quot;: value} with the tolerance for the phonon run.</span>
<span class="sd">                None to use AbiPy default.</span>
<span class="sd">            tolwfr: tolerance used to compute WFQ.</span>
<span class="sd">            ddk_tolerance: dict {&quot;varname&quot;: value} with the tolerance used in the DDK run if with_becs.</span>
<span class="sd">                None to use AbiPy default.</span>
<span class="sd">            shiftq: Q-mesh shift. Multiple shifts are not supported.</span>
<span class="sd">            is_ngqpt: the ngqpt is interpreted as a set of integers defining the q-mesh, otherwise</span>
<span class="sd">                      is an explicit list of q-points</span>
<span class="sd">            remove_wfkq: Remove WKQ files when the children are completed.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>

<span class="sd">        .. note:</span>

<span class="sd">            Use k-meshes with one shift and q-meshes that are multiple of ngkpt</span>
<span class="sd">            to decrease the number of WFQ files to be computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scf_task</span><span class="p">,</span> <span class="n">ScfTask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;task `</span><span class="si">%s</span><span class="s2">` does not inherit from ScfTask&quot;</span> <span class="o">%</span> <span class="n">scf_task</span><span class="p">)</span>

        <span class="n">shiftq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shiftq</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">is_ngqpt</span><span class="p">:</span>
            <span class="n">qpoints</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">abiget_ibz</span><span class="p">(</span><span class="n">ngkpt</span><span class="o">=</span><span class="n">ngqpt</span><span class="p">,</span> <span class="n">shiftk</span><span class="o">=</span><span class="n">shiftq</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">points</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qpoints</span> <span class="o">=</span> <span class="n">ngqpt</span>

        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">remove_wfkq</span> <span class="o">=</span> <span class="n">remove_wfkq</span>
        <span class="n">new</span><span class="o">.</span><span class="n">wfkq_tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new</span><span class="o">.</span><span class="n">wfkq_task_children</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">with_becs</span><span class="p">:</span>
            <span class="c1"># Add DDK and BECS.</span>
            <span class="n">new</span><span class="o">.</span><span class="n">add_becs_from_scf_task</span><span class="p">(</span><span class="n">scf_task</span><span class="p">,</span> <span class="n">ddk_tolerance</span><span class="p">,</span> <span class="n">ph_tolerance</span><span class="p">)</span>

        <span class="c1"># Get ngkpt, shift for electrons from input.</span>
        <span class="c1"># Won&#39;t try to skip WFQ if multiple shifts or off-diagonal kptrlatt</span>
        <span class="n">ngkpt</span><span class="p">,</span> <span class="n">shiftk</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get_ngkpt_shiftk</span><span class="p">()</span>
        <span class="n">try_to_skip_wfkq</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">ngkpt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">shiftk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">is_ngqpt</span><span class="p">:</span>
            <span class="n">try_to_skip_wfkq</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># TODO: One could avoid kptopt 3 by computing WFK in the IBZ and then rotating.</span>
        <span class="c1"># but this has to be done inside Abinit.</span>
        <span class="k">for</span> <span class="n">qpt</span> <span class="ow">in</span> <span class="n">qpoints</span><span class="p">:</span>
            <span class="n">is_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qpt</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-12</span>
            <span class="k">if</span> <span class="n">with_becs</span> <span class="ow">and</span> <span class="n">is_gamma</span><span class="p">:</span> <span class="k">continue</span>

            <span class="c1"># Avoid WFQ if k + q = k (requires ngkpt, multiple shifts are not supported)</span>
            <span class="n">need_wfkq</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">is_gamma</span><span class="p">:</span>
                <span class="n">need_wfkq</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">try_to_skip_wfkq</span><span class="p">:</span>
                <span class="c1"># k = (i + shiftk) / ngkpt</span>
                <span class="n">qinds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">qpt</span> <span class="o">*</span> <span class="n">ngqpt</span> <span class="o">-</span> <span class="n">shiftq</span><span class="p">)</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">qinds</span> <span class="o">*</span> <span class="n">ngkpt</span><span class="p">)</span> <span class="o">%</span> <span class="n">ngqpt</span>
                <span class="n">need_wfkq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">f</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">need_wfkq</span><span class="p">:</span>
                <span class="n">nscf_inp</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">new_with_vars</span><span class="p">(</span><span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">,</span> <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">tolwfr</span><span class="o">=</span><span class="n">tolwfr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nband</span><span class="p">:</span>
                    <span class="n">nbdbuf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">nband</span><span class="o">*</span><span class="mf">0.1</span><span class="p">)</span>
                    <span class="n">nscf_inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">nband</span><span class="o">=</span><span class="n">nband</span><span class="o">+</span><span class="n">nbdbuf</span><span class="p">,</span> <span class="n">nbdbuf</span><span class="o">=</span><span class="n">nbdbuf</span><span class="p">)</span>
                <span class="n">wfkq_task</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">register_nscf_task</span><span class="p">(</span><span class="n">nscf_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">scf_task</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;DEN&quot;</span><span class="p">,</span> <span class="s2">&quot;WFK&quot;</span><span class="p">]})</span>
                <span class="n">new</span><span class="o">.</span><span class="n">wfkq_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfkq_task</span><span class="p">)</span>

            <span class="n">multi</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">make_ph_inputs_qpoint</span><span class="p">(</span><span class="n">qpt</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">ph_tolerance</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ph_inp</span> <span class="ow">in</span> <span class="n">multi</span><span class="p">:</span>
                <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">,</span> <span class="n">wfkq_task</span><span class="p">:</span> <span class="s2">&quot;WFQ&quot;</span><span class="p">}</span> <span class="k">if</span> <span class="n">need_wfkq</span> <span class="k">else</span> <span class="p">{</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">}</span>
                <span class="c1">#ph_inp[&quot;prtwf&quot;] = -1</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">register_phonon_task</span><span class="p">(</span><span class="n">ph_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">need_wfkq</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">wfkq_task_children</span><span class="p">[</span><span class="n">wfkq_task</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="PhononWfkqWork.on_ok"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.PhononWfkqWork.on_ok">[docs]</a>    <span class="k">def</span> <span class="nf">on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This callback is called when one task reaches status `S_OK`.</span>
<span class="sd">        It removes the WFKQ file if all its children have reached `S_OK`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_wfkq</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfkq_tasks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">task</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfkq_task_children</span><span class="p">[</span><span class="n">task</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">child</span><span class="o">.</span><span class="n">S_OK</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">):</span>
                   <span class="n">path</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;WFQ&quot;</span><span class="p">)</span>
                   <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Removing WFQ: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">path</span><span class="p">)</span>
                       <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">PhononWfkqWork</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">on_ok</span><span class="p">(</span><span class="n">sender</span><span class="p">)</span></div>

    <span class="c1">#@check_spectator</span>
<div class="viewcode-block" id="PhononWfkqWork.on_all_ok"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.PhononWfkqWork.on_all_ok">[docs]</a>    <span class="k">def</span> <span class="nf">on_all_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when all the q-points have been computed.</span>
<span class="sd">        Ir runs `mrgddb` in sequential on the local machine to produce</span>
<span class="sd">        the final DDB file in the outdir of the `Work`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Merge DDB files.</span>
        <span class="n">out_ddb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_ddb_files</span><span class="p">()</span>

        <span class="c1"># Merge DVDB files.</span>
        <span class="n">out_dvdb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_pot1_files</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Results</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">returncode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;DDB merge done&quot;</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="GKKPWork"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.GKKPWork">[docs]</a><span class="k">class</span> <span class="nc">GKKPWork</span><span class="p">(</span><span class="n">Work</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This work computes electron-phonon matrix elements for all the q-points</span>
<span class="sd">    present in a DVDB and DDB file</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="GKKPWork.from_den_ddb_dvdb"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.GKKPWork.from_den_ddb_dvdb">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_den_ddb_dvdb</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">den_path</span><span class="p">,</span> <span class="n">ddb_path</span><span class="p">,</span> <span class="n">dvdb_path</span><span class="p">,</span> <span class="n">mpiprocs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">remove_wfkq</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">qpath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_ddk</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a `PhononWfkqWork` from a DDB and DVDB file.</span>
<span class="sd">        For each q found, a WFQ task and an EPH task computing the matrix elements are created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">abipy.abilab</span> <span class="k">as</span> <span class="nn">abilab</span>

        <span class="c1"># Create file nodes</span>
        <span class="n">den_file</span> <span class="o">=</span> <span class="n">FileNode</span><span class="p">(</span><span class="n">den_path</span><span class="p">)</span>
        <span class="n">ddb_file</span> <span class="o">=</span> <span class="n">FileNode</span><span class="p">(</span><span class="n">ddb_path</span><span class="p">)</span>
        <span class="n">dvdb_file</span> <span class="o">=</span> <span class="n">FileNode</span><span class="p">(</span><span class="n">dvdb_path</span><span class="p">)</span>

        <span class="c1"># Create new work</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">remove_wfkq</span> <span class="o">=</span> <span class="n">remove_wfkq</span>
        <span class="n">new</span><span class="o">.</span><span class="n">wfkq_tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new</span><span class="o">.</span><span class="n">wfkq_task_children</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">TaskManager</span><span class="o">.</span><span class="n">from_user_config</span><span class="p">()</span>
        <span class="n">tm</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">new_with_fixed_mpi_omp</span><span class="p">(</span><span class="n">mpiprocs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create a WFK task</span>
        <span class="n">kptopt</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">expand</span> <span class="k">else</span> <span class="mi">3</span>
        <span class="n">nscf_inp</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">new_with_vars</span><span class="p">(</span><span class="n">iscf</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">)</span>
        <span class="n">wfk_task</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">register_nscf_task</span><span class="p">(</span><span class="n">nscf_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">den_file</span><span class="p">:</span> <span class="s2">&quot;DEN&quot;</span><span class="p">},</span><span class="n">manager</span><span class="o">=</span><span class="n">tm</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">wfkq_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfk_task</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">wfk_task</span> <span class="o">=</span> <span class="n">wfk_task</span>

        <span class="c1"># Read path and regular grid from DDB file</span>
        <span class="k">with</span> <span class="n">abilab</span><span class="o">.</span><span class="n">abiopen</span><span class="p">(</span><span class="n">ddb_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">ddb</span><span class="p">:</span>
            <span class="n">q_frac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ddb</span><span class="o">.</span><span class="n">qpoints</span><span class="p">])</span>
            <span class="n">ddb_ngqpt</span> <span class="o">=</span> <span class="n">ddb</span><span class="o">.</span><span class="n">guessed_ngqpt</span>

        <span class="c1"># If qpath is set, we read the list of q-points to be used to interpolate the DVDB file.</span>
        <span class="c1"># The DVDB and DDB file have to correspond to a regular grid.</span>
        <span class="n">dvdb</span> <span class="o">=</span> <span class="n">dvdb_file</span>
        <span class="k">if</span> <span class="n">qpath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qpath</span> <span class="o">=</span> <span class="n">q_frac_coords</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">interp_inp</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">new_with_vars</span><span class="p">(</span><span class="n">optdriver</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">eph_task</span><span class="o">=-</span><span class="mi">5</span><span class="p">,</span> <span class="n">ddb_ngqpt</span><span class="o">=</span><span class="n">ddb_ngqpt</span><span class="p">,</span>
                                           <span class="n">ph_nqpath</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">qpath</span><span class="p">),</span> <span class="n">ph_qpath</span><span class="o">=</span><span class="n">qpath</span><span class="p">,</span> <span class="n">prtphdos</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">dvdb</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">register_eph_task</span><span class="p">(</span><span class="n">interp_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">wfk_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">,</span> <span class="n">ddb_file</span><span class="p">:</span> <span class="s2">&quot;DDB&quot;</span><span class="p">,</span> <span class="n">dvdb_file</span><span class="p">:</span> <span class="s2">&quot;DVDB&quot;</span><span class="p">},</span>
                                          <span class="n">manager</span><span class="o">=</span><span class="n">tm</span><span class="p">)</span>

        <span class="c1"># Create a WFK expansion task</span>
        <span class="k">if</span> <span class="n">expand</span><span class="p">:</span>
            <span class="n">fbz_nscf_inp</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">new_with_vars</span><span class="p">(</span><span class="n">optdriver</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
            <span class="n">fbz_nscf_inp</span><span class="o">.</span><span class="n">set_spell_check</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">fbz_nscf_inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">wfk_task</span><span class="o">=</span><span class="s2">&quot;wfk_fullbz&quot;</span><span class="p">)</span>
            <span class="n">tm_serial</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">new_with_fixed_mpi_omp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">wfk_task</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">register_nscf_task</span><span class="p">(</span><span class="n">fbz_nscf_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">wfk_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">,</span> <span class="n">den_file</span><span class="p">:</span> <span class="s2">&quot;DEN&quot;</span><span class="p">},</span>
                                              <span class="n">manager</span><span class="o">=</span><span class="n">tm_serial</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">wfkq_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfk_task</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">wfk_task</span> <span class="o">=</span> <span class="n">wfk_task</span>

        <span class="k">if</span> <span class="n">with_ddk</span><span class="p">:</span>
            <span class="n">kptopt</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">expand</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">ddk_inp</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">new_with_vars</span><span class="p">(</span><span class="n">optdriver</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">kptopt</span><span class="o">=</span><span class="n">kptopt</span><span class="p">)</span>
            <span class="n">ddk_inp</span><span class="o">.</span><span class="n">set_spell_check</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ddk_inp</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">wfk_task</span><span class="o">=</span><span class="s2">&quot;wfk_ddk&quot;</span><span class="p">)</span>
            <span class="n">ddk_task</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">register_nscf_task</span><span class="p">(</span><span class="n">ddk_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">wfk_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">,</span> <span class="n">den_file</span><span class="p">:</span> <span class="s2">&quot;DEN&quot;</span><span class="p">},</span> <span class="n">manager</span><span class="o">=</span><span class="n">tm</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">wfkq_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ddk_task</span><span class="p">)</span>

        <span class="c1"># For each qpoint</span>
        <span class="k">for</span> <span class="n">qpt</span> <span class="ow">in</span> <span class="n">qpath</span><span class="p">:</span>
            <span class="n">is_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">qpt</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-12</span>
            <span class="k">if</span> <span class="n">is_gamma</span><span class="p">:</span>
                <span class="c1"># Create a link from WFK to WFQ on_ok</span>
                <span class="n">wfkq_task</span> <span class="o">=</span> <span class="n">wfk_task</span>
                <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">wfk_task</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;WFK&quot;</span><span class="p">,</span><span class="s2">&quot;WFQ&quot;</span><span class="p">],</span> <span class="n">ddb_file</span><span class="p">:</span> <span class="s2">&quot;DDB&quot;</span><span class="p">,</span> <span class="n">dvdb</span><span class="p">:</span> <span class="s2">&quot;DVDB&quot;</span> <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Create a WFQ task</span>
                <span class="n">nscf_inp</span> <span class="o">=</span> <span class="n">nscf_inp</span><span class="o">.</span><span class="n">new_with_vars</span><span class="p">(</span><span class="n">kptopt</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">,</span> <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">wfkq_task</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">register_nscf_task</span><span class="p">(</span><span class="n">nscf_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">den_file</span><span class="p">:</span> <span class="s2">&quot;DEN&quot;</span><span class="p">},</span> <span class="n">manager</span><span class="o">=</span><span class="n">tm</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">wfkq_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wfkq_task</span><span class="p">)</span>
                <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">wfk_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">,</span> <span class="n">wfkq_task</span><span class="p">:</span> <span class="s2">&quot;WFQ&quot;</span><span class="p">,</span> <span class="n">ddb_file</span><span class="p">:</span> <span class="s2">&quot;DDB&quot;</span><span class="p">,</span> <span class="n">dvdb</span><span class="p">:</span> <span class="s2">&quot;DVDB&quot;</span> <span class="p">}</span>

            <span class="c1"># Create a EPH task</span>
            <span class="n">eph_inp</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">new_with_vars</span><span class="p">(</span><span class="n">optdriver</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">prtphdos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">eph_task</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">kptopt</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                        <span class="n">ddb_ngqpt</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">register_eph_task</span><span class="p">(</span><span class="n">eph_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">tm</span><span class="p">)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">wfkq_task_children</span><span class="p">[</span><span class="n">wfkq_task</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="GKKPWork.from_phononwfkq_work"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.GKKPWork.from_phononwfkq_work">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_phononwfkq_work</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">phononwfkq_work</span><span class="p">,</span> <span class="n">nscf_vars</span><span class="o">=</span><span class="p">{},</span> <span class="n">remove_wfkq</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_ddk</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a `GKKPWork` from a `PhononWfkqWork` object.</span>
<span class="sd">        The WFQ are the ones used for PhononWfkqWork so in principle have only valence bands</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get list of qpoints from the the phonon tasks in this work</span>
        <span class="n">qpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">qpoints_deps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">phononwfkq_work</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">task</span><span class="p">,</span><span class="n">PhononTask</span><span class="p">):</span>
                <span class="c1"># Store qpoints</span>
                <span class="n">qpt</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;qpt&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">qpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qpt</span><span class="p">)</span>
                <span class="c1"># Store dependencies</span>
                <span class="n">qpoints_deps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">deps</span><span class="p">)</span>

        <span class="c1"># Create file nodes</span>
        <span class="n">ddb_path</span>  <span class="o">=</span> <span class="n">phononwfkq_work</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DDB&quot;</span><span class="p">)</span>
        <span class="n">dvdb_path</span> <span class="o">=</span> <span class="n">phononwfkq_work</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DVDB&quot;</span><span class="p">)</span>
        <span class="n">ddb_file</span> <span class="o">=</span> <span class="n">FileNode</span><span class="p">(</span><span class="n">ddb_path</span><span class="p">)</span>
        <span class="n">dvdb_file</span> <span class="o">=</span> <span class="n">FileNode</span><span class="p">(</span><span class="n">dvdb_path</span><span class="p">)</span>

        <span class="c1"># Get scf_task from first q-point</span>
        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">qpoints_deps</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dep</span><span class="o">.</span><span class="n">node</span><span class="p">,</span><span class="n">ScfTask</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dep</span><span class="o">.</span><span class="n">exts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;WFK&#39;</span><span class="p">:</span>
                <span class="n">scf_task</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">node</span>

        <span class="c1"># Create new work</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">remove_wfkq</span> <span class="o">=</span> <span class="n">remove_wfkq</span>
        <span class="n">new</span><span class="o">.</span><span class="n">wfkq_tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new</span><span class="o">.</span><span class="n">wfk_task</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Add one eph task per qpoint</span>
        <span class="k">for</span> <span class="n">qpt</span><span class="p">,</span><span class="n">qpoint_deps</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">qpoints</span><span class="p">,</span><span class="n">qpoints_deps</span><span class="p">):</span>
            <span class="c1"># Create eph task</span>
            <span class="n">eph_input</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">new_with_vars</span><span class="p">(</span><span class="n">optdriver</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">prtphdos</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">eph_task</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span>
                                                     <span class="n">ddb_ngqpt</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">nqpt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">qpt</span><span class="o">=</span><span class="n">qpt</span><span class="p">)</span>
            <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">ddb_file</span><span class="p">:</span> <span class="s2">&quot;DDB&quot;</span><span class="p">,</span> <span class="n">dvdb_file</span><span class="p">:</span> <span class="s2">&quot;DVDB&quot;</span> <span class="p">}</span>
            <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">qpoint_deps</span><span class="p">:</span>
                <span class="n">deps</span><span class="p">[</span><span class="n">dep</span><span class="o">.</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">exts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># If no WFQ in deps link the WFK with WFQ extension</span>
            <span class="k">if</span> <span class="s1">&#39;WFQ&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">deps</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">inv_deps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">deps</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                <span class="n">wfk_task</span> <span class="o">=</span> <span class="n">inv_deps</span><span class="p">[</span><span class="s1">&#39;WFK&#39;</span><span class="p">]</span>
                <span class="n">wfk_path</span> <span class="o">=</span> <span class="n">wfk_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;WFK&quot;</span><span class="p">)</span>
                <span class="c1"># Check if netcdf</span>
                <span class="n">filename</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">wfk_path</span><span class="p">)</span>
                <span class="n">infile</span> <span class="o">=</span> <span class="s1">&#39;out_WFQ&#39;</span> <span class="o">+</span> <span class="n">extension</span>
                <span class="n">wfq_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">wfk_path</span><span class="p">),</span> <span class="n">infile</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">wfq_path</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">wfk_path</span><span class="p">,</span> <span class="n">wfq_path</span><span class="p">)</span>
                <span class="n">deps</span><span class="p">[</span><span class="n">FileNode</span><span class="p">(</span><span class="n">wfq_path</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;WFQ&#39;</span>
            <span class="n">new</span><span class="o">.</span><span class="n">register_eph_task</span><span class="p">(</span><span class="n">eph_input</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="GKKPWork.on_ok"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.GKKPWork.on_ok">[docs]</a>    <span class="k">def</span> <span class="nf">on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sender</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This callback is called when one task reaches status `S_OK`.</span>
<span class="sd">        It removes the WFKQ file if all its children have reached `S_OK`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_wfkq</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfkq_tasks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="n">task</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfkq_task_children</span><span class="p">[</span><span class="n">task</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">child</span><span class="o">.</span><span class="n">S_OK</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">):</span>
                   <span class="n">path</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;WFQ&quot;</span><span class="p">)</span>
                   <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Removing WFQ: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">path</span><span class="p">)</span>
                       <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># If wfk task we create a link to a wfq file so abinit is happy</span>
        <span class="k">if</span> <span class="n">sender</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfk_task</span><span class="p">:</span>
            <span class="n">wfk_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfk_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;WFK&quot;</span><span class="p">)</span>
            <span class="c1"># Check if netcdf</span>
            <span class="n">filename</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">wfk_path</span><span class="p">)</span>
            <span class="n">infile</span> <span class="o">=</span> <span class="s1">&#39;out_WFQ&#39;</span> <span class="o">+</span> <span class="n">extension</span>
            <span class="n">infile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">wfk_path</span><span class="p">),</span> <span class="n">infile</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">wfk_path</span><span class="p">,</span> <span class="n">infile</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">GKKPWork</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">on_ok</span><span class="p">(</span><span class="n">sender</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BecWork"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.BecWork">[docs]</a><span class="k">class</span> <span class="nc">BecWork</span><span class="p">(</span><span class="n">Work</span><span class="p">,</span> <span class="n">MergeDdb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Work for the computation of the Born effective charges.</span>

<span class="sd">    This work consists of DDK tasks and phonon + electric field perturbation</span>
<span class="sd">    It provides the callback method (on_all_ok) that calls mrgddb to merge the</span>
<span class="sd">    partial DDB files produced by the work.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BecWork.from_scf_task"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.BecWork.from_scf_task">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_scf_task</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">scf_task</span><span class="p">,</span> <span class="n">ddk_tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ph_tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build tasks for the computation of Born effective charges from a ground-state task.</span>

<span class="sd">        Args:</span>
<span class="sd">            scf_task: ScfTask object.</span>
<span class="sd">            ddk_tolerance: tolerance used in the DDK run if with_becs. None to use AbiPy default.</span>
<span class="sd">            ph_tolerance: dict {&quot;varname&quot;: value} with the tolerance used in the phonon run.</span>
<span class="sd">                None to use AbiPy default.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">	&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">add_becs_from_scf_task</span><span class="p">(</span><span class="n">scf_task</span><span class="p">,</span> <span class="n">ddk_tolerance</span><span class="p">,</span> <span class="n">ph_tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="BecWork.on_all_ok"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.BecWork.on_all_ok">[docs]</a>    <span class="k">def</span> <span class="nf">on_all_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when all tasks reach S_OK</span>
<span class="sd">        Ir runs `mrgddb` in sequential on the local machine to produce</span>
<span class="sd">        the final DDB file in the outdir of the `Work`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Merge DDB files.</span>
        <span class="n">out_ddb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_ddb_files</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Results</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">returncode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;DDB merge done&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DteWork"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.DteWork">[docs]</a><span class="k">class</span> <span class="nc">DteWork</span><span class="p">(</span><span class="n">Work</span><span class="p">,</span> <span class="n">MergeDdb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Work for the computation of the third derivative of the energy.</span>

<span class="sd">    This work consists of DDK tasks and electric field perturbation.</span>
<span class="sd">    It provides the callback method (on_all_ok) that calls mrgddb to merge the partial DDB files produced</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="DteWork.from_scf_task"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.DteWork.from_scf_task">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_scf_task</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">scf_task</span><span class="p">,</span> <span class="n">ddk_tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Build a DteWork from a ground-state task.</span>

<span class="sd">        Args:</span>
<span class="sd">            scf_task: ScfTask object.</span>
<span class="sd">            ddk_tolerance: tolerance used in the DDK run if with_becs. None to use AbiPy default.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">	&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scf_task</span><span class="p">,</span> <span class="n">ScfTask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;task `</span><span class="si">%s</span><span class="s2">` does not inherit from ScfTask&quot;</span> <span class="o">%</span> <span class="n">scf_task</span><span class="p">)</span>

        <span class="n">new</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="c1"># DDK calculations</span>
        <span class="n">multi_ddk</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">make_ddk_inputs</span><span class="p">(</span><span class="n">tolerance</span><span class="o">=</span><span class="n">ddk_tolerance</span><span class="p">)</span>

        <span class="n">ddk_tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ddk_inp</span> <span class="ow">in</span> <span class="n">multi_ddk</span><span class="p">:</span>
            <span class="n">ddk_task</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">register_ddk_task</span><span class="p">(</span><span class="n">ddk_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="p">{</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">})</span>
            <span class="n">ddk_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ddk_task</span><span class="p">)</span>

        <span class="c1"># Build the list of inputs for electric field perturbation</span>
        <span class="c1"># Each task is connected to all the previous DDK, DDE task and to the scf_task.</span>
        <span class="n">multi_dde</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">make_dde_inputs</span><span class="p">(</span><span class="n">use_symmetries</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># To compute the nonlinear coefficients all the directions of the perturbation</span>
        <span class="c1"># have to be taken in consideration</span>
        <span class="c1"># DDE calculations</span>
        <span class="n">dde_tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dde_deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">ddk_task</span><span class="p">:</span> <span class="s2">&quot;DDK&quot;</span> <span class="k">for</span> <span class="n">ddk_task</span> <span class="ow">in</span> <span class="n">ddk_tasks</span><span class="p">}</span>
        <span class="n">dde_deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">dde_inp</span> <span class="ow">in</span> <span class="n">multi_dde</span><span class="p">:</span>
            <span class="n">dde_task</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">register_dde_task</span><span class="p">(</span><span class="n">dde_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">dde_deps</span><span class="p">)</span>
            <span class="n">dde_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dde_task</span><span class="p">)</span>

        <span class="c1"># DTE calculations</span>
        <span class="n">dte_deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">scf_task</span><span class="p">:</span> <span class="s2">&quot;WFK DEN&quot;</span><span class="p">}</span>
        <span class="n">dte_deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">dde_task</span><span class="p">:</span> <span class="s2">&quot;1WF 1DEN&quot;</span> <span class="k">for</span> <span class="n">dde_task</span> <span class="ow">in</span> <span class="n">dde_tasks</span><span class="p">})</span>

        <span class="n">multi_dte</span> <span class="o">=</span> <span class="n">scf_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">make_dte_inputs</span><span class="p">()</span>
        <span class="n">dte_tasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dte_inp</span> <span class="ow">in</span> <span class="n">multi_dte</span><span class="p">:</span>
             <span class="n">dte_task</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">register_dte_task</span><span class="p">(</span><span class="n">dte_inp</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">dte_deps</span><span class="p">)</span>
             <span class="n">dte_tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dte_task</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="DteWork.on_all_ok"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.works.html#pymatgen.io.abinit.works.DteWork.on_all_ok">[docs]</a>    <span class="k">def</span> <span class="nf">on_all_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when all tasks reach S_OK</span>
<span class="sd">        Ir runs `mrgddb` in sequential on the local machine to produce</span>
<span class="sd">        the final DDB file in the outdir of the `Work`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Merge DDB files.</span>
        <span class="n">out_ddb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_ddb_files</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Results</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">returncode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;DDB merge done&quot;</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 2019.1.24 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../pymatgen.html" >pymatgen</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2011, Pymatgen Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>