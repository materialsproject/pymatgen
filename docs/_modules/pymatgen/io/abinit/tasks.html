
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pymatgen.io.abinit.tasks &#8212; pymatgen 2018.9.12 documentation</title>
    <link rel="stylesheet" href="../../../../_static/proBlue.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 2018.9.12 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../pymatgen.html" accesskey="U">pymatgen</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.io.abinit.tasks</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="c1"># Copyright (c) Pymatgen Development Team.</span>
<span class="c1"># Distributed under the terms of the MIT License.</span>
<span class="sd">&quot;&quot;&quot;This module provides functions and classes related to Task objects.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">ruamel.yaml</span> <span class="k">as</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pprint</span> <span class="k">import</span> <span class="n">pprint</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="n">StringIO</span>
<span class="kn">from</span> <span class="nn">monty.string</span> <span class="k">import</span> <span class="n">is_string</span><span class="p">,</span> <span class="n">list_strings</span>
<span class="kn">from</span> <span class="nn">monty.termcolor</span> <span class="k">import</span> <span class="n">colored</span><span class="p">,</span> <span class="n">cprint</span>
<span class="kn">from</span> <span class="nn">monty.collections</span> <span class="k">import</span> <span class="n">AttrDict</span>
<span class="kn">from</span> <span class="nn">monty.functools</span> <span class="k">import</span> <span class="n">lazy_property</span><span class="p">,</span> <span class="n">return_none_if_raise</span>
<span class="kn">from</span> <span class="nn">monty.json</span> <span class="k">import</span> <span class="n">MSONable</span>
<span class="kn">from</span> <span class="nn">monty.fnmatch</span> <span class="k">import</span> <span class="n">WildCard</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.units</span> <span class="k">import</span> <span class="n">Memory</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.serialization</span> <span class="k">import</span> <span class="n">json_pretty_dump</span><span class="p">,</span> <span class="n">pmg_serialize</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">File</span><span class="p">,</span> <span class="n">Directory</span><span class="p">,</span> <span class="n">irdvars_for_ext</span><span class="p">,</span> <span class="n">abi_splitext</span><span class="p">,</span> <span class="n">FilepathFixer</span><span class="p">,</span> <span class="n">Condition</span><span class="p">,</span> <span class="n">SparseHistogram</span>
<span class="kn">from</span> <span class="nn">.qadapters</span> <span class="k">import</span> <span class="n">make_qadapter</span><span class="p">,</span> <span class="n">QueueAdapter</span><span class="p">,</span> <span class="n">QueueAdapterError</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">qutils</span> <span class="k">as</span> <span class="n">qu</span>
<span class="kn">from</span> <span class="nn">.db</span> <span class="k">import</span> <span class="n">DBConnector</span>
<span class="kn">from</span> <span class="nn">.nodes</span> <span class="k">import</span> <span class="n">Status</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">NodeError</span><span class="p">,</span> <span class="n">NodeResults</span><span class="p">,</span> <span class="n">NodeCorrections</span><span class="p">,</span> <span class="n">FileNode</span><span class="p">,</span> <span class="n">check_spectator</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">abiinspect</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">events</span>


<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Matteo Giantomassi&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2013, The Materials Project&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.1&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Matteo Giantomassi&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;TaskManager&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AbinitBuild&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ParalHintsParser&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ParalHints&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AbinitTask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ScfTask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;NscfTask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RelaxTask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DdkTask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PhononTask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ElasticTask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SigmaTask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;EphTask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;OpticTask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AnaddbTask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;set_user_config_taskmanager&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># Tools and helper functions.</span>

<span class="k">def</span> <span class="nf">straceback</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Returns a string with the traceback.&quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">traceback</span>
    <span class="k">return</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">lennone</span><span class="p">(</span><span class="n">PropperOrNone</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">PropperOrNone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">PropperOrNone</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">nmltostring</span><span class="p">(</span><span class="n">nml</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a dictionary representing a Fortran namelist into a string.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nml</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nml should be a dict !&quot;</span><span class="p">)</span>

    <span class="n">curstr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">group</span> <span class="ow">in</span> <span class="n">nml</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
       <span class="n">namelist</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&amp;&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">]</span>
       <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
         <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
           <span class="n">namelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span>
         <span class="k">elif</span> <span class="n">is_string</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
           <span class="n">namelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="s2">&quot; = &#39;&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;,&quot;</span><span class="p">)</span>
         <span class="k">else</span><span class="p">:</span>
           <span class="n">namelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span>
       <span class="n">namelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>

       <span class="n">curstr</span> <span class="o">=</span> <span class="n">curstr</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">namelist</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="k">return</span> <span class="n">curstr</span>


<span class="k">class</span> <span class="nc">TaskResults</span><span class="p">(</span><span class="n">NodeResults</span><span class="p">):</span>

    <span class="n">JSON_SCHEMA</span> <span class="o">=</span> <span class="n">NodeResults</span><span class="o">.</span><span class="n">JSON_SCHEMA</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">JSON_SCHEMA</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;executable&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;required&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_node</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">task</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance from an :class:`AbinitTask` instance.&quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TaskResults</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">from_node</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">executable</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span>
            <span class="c1">#executable_version:</span>
            <span class="c1">#task_events=</span>
            <span class="n">pseudos</span><span class="o">=</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">pseudos</span><span class="p">],</span>
            <span class="c1">#input=task.input</span>
        <span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span>
            <span class="n">run_abi</span><span class="o">=</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">),</span>
            <span class="n">run_abo</span><span class="o">=</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span>


<span class="k">class</span> <span class="nc">ParalConf</span><span class="p">(</span><span class="n">AttrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object store the parameters associated to one</span>
<span class="sd">    of the possible parallel configurations reported by ABINIT.</span>
<span class="sd">    Essentially it is a dictionary whose values can also be accessed</span>
<span class="sd">    as attributes. It also provides default values for selected keys</span>
<span class="sd">    that might not be present in the ABINIT dictionary.</span>

<span class="sd">    Example:</span>

<span class="sd">        --- !Autoparal</span>
<span class="sd">        info:</span>
<span class="sd">            version: 1</span>
<span class="sd">            autoparal: 1</span>
<span class="sd">            max_ncpus: 108</span>
<span class="sd">        configurations:</span>
<span class="sd">            -   tot_ncpus: 2         # Total number of CPUs</span>
<span class="sd">                mpi_ncpus: 2         # Number of MPI processes.</span>
<span class="sd">                omp_ncpus: 1         # Number of OMP threads (1 if not present)</span>
<span class="sd">                mem_per_cpu: 10      # Estimated memory requirement per MPI processor in Megabytes.</span>
<span class="sd">                efficiency: 0.4      # 1.0 corresponds to an &quot;expected&quot; optimal efficiency (strong scaling).</span>
<span class="sd">                vars: {              # Dictionary with the variables that should be added to the input.</span>
<span class="sd">                      varname1: varvalue1</span>
<span class="sd">                      varname2: varvalue2</span>
<span class="sd">                      }</span>
<span class="sd">            -</span>
<span class="sd">        ...</span>

<span class="sd">    For paral_kgb we have:</span>
<span class="sd">    nproc     npkpt  npspinor    npband     npfft    bandpp    weight</span>
<span class="sd">       108       1         1        12         9         2        0.25</span>
<span class="sd">       108       1         1       108         1         2       27.00</span>
<span class="sd">        96       1         1        24         4         1        1.50</span>
<span class="sd">        84       1         1        12         7         2        0.25</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_DEFAULTS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;omp_ncpus&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;mem_per_cpu&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="s2">&quot;vars&quot;</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParalConf</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Add default values if not already in self.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DEFAULTS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
        <span class="n">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_cpu</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_ncpus</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_ncpus</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">speedup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimated speedup reported by ABINIT.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">efficiency</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cores</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tot_mem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimated total memory in Mbs (computed from mem_per_proc)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span>


<span class="k">class</span> <span class="nc">ParalHintsError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base error class for `ParalHints`.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="ParalHintsParser"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHintsParser">[docs]</a><span class="k">class</span> <span class="nc">ParalHintsParser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">Error</span> <span class="o">=</span> <span class="n">ParalHintsError</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Used to push error strings.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<div class="viewcode-block" id="ParalHintsParser.add_error"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHintsParser.add_error">[docs]</a>    <span class="k">def</span> <span class="nf">add_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errmsg</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParalHintsParser.parse"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHintsParser.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the `AutoParal` section (YAML format) from filename.</span>
<span class="sd">        Assumes the file contains only one section.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">YamlTokenizer</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">next_doc_with_tag</span><span class="p">(</span><span class="s2">&quot;!Autoparal&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">text_notag</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ParalHints</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">],</span> <span class="n">confs</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;configurations&quot;</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">traceback</span>
                <span class="n">sexc</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Wrong YAML doc:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n\n</span><span class="s2">Exception:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="n">sexc</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ParalHints"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints">[docs]</a><span class="k">class</span> <span class="nc">ParalHints</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterable with the hints for the parallel execution reported by ABINIT.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">ParalHintsError</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">confs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ParalConf</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">confs</span><span class="p">]</span>

<div class="viewcode-block" id="ParalHints.from_mpi_omp_lists"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.from_mpi_omp_lists">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_mpi_omp_lists</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a list of Parallel configurations from two lists</span>
<span class="sd">        containing the number of MPI processes and the number of OpenMP threads</span>
<span class="sd">        i.e. product(mpi_procs, omp_threads).</span>
<span class="sd">        The configuration have parallel efficiency set to 1.0 and no input variables.</span>
<span class="sd">        Mainly used for preparing benchmarks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">confs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ParalConf</span><span class="p">(</span><span class="n">mpi_ncpus</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">omp_ncpus</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">efficiency</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">)]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">confs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span> <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="ParalHints.max_cores"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.max_cores">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">max_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum number of cores.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">mpi_procs</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">omp_threads</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParalHints.max_mem_per_proc"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.max_mem_per_proc">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">max_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum memory per MPI process.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParalHints.max_speedup"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.max_speedup">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">max_speedup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum speedup.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">speedup</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParalHints.max_efficiency"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.max_efficiency">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">max_efficiency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum parallel efficiency.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">efficiency</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParalHints.as_dict"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.as_dict">[docs]</a>    <span class="nd">@pmg_serialize</span>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;info&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;confs&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="p">}</span></div>

<div class="viewcode-block" id="ParalHints.from_dict"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">],</span> <span class="n">confs</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;confs&quot;</span><span class="p">])</span></div>

<div class="viewcode-block" id="ParalHints.copy"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shallow copy of self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParalHints.select_with_condition"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.select_with_condition">[docs]</a>    <span class="k">def</span> <span class="nf">select_with_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all the configurations that do not satisfy the given condition.</span>

<span class="sd">            Args:</span>
<span class="sd">                condition: dict or :class:`Condition` object with operators expressed with a Mongodb-like syntax</span>
<span class="sd">                key: Selects the sub-dictionary on which condition is applied, e.g. key=&quot;vars&quot;</span>
<span class="sd">                    if we have to filter the configurations depending on the values in vars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="o">.</span><span class="n">as_condition</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>
        <span class="n">new_confs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># Select the object on which condition is applied</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">conf</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">add_it</span> <span class="o">=</span> <span class="n">condition</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">)</span>
            <span class="c1">#if key is &quot;vars&quot;: print(&quot;conf&quot;, conf, &quot;added:&quot;, add_it)</span>
            <span class="k">if</span> <span class="n">add_it</span><span class="p">:</span> <span class="n">new_confs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span> <span class="o">=</span> <span class="n">new_confs</span></div>

<div class="viewcode-block" id="ParalHints.sort_by_efficiency"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.sort_by_efficiency">[docs]</a>    <span class="k">def</span> <span class="nf">sort_by_efficiency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort the configurations in place. items with highest efficiency come first&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">efficiency</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParalHints.sort_by_speedup"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.sort_by_speedup">[docs]</a>    <span class="k">def</span> <span class="nf">sort_by_speedup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort the configurations in place. items with highest speedup come first&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">speedup</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParalHints.sort_by_mem_per_proc"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.sort_by_mem_per_proc">[docs]</a>    <span class="k">def</span> <span class="nf">sort_by_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sort the configurations in place. items with lowest memory per proc come first.&quot;&quot;&quot;</span>
        <span class="c1"># Avoid sorting if mem_per_cpu is not available.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">mem_per_proc</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParalHints.multidimensional_optimization"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.multidimensional_optimization">[docs]</a>    <span class="k">def</span> <span class="nf">multidimensional_optimization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priorities</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;speedup&quot;</span><span class="p">,</span> <span class="s2">&quot;efficiency&quot;</span><span class="p">)):</span>
        <span class="c1"># Mapping property --&gt; options passed to sparse_histogram</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">speedup</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">efficiency</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mf">0.1</span><span class="p">),</span> <span class="n">mem_per_proc</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">memory</span><span class="o">=</span><span class="mi">1024</span><span class="p">))</span>
        <span class="c1">#opts = dict(zip(priorities, bin_widths))</span>

        <span class="n">opt_confs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_confs</span>
        <span class="k">for</span> <span class="n">priority</span> <span class="ow">in</span> <span class="n">priorities</span><span class="p">:</span>
            <span class="n">histogram</span> <span class="o">=</span> <span class="n">SparseHistogram</span><span class="p">(</span><span class="n">opt_confs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">priority</span><span class="p">),</span> <span class="o">**</span><span class="n">opts</span><span class="p">[</span><span class="n">priority</span><span class="p">])</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">priority</span> <span class="o">==</span> <span class="s2">&quot;mem_per_proc&quot;</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">opt_confs</span> <span class="o">=</span> <span class="n">histogram</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="c1">#histogram.plot(show=True, savefig=&quot;hello.pdf&quot;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">confs</span><span class="o">=</span><span class="n">opt_confs</span><span class="p">)</span></div>

    <span class="c1">#def histogram_efficiency(self, step=0.1):</span>
    <span class="c1">#    &quot;&quot;&quot;Returns a :class:`SparseHistogram` with configuration grouped by parallel efficiency.&quot;&quot;&quot;</span>
    <span class="c1">#    return SparseHistogram(self._confs, key=lambda c: c.efficiency, step=step)</span>

    <span class="c1">#def histogram_speedup(self, step=1.0):</span>
    <span class="c1">#    &quot;&quot;&quot;Returns a :class:`SparseHistogram` with configuration grouped by parallel speedup.&quot;&quot;&quot;</span>
    <span class="c1">#    return SparseHistogram(self._confs, key=lambda c: c.speedup, step=step)</span>

    <span class="c1">#def histogram_memory(self, step=1024):</span>
    <span class="c1">#    &quot;&quot;&quot;Returns a :class:`SparseHistogram` with configuration grouped by memory.&quot;&quot;&quot;</span>
    <span class="c1">#    return SparseHistogram(self._confs, key=lambda c: c.speedup, step=step)</span>

    <span class="c1">#def filter(self, qadapter):</span>
    <span class="c1">#    &quot;&quot;&quot;Return a new list of configurations that can be executed on the `QueueAdapter` qadapter.&quot;&quot;&quot;</span>
    <span class="c1">#    new_confs = [pconf for pconf in self if qadapter.can_run_pconf(pconf)]</span>
    <span class="c1">#    return self.__class__(info=self.info, confs=new_confs)</span>

<div class="viewcode-block" id="ParalHints.get_ordered_with_policy"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ParalHints.get_ordered_with_policy">[docs]</a>    <span class="k">def</span> <span class="nf">get_ordered_with_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort and return a new list of configurations ordered according to the :class:`TaskPolicy` policy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Build new list since we are gonna change the object in place.</span>
        <span class="n">hints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">confs</span><span class="o">=</span><span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">num_cores</span> <span class="o">&lt;=</span> <span class="n">max_ncpus</span><span class="p">])</span>

        <span class="c1"># First select the configurations satisfying the condition specified by the user (if any)</span>
        <span class="n">bkp_hints</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">condition</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying condition </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">condition</span><span class="p">))</span>
            <span class="n">hints</span><span class="o">.</span><span class="n">select_with_condition</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>

            <span class="c1"># Undo change if no configuration fullfills the requirements.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hints</span><span class="p">:</span>
                <span class="n">hints</span> <span class="o">=</span> <span class="n">bkp_hints</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Empty list of configurations after policy.condition&quot;</span><span class="p">)</span>

        <span class="c1"># Now filter the configurations depending on the values in vars</span>
        <span class="n">bkp_hints</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">vars_condition</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying vars_condition </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">vars_condition</span><span class="p">))</span>
            <span class="n">hints</span><span class="o">.</span><span class="n">select_with_condition</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">vars_condition</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;vars&quot;</span><span class="p">)</span>

            <span class="c1"># Undo change if no configuration fullfills the requirements.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hints</span><span class="p">:</span>
                <span class="n">hints</span> <span class="o">=</span> <span class="n">bkp_hints</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Empty list of configurations after policy.vars_condition&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Example: hints.sort_by_speedup()</span>
            <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;efficiency&#39;</span><span class="p">,</span> <span class="s1">&#39;speedup&#39;</span><span class="p">,</span> <span class="s1">&#39;mem_per_proc&#39;</span><span class="p">]:</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">hints</span><span class="p">,</span> <span class="s2">&quot;sort_by_&quot;</span> <span class="o">+</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">[</span><span class="mi">0</span><span class="p">])()</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;meta_priority&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;highest_speedup_minimum_efficiency_cutoff&#39;</span><span class="p">:</span>
                    <span class="n">min_efficiency</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;minimum_efficiency&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                    <span class="n">hints</span><span class="o">.</span><span class="n">select_with_condition</span><span class="p">({</span><span class="s1">&#39;efficiency&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;$gte&#39;</span><span class="p">:</span> <span class="n">min_efficiency</span><span class="p">}})</span>
                    <span class="n">hints</span><span class="o">.</span><span class="n">sort_by_speedup</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hints</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">multidimensional_optimization</span><span class="p">(</span><span class="n">priorities</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal_priorities</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(hints) == 0&quot;</span><span class="p">)</span>

        <span class="c1">#TODO: make sure that num_cores == 1 is never selected when we have more than one configuration</span>
        <span class="c1">#if len(hints) &gt; 1:</span>
        <span class="c1">#    hints.select_with_condition(dict(num_cores={&quot;$eq&quot;: 1)))</span>

        <span class="c1"># Return final (orderded ) list of configurations (best first).</span>
        <span class="k">return</span> <span class="n">hints</span></div></div>


<span class="k">class</span> <span class="nc">TaskPolicy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores the parameters used by the :class:`TaskManager` to</span>
<span class="sd">    create the submission script and/or to modify the ABINIT variables</span>
<span class="sd">    governing the parallel execution. A `TaskPolicy` object contains</span>
<span class="sd">    a set of variables that specify the launcher, as well as the options</span>
<span class="sd">    and the conditions used to select the optimal configuration for the parallel run</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">as_policy</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts an object obj into a `:class:`TaskPolicy. Accepts:</span>

<span class="sd">            * None</span>
<span class="sd">            * TaskPolicy</span>
<span class="sd">            * dict-like object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Use default policy.</span>
            <span class="k">return</span> <span class="n">TaskPolicy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to convert type </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="bp">cls</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autodoc</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    autoparal:                # (integer). 0 to disable the autoparal feature (DEFAULT: 1 i.e. autoparal is on)</span>
<span class="s2">    condition:                # condition used to filter the autoparal configurations (Mongodb-like syntax).</span>
<span class="s2">                              # DEFAULT: empty i.e. ignored.</span>
<span class="s2">    vars_condition:           # Condition used to filter the list of ABINIT variables reported by autoparal</span>
<span class="s2">                              # (Mongodb-like syntax). DEFAULT: empty i.e. ignored.</span>
<span class="s2">    frozen_timeout:           # A job is considered frozen and its status is set to ERROR if no change to</span>
<span class="s2">                              # the output file has been done for `frozen_timeout` seconds. Accepts int with seconds or</span>
<span class="s2">                              # string in slurm form i.e. days-hours:minutes:seconds. DEFAULT: 1 hour.</span>
<span class="s2">    precedence:               # Under development.</span>
<span class="s2">    autoparal_priorities:     # Under development.</span>
<span class="s2">&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See autodoc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;autoparal&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;condition&quot;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vars_condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;vars_condition&quot;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precedence</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;precedence&quot;</span><span class="p">,</span> <span class="s2">&quot;autoparal_conf&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoparal_priorities</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;autoparal_priorities&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;speedup&quot;</span><span class="p">])</span>
        <span class="c1">#self.autoparal_priorities = kwargs.pop(&quot;autoparal_priorities&quot;, [&quot;speedup&quot;, &quot;efficiecy&quot;, &quot;memory&quot;]</span>
        <span class="c1"># TODO frozen_timeout could be computed as a fraction of the timelimit of the qadapter!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frozen_timeout</span> <span class="o">=</span> <span class="n">qu</span><span class="o">.</span><span class="n">slurm_parse_timestr</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;frozen_timeout&quot;</span><span class="p">,</span> <span class="s2">&quot;0-1:00:00&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found invalid keywords in policy section:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c1"># Consistency check.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precedence</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;qadapter&quot;</span><span class="p">,</span> <span class="s2">&quot;autoparal_conf&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong value for policy.precedence, should be qadapter or autoparal_conf&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ManagerIncreaseError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception raised by the manager if the increase request failed</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">FixQueueCriticalError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    error raised when an error could not be fixed at the task level</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="c1"># Global variable used to store the task manager returned by `from_user_config`.</span>
<span class="n">_USER_CONFIG_TASKMANAGER</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="set_user_config_taskmanager"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.set_user_config_taskmanager">[docs]</a><span class="k">def</span> <span class="nf">set_user_config_taskmanager</span><span class="p">(</span><span class="n">manager</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change the default manager returned by TaskManager.from_user_config.&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_USER_CONFIG_TASKMANAGER</span>
    <span class="n">_USER_CONFIG_TASKMANAGER</span>  <span class="o">=</span> <span class="n">manager</span></div>


<div class="viewcode-block" id="TaskManager"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager">[docs]</a><span class="k">class</span> <span class="nc">TaskManager</span><span class="p">(</span><span class="n">MSONable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A `TaskManager` is responsible for the generation of the job script and the submission</span>
<span class="sd">    of the task, as well as for the specification of the parameters passed to the resource manager</span>
<span class="sd">    (e.g. Slurm, PBS ...) and/or the run-time specification of the ABINIT variables governing the parallel execution.</span>
<span class="sd">    A `TaskManager` delegates the generation of the submission script and the submission of the task to the :class:`QueueAdapter`.</span>
<span class="sd">    A `TaskManager` has a :class:`TaskPolicy` that governs the specification of the parameters for the parallel executions.</span>
<span class="sd">    Ideally, the TaskManager should be the **main entry point** used by the task to deal with job submission/optimization</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">YAML_FILE</span> <span class="o">=</span> <span class="s2">&quot;manager.yml&quot;</span>
    <span class="n">USER_CONFIG_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">),</span> <span class="s2">&quot;.abinit&quot;</span><span class="p">,</span> <span class="s2">&quot;abipy&quot;</span><span class="p">)</span>

    <span class="n">ENTRIES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;policy&quot;</span><span class="p">,</span> <span class="s2">&quot;qadapters&quot;</span><span class="p">,</span> <span class="s2">&quot;db_connector&quot;</span><span class="p">,</span> <span class="s2">&quot;batch_adapter&quot;</span><span class="p">}</span>

<div class="viewcode-block" id="TaskManager.autodoc"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.autodoc">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autodoc</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">.db</span> <span class="k">import</span> <span class="n">DBConnector</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2"># TaskManager configuration file (YAML Format)</span>

<span class="s2">policy:</span>
<span class="s2">    # Dictionary with options used to control the execution of the tasks.</span>

<span class="s2">qadapters:</span>
<span class="s2">    # List of qadapters objects (mandatory)</span>
<span class="s2">    -  # qadapter_1</span>
<span class="s2">    -  # qadapter_2</span>

<span class="s2">db_connector:</span>
<span class="s2">    # Connection to MongoDB database (optional)</span>

<span class="s2">batch_adapter:</span>
<span class="s2">    # Adapter used to submit flows with batch script. (optional)</span>

<span class="s2">##########################################</span>
<span class="s2"># Individual entries are documented below:</span>
<span class="s2">##########################################</span>

<span class="s2">&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;policy: &quot;</span> <span class="o">+</span> <span class="n">TaskPolicy</span><span class="o">.</span><span class="n">autodoc</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;qadapter: &quot;</span> <span class="o">+</span> <span class="n">QueueAdapter</span><span class="o">.</span><span class="n">autodoc</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="c1">#s += &quot;db_connector: &quot; + DBConnector.autodoc()</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="TaskManager.from_user_config"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.from_user_config">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_user_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the :class:`TaskManager` from the YAML file &#39;manager.yaml&#39;.</span>
<span class="sd">        Search first in the working directory and then in the AbiPy configuration directory.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError if file is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">global</span> <span class="n">_USER_CONFIG_TASKMANAGER</span>
        <span class="k">if</span> <span class="n">_USER_CONFIG_TASKMANAGER</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_USER_CONFIG_TASKMANAGER</span>

        <span class="c1"># Try in the current directory then in user configuration directory.</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="bp">cls</span><span class="o">.</span><span class="n">YAML_FILE</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">USER_CONFIG_DIR</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">YAML_FILE</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">colored</span><span class="p">(</span>
		<span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Cannot locate </span><span class="si">%s</span><span class="s2"> neither in current directory nor in </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;!!! PLEASE READ THIS: !!!</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;To use AbiPy to run jobs this file must be present</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;It provides a description of the cluster/computer you are running on</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Examples are provided in abipy/data/managers.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">YAML_FILE</span><span class="p">,</span> <span class="n">path</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">))</span>

        <span class="n">_USER_CONFIG_TASKMANAGER</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_USER_CONFIG_TASKMANAGER</span></div>

<div class="viewcode-block" id="TaskManager.from_file"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.from_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the configuration parameters from the Yaml file filename.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">fh</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error while reading TaskManager parameters from </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">raise</span></div>

<div class="viewcode-block" id="TaskManager.from_string"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.from_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance from string s containing a YAML dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">s</span><span class="p">))</span></div>

<div class="viewcode-block" id="TaskManager.as_manager"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.as_manager">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">as_manager</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert obj into TaskManager instance. Accepts string, filepath, dictionary, `TaskManager` object.</span>
<span class="sd">        If obj is None, the manager is initialized from the user config file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span> <span class="k">return</span> <span class="n">obj</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_user_config</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">is_string</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to convert type </span><span class="si">%s</span><span class="s2"> to TaskManager&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span></div>

<div class="viewcode-block" id="TaskManager.from_dict"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an instance from a dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ENTRIES</span><span class="p">})</span></div>

<div class="viewcode-block" id="TaskManager.as_dict"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.as_dict">[docs]</a>    <span class="nd">@pmg_serialize</span>
    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            policy:None</span>
<span class="sd">            qadapters:List of qadapters in YAML format</span>
<span class="sd">            db_connector:Dictionary with data used to connect to the database (optional)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Keep a copy of kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">policy</span> <span class="o">=</span> <span class="n">TaskPolicy</span><span class="o">.</span><span class="n">as_policy</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;policy&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="c1"># Initialize database connector (if specified)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_connector</span> <span class="o">=</span> <span class="n">DBConnector</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;db_connector&quot;</span><span class="p">,</span> <span class="p">{}))</span>

        <span class="c1"># Build list of QAdapters. Neglect entry if priority == 0 or `enabled: no&quot;</span>
        <span class="n">qads</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;qadapters&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;enabled&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span> <span class="k">continue</span>
            <span class="n">qad</span> <span class="o">=</span> <span class="n">make_qadapter</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">priority</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">qads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qad</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">qad</span><span class="o">.</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;qadapter cannot have negative priority:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">qad</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">qads</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Received emtpy list of qadapters&quot;</span><span class="p">)</span>
        <span class="c1">#if len(qads) != 1:</span>
        <span class="c1">#    raise NotImplementedError(&quot;For the time being multiple qadapters are not supported! Please use one adapter&quot;)</span>

        <span class="c1"># Order qdapters according to priority.</span>
        <span class="n">qads</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">qads</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">q</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">priority</span><span class="p">)</span>
        <span class="n">priorities</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">priority</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qads</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">priorities</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">priorities</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Two or more qadapters have same priority. This is not allowed. Check taskmanager.yml&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_qads</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qadpos</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">qads</span><span class="p">),</span> <span class="mi">0</span>

        <span class="c1"># Initialize the qadapter for batch script submission.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;batch_adapter&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_adapter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_adapter</span> <span class="o">=</span> <span class="n">make_qadapter</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>
        <span class="c1">#print(&quot;batch_adapter&quot;, self.batch_adapter)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Found invalid keywords in the taskmanager file:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>

<div class="viewcode-block" id="TaskManager.abinit_build"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.abinit_build">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">abinit_build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`AbinitBuild` object with Abinit version and options used to build the code&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AbinitBuild</span><span class="p">(</span><span class="n">manager</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.to_shell_manager"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.to_shell_manager">[docs]</a>    <span class="k">def</span> <span class="nf">to_shell_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new `TaskManager` with the same parameters as self but replace the :class:`QueueAdapter`</span>
<span class="sd">        with a :class:`ShellAdapter` with mpi_procs so that we can submit the job without passing through the queue.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">my_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>
        <span class="n">my_kwargs</span><span class="p">[</span><span class="s2">&quot;policy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">TaskPolicy</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># On BlueGene we need at least two qadapters.</span>
        <span class="c1"># One for running jobs on the computing nodes and another one</span>
        <span class="c1"># for running small jobs on the fronted. These two qadapters</span>
        <span class="c1"># will have different enviroments and different executables.</span>
        <span class="c1"># If None of the q-adapters has qtype==shell, we change qtype to shell</span>
        <span class="c1"># and we return a new Manager for sequential jobs with the same parameters as self.</span>
        <span class="c1"># If the list contains a qadapter with qtype == shell, we ignore the remaining qadapters</span>
        <span class="c1"># when we build the new Manager.</span>
        <span class="n">has_shell_qad</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">my_kwargs</span><span class="p">[</span><span class="s2">&quot;qadapters&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;queue&quot;</span><span class="p">][</span><span class="s2">&quot;qtype&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;shell&quot;</span><span class="p">:</span> <span class="n">has_shell_qad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">has_shell_qad</span><span class="p">:</span>
            <span class="n">my_kwargs</span><span class="p">[</span><span class="s2">&quot;qadapters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">my_kwargs</span><span class="p">[</span><span class="s2">&quot;qadapters&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;queue&quot;</span><span class="p">][</span><span class="s2">&quot;qtype&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;shell&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">my_kwargs</span><span class="p">[</span><span class="s2">&quot;qadapters&quot;</span><span class="p">]:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;queue&quot;</span><span class="p">][</span><span class="s2">&quot;qtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;shell&quot;</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;limits&quot;</span><span class="p">][</span><span class="s2">&quot;min_cores&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi_procs</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;limits&quot;</span><span class="p">][</span><span class="s2">&quot;max_cores&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi_procs</span>

            <span class="c1"># If shell_runner is specified, replace mpi_runner with shell_runner</span>
            <span class="c1"># in the script used to run jobs on the frontend.</span>
            <span class="c1"># On same machines based on Slurm, indeed, mpirun/mpiexec is not available</span>
            <span class="c1"># and jobs should be executed with `srun -n4 exec` when running on the computing nodes</span>
            <span class="c1"># or with `exec` when running in sequential on the frontend.</span>
            <span class="k">if</span> <span class="s2">&quot;job&quot;</span> <span class="ow">in</span> <span class="n">d</span> <span class="ow">and</span> <span class="s2">&quot;shell_runner&quot;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;job&quot;</span><span class="p">]:</span>
                <span class="n">shell_runner</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;job&quot;</span><span class="p">][</span><span class="s2">&quot;shell_runner&quot;</span><span class="p">]</span>
                <span class="c1">#print(&quot;shell_runner:&quot;, shell_runner, type(shell_runner))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">shell_runner</span> <span class="ow">or</span> <span class="n">shell_runner</span> <span class="o">==</span> <span class="s2">&quot;None&quot;</span><span class="p">:</span> <span class="n">shell_runner</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;job&quot;</span><span class="p">][</span><span class="s2">&quot;mpi_runner&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shell_runner</span>
                <span class="c1">#print(&quot;shell_runner:&quot;, shell_runner)</span>

        <span class="c1">#print(my_kwargs)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">my_kwargs</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="TaskManager.new_with_fixed_mpi_omp"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.new_with_fixed_mpi_omp">[docs]</a>    <span class="k">def</span> <span class="nf">new_with_fixed_mpi_omp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new `TaskManager` in which autoparal has been disabled.</span>
<span class="sd">        The jobs will be executed with `mpi_procs` MPI processes and `omp_threads` OpenMP threads.</span>
<span class="sd">        Useful for generating input files for benchmarks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_omp_threads</span><span class="p">(</span><span class="n">omp_threads</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are submitting jobs via a queue manager.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;shell&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of :class:`QueueAdapter` objects sorted according to priorities (highest comes first)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qadapter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The qadapter used to submit jobs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qads</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_qadpos</span><span class="p">]</span>

<div class="viewcode-block" id="TaskManager.select_qadapter"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.select_qadapter">[docs]</a>    <span class="k">def</span> <span class="nf">select_qadapter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pconfs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of parallel configurations, pconfs, this method select an `optimal` configuration</span>
<span class="sd">        according to some criterion as well as the :class:`QueueAdapter` to use.</span>

<span class="sd">        Args:</span>
<span class="sd">            pconfs: :class:`ParalHints` object with the list of parallel configurations</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`ParallelConf` object with the `optimal` configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Order the list of configurations according to policy.</span>
        <span class="n">policy</span><span class="p">,</span> <span class="n">max_ncpus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">policy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cores</span>
        <span class="n">pconfs</span> <span class="o">=</span> <span class="n">pconfs</span><span class="o">.</span><span class="n">get_ordered_with_policy</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">precedence</span> <span class="o">==</span> <span class="s2">&quot;qadapter&quot;</span><span class="p">:</span>

            <span class="c1"># Try to run on the qadapter with the highest priority.</span>
            <span class="k">for</span> <span class="n">qadpos</span><span class="p">,</span> <span class="n">qad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qads</span><span class="p">):</span>
                <span class="n">possible_pconfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pc</span> <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">pconfs</span> <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">can_run_pconf</span><span class="p">(</span><span class="n">pc</span><span class="p">)]</span>

                <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">allocation</span> <span class="o">==</span> <span class="s2">&quot;nodes&quot;</span><span class="p">:</span>
                <span class="c1">#if qad.allocation in [&quot;nodes&quot;, &quot;force_nodes&quot;]:</span>
                    <span class="c1"># Select the configuration divisible by nodes if possible.</span>
                    <span class="k">for</span> <span class="n">pconf</span> <span class="ow">in</span> <span class="n">possible_pconfs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">pconf</span><span class="o">.</span><span class="n">num_cores</span> <span class="o">%</span> <span class="n">qad</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_qadpos_pconf</span><span class="p">(</span><span class="n">qadpos</span><span class="p">,</span> <span class="n">pconf</span><span class="p">)</span>

                <span class="c1"># Here we select the first one.</span>
                <span class="k">if</span> <span class="n">possible_pconfs</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_qadpos_pconf</span><span class="p">(</span><span class="n">qadpos</span><span class="p">,</span> <span class="n">possible_pconfs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">policy</span><span class="o">.</span><span class="n">precedence</span> <span class="o">==</span> <span class="s2">&quot;autoparal_conf&quot;</span><span class="p">:</span>
            <span class="c1"># Try to run on the first pconf irrespectively of the priority of the qadapter.</span>
            <span class="k">for</span> <span class="n">pconf</span> <span class="ow">in</span> <span class="n">pconfs</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">qadpos</span><span class="p">,</span> <span class="n">qad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qads</span><span class="p">):</span>

                    <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">allocation</span> <span class="o">==</span> <span class="s2">&quot;nodes&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pconf</span><span class="o">.</span><span class="n">num_cores</span> <span class="o">%</span> <span class="n">qad</span><span class="o">.</span><span class="n">hw</span><span class="o">.</span><span class="n">cores_per_node</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span> <span class="c1"># Ignore it. not very clean</span>

                    <span class="k">if</span> <span class="n">qad</span><span class="o">.</span><span class="n">can_run_pconf</span><span class="p">(</span><span class="n">pconf</span><span class="p">):</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_qadpos_pconf</span><span class="p">(</span><span class="n">qadpos</span><span class="p">,</span> <span class="n">pconf</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong value of policy.precedence = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">policy</span><span class="o">.</span><span class="n">precedence</span><span class="p">)</span>

        <span class="c1"># No qadapter could be found</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot find qadapter for this run!&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_use_qadpos_pconf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qadpos</span><span class="p">,</span> <span class="n">pconf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is called when we have accepted the :class:`ParalConf` pconf.</span>
<span class="sd">        Returns pconf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qadpos</span> <span class="o">=</span> <span class="n">qadpos</span>

        <span class="c1"># Change the number of MPI/OMP cores.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">pconf</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_omp_threads</span><span class="p">(</span><span class="n">pconf</span><span class="o">.</span><span class="n">omp_threads</span><span class="p">)</span>

        <span class="c1"># Set memory per proc.</span>
        <span class="c1">#FIXME: Fixer may have changed the memory per proc and should not be resetted by ParalConf</span>
        <span class="c1">#self.set_mem_per_proc(pconf.mem_per_proc)</span>
        <span class="k">return</span> <span class="n">pconf</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="c1">#app(&quot;[Task policy]\n%s&quot; % str(self.policy))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">qad</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qads</span><span class="p">):</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;[Qadapter </span><span class="si">%d</span><span class="s2">]</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">qad</span><span class="p">)))</span>
        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Qadapter selected: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qadpos</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_db</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="s2">&quot;[MongoDB database]:&quot;</span><span class="p">)</span>
            <span class="n">app</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_connector</span><span class="p">))</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_db</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are using MongoDB database&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_connector</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_omp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are using OpenMP parallelization.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">has_omp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of CPUs used to run the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">num_cores</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of MPI processes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">mpi_procs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Memory per MPI process.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">mem_per_proc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of OpenMP threads&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">omp_threads</span>

<div class="viewcode-block" id="TaskManager.deepcopy"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deep copy of self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.set_mpi_procs"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.set_mpi_procs">[docs]</a>    <span class="k">def</span> <span class="nf">set_mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of MPI processes to use.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">set_mpi_procs</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.set_omp_threads"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.set_omp_threads">[docs]</a>    <span class="k">def</span> <span class="nf">set_omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the number of OpenMp threads to use.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">set_omp_threads</span><span class="p">(</span><span class="n">omp_threads</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.set_mem_per_proc"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.set_mem_per_proc">[docs]</a>    <span class="k">def</span> <span class="nf">set_mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mem_mb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the memory (in Megabytes) per CPU.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">set_mem_per_proc</span><span class="p">(</span><span class="n">mem_mb</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maximum number of cores that can be used.</span>
<span class="sd">        This value is mainly used in the autoparal part to get the list of possible configurations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">hint_cores</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qads</span><span class="p">)</span>

<div class="viewcode-block" id="TaskManager.get_njobs_in_queue"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.get_njobs_in_queue">[docs]</a>    <span class="k">def</span> <span class="nf">get_njobs_in_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the number of jobs in the queue,</span>
<span class="sd">        returns None when the number of jobs cannot be determined.</span>

<span class="sd">        Args:</span>
<span class="sd">            username: (str) the username of the jobs to count (default is to autodetect)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">get_njobs_in_queue</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="n">username</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.cancel"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.cancel">[docs]</a>    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cancel the job. Returns exit status.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">cancel</span><span class="p">(</span><span class="n">job_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.write_jobfile"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.write_jobfile">[docs]</a>    <span class="k">def</span> <span class="nf">write_jobfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the submission script. Return the path of the script</span>

<span class="sd">        ================  ============================================</span>
<span class="sd">        kwargs            Meaning</span>
<span class="sd">        ================  ============================================</span>
<span class="sd">        exec_args         List of arguments passed to task.executable.</span>
<span class="sd">                          Default: no arguments.</span>

<span class="sd">        ================  ============================================</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">script</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">get_script_str</span><span class="p">(</span>
            <span class="n">job_name</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">launch_dir</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span>
            <span class="n">executable</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">executable</span><span class="p">,</span>
            <span class="n">qout_path</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">qerr_path</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">stdin</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">files_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">stdout</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">stderr</span><span class="o">=</span><span class="n">task</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="n">exec_args</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;exec_args&quot;</span><span class="p">,</span> <span class="p">[]),</span>
        <span class="p">)</span>

        <span class="c1"># Write the script.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">job_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">job_file</span><span class="o">.</span><span class="n">chmod</span><span class="p">(</span><span class="mo">0o740</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">job_file</span><span class="o">.</span><span class="n">path</span></div>

<div class="viewcode-block" id="TaskManager.launch"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.launch">[docs]</a>    <span class="k">def</span> <span class="nf">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the input files and submit the task via the :class:`Qadapter`</span>

<span class="sd">        Args:</span>
<span class="sd">            task: :class:`TaskObject`</span>

<span class="sd">        Returns:</span>
<span class="sd">            Process object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">task</span><span class="o">.</span><span class="n">S_LOCKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You shall not submit a locked task!&quot;</span><span class="p">)</span>

        <span class="c1"># Build the task</span>
        <span class="n">task</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

        <span class="c1"># Pass information on the time limit to Abinit (we always assume ndtset == 1)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">AbinitTask</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;exec_args&quot;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:]</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;--timelimit </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">qu</span><span class="o">.</span><span class="n">time2slurm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">timelimit</span><span class="p">))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;exec_args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span>

        <span class="c1"># Write the submission script</span>
        <span class="n">script_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_jobfile</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Submit the task and save the queue id.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">qjob</span><span class="p">,</span> <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">submit_to_queue</span><span class="p">(</span><span class="n">script_file</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;Submitted to queue&#39;</span><span class="p">)</span>
            <span class="n">task</span><span class="o">.</span><span class="n">set_qjob</span><span class="p">(</span><span class="n">qjob</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">process</span>

        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">MaxNumLaunchesError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c1"># TODO: Here we should try to switch to another qadapter</span>
            <span class="c1"># 1) Find a new parallel configuration in those stored in task.pconfs</span>
            <span class="c1"># 2) Change the input file.</span>
            <span class="c1"># 3) Regenerate the submission script</span>
            <span class="c1"># 4) Relaunch</span>
            <span class="n">task</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;max_num_launches reached: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
            <span class="k">raise</span></div>

<div class="viewcode-block" id="TaskManager.get_collection"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.get_collection">[docs]</a>    <span class="k">def</span> <span class="nf">get_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the MongoDB collection used to store the results.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_connector</span><span class="o">.</span><span class="n">get_collection</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.increase_mem"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.increase_mem">[docs]</a>    <span class="k">def</span> <span class="nf">increase_mem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># OLD</span>
        <span class="c1"># with GW calculations in mind with GW mem = 10,</span>
        <span class="c1"># the response fuction is in memory and not distributed</span>
        <span class="c1"># we need to increase memory if jobs fail ...</span>
        <span class="c1"># return self.qadapter.more_mem_per_proc()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">more_mem_per_proc</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">QueueAdapterError</span><span class="p">:</span>
            <span class="c1"># here we should try to switch to an other qadapter</span>
            <span class="k">raise</span> <span class="n">ManagerIncreaseError</span><span class="p">(</span><span class="s1">&#39;manager failed to increase mem&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.increase_ncpus"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.increase_ncpus">[docs]</a>    <span class="k">def</span> <span class="nf">increase_ncpus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        increase the number of cpus, first ask the current qadapter, if that one raises a QadapterIncreaseError</span>
<span class="sd">        switch to the next qadapter. If all fail raise an ManagerIncreaseError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">more_cores</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">QueueAdapterError</span><span class="p">:</span>
            <span class="c1"># here we should try to switch to an other qadapter</span>
            <span class="k">raise</span> <span class="n">ManagerIncreaseError</span><span class="p">(</span><span class="s1">&#39;manager failed to increase ncpu&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.increase_resources"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.increase_resources">[docs]</a>    <span class="k">def</span> <span class="nf">increase_resources</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">more_cores</span><span class="p">()</span>
            <span class="k">return</span>
        <span class="k">except</span> <span class="n">QueueAdapterError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">more_mem_per_proc</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">QueueAdapterError</span><span class="p">:</span>
            <span class="c1"># here we should try to switch to an other qadapter</span>
            <span class="k">raise</span> <span class="n">ManagerIncreaseError</span><span class="p">(</span><span class="s1">&#39;manager failed to increase resources&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.exclude_nodes"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.exclude_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">exclude_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">exclude_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">QueueAdapterError</span><span class="p">:</span>
            <span class="c1"># here we should try to switch to an other qadapter</span>
            <span class="k">raise</span> <span class="n">ManagerIncreaseError</span><span class="p">(</span><span class="s1">&#39;manager failed to exclude nodes&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TaskManager.increase_time"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.TaskManager.increase_time">[docs]</a>    <span class="k">def</span> <span class="nf">increase_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">more_time</span><span class="p">()</span>
        <span class="k">except</span> <span class="n">QueueAdapterError</span><span class="p">:</span>
            <span class="c1"># here we should try to switch to an other qadapter</span>
            <span class="k">raise</span> <span class="n">ManagerIncreaseError</span><span class="p">(</span><span class="s1">&#39;manager failed to increase time&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AbinitBuild"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitBuild">[docs]</a><span class="k">class</span> <span class="nc">AbinitBuild</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object stores information on the options used to build Abinit</span>

<span class="sd">        .. attribute:: info</span>
<span class="sd">            String with build information as produced by `abinit -b`</span>

<span class="sd">        .. attribute:: version</span>
<span class="sd">            Abinit version number e.g 8.0.1 (string)</span>

<span class="sd">        .. attribute:: has_netcdf</span>
<span class="sd">            True if netcdf is enabled.</span>

<span class="sd">        .. attribute:: has_omp</span>
<span class="sd">            True if OpenMP is enabled.</span>

<span class="sd">        .. attribute:: has_mpi</span>
<span class="sd">            True if MPI is enabled.</span>

<span class="sd">        .. attribute:: has_mpiio</span>
<span class="sd">            True if MPI-IO is supported.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">manager</span> <span class="o">=</span> <span class="n">TaskManager</span><span class="o">.</span><span class="n">as_manager</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span><span class="o">.</span><span class="n">to_shell_manager</span><span class="p">(</span><span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Build a simple manager to run the job in a shell subprocess</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="n">workdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span> <span class="k">if</span> <span class="n">workdir</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">workdir</span>

        <span class="c1"># Generate a shell script to execute `abinit -b`</span>
        <span class="n">stdout</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;run.abo&quot;</span><span class="p">)</span>
        <span class="n">script</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">get_script_str</span><span class="p">(</span>
            <span class="n">job_name</span><span class="o">=</span><span class="s2">&quot;abinit_b&quot;</span><span class="p">,</span>
            <span class="n">launch_dir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span>
            <span class="n">executable</span><span class="o">=</span><span class="s2">&quot;abinit&quot;</span><span class="p">,</span>
            <span class="n">qout_path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;queue.qout&quot;</span><span class="p">),</span>
            <span class="n">qerr_path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;queue.qerr&quot;</span><span class="p">),</span>
            <span class="c1">#stdin=os.path.join(workdir, &quot;run.files&quot;),</span>
            <span class="n">stdout</span><span class="o">=</span><span class="n">stdout</span><span class="p">,</span>
            <span class="n">stderr</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;run.err&quot;</span><span class="p">),</span>
            <span class="n">exec_args</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;-b&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># Execute the script.</span>
        <span class="n">script_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;job.sh&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">script_file</span><span class="p">,</span> <span class="s2">&quot;wt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
        <span class="n">qjob</span><span class="p">,</span> <span class="n">process</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">submit_to_queue</span><span class="p">(</span><span class="n">script_file</span><span class="p">)</span>
        <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">process</span><span class="o">.</span><span class="n">returncode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Error while executing </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">script_file</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;stderr:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">process</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
            <span class="c1">#print(&quot;stdout:&quot;, process.stdout.read())</span>

        <span class="c1"># To avoid: ResourceWarning: unclosed file &lt;_io.BufferedReader name=87&gt; in py3k</span>
        <span class="n">process</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s2">&quot;rt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="c1"># info string has the following format.</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        === Build Information ===</span>
<span class="sd">         Version       : 8.0.1</span>
<span class="sd">         Build target  : x86_64_darwin15.0.0_gnu5.3</span>
<span class="sd">         Build date    : 20160122</span>

<span class="sd">        === Compiler Suite ===</span>
<span class="sd">         C compiler       : gnu</span>
<span class="sd">         C++ compiler     : gnuApple</span>
<span class="sd">         Fortran compiler : gnu5.3</span>
<span class="sd">         CFLAGS           :  -g -O2 -mtune=native -march=native</span>
<span class="sd">         CXXFLAGS         :  -g -O2 -mtune=native -march=native</span>
<span class="sd">         FCFLAGS          :  -g -ffree-line-length-none</span>
<span class="sd">         FC_LDFLAGS       :</span>

<span class="sd">        === Optimizations ===</span>
<span class="sd">         Debug level        : basic</span>
<span class="sd">         Optimization level : standard</span>
<span class="sd">         Architecture       : unknown_unknown</span>

<span class="sd">        === Multicore ===</span>
<span class="sd">         Parallel build : yes</span>
<span class="sd">         Parallel I/O   : yes</span>
<span class="sd">         openMP support : no</span>
<span class="sd">         GPU support    : no</span>

<span class="sd">        === Connectors / Fallbacks ===</span>
<span class="sd">         Connectors on : yes</span>
<span class="sd">         Fallbacks on  : yes</span>
<span class="sd">         DFT flavor    : libxc-fallback+atompaw-fallback+wannier90-fallback</span>
<span class="sd">         FFT flavor    : none</span>
<span class="sd">         LINALG flavor : netlib</span>
<span class="sd">         MATH flavor   : none</span>
<span class="sd">         TIMER flavor  : abinit</span>
<span class="sd">         TRIO flavor   : netcdf+etsf_io-fallback</span>

<span class="sd">        === Experimental features ===</span>
<span class="sd">         Bindings            : @enable_bindings@</span>
<span class="sd">         Exports             : no</span>
<span class="sd">         GW double-precision : yes</span>

<span class="sd">        === Bazaar branch information ===</span>
<span class="sd">         Branch ID : gmatteo@gmac-20160112110440-lf6exhneqim9082h</span>
<span class="sd">         Revision  : 1226</span>
<span class="sd">         Committed : 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="s2">&quot;0.0.0&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_netcdf</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_mpi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_mpiio</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">yesno2bool</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">yes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">no</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">auto</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">ans</span><span class="p">]</span>

        <span class="c1"># Parse info.</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;Version&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;TRIO flavor&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">has_netcdf</span> <span class="o">=</span> <span class="s2">&quot;netcdf&quot;</span> <span class="ow">in</span> <span class="n">line</span>
            <span class="k">if</span> <span class="s2">&quot;openMP support&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span> <span class="o">=</span> <span class="n">yesno2bool</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;Parallel build&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_mpi</span> <span class="o">=</span> <span class="n">yesno2bool</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;Parallel I/O&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_mpiio</span> <span class="o">=</span> <span class="n">yesno2bool</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Abinit Build Information:&quot;</span><span class="p">)</span>
        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;    Abinit version: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>
        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;    MPI: </span><span class="si">%s</span><span class="s2">, MPI-IO: </span><span class="si">%s</span><span class="s2">, OpenMP: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_mpi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_mpiio</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_omp</span><span class="p">))</span>
        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;    Netcdf: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_netcdf</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitBuild.version_ge"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitBuild.version_ge">[docs]</a>    <span class="k">def</span> <span class="nf">version_ge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">version_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True is Abinit version is &gt;= version_string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_version</span><span class="p">(</span><span class="n">version_string</span><span class="p">,</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitBuild.compare_version"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitBuild.compare_version">[docs]</a>    <span class="k">def</span> <span class="nf">compare_version</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">version_string</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare Abinit version to `version_string` with operator `op`&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pkg_resources</span> <span class="k">import</span> <span class="n">parse_version</span>
        <span class="kn">from</span> <span class="nn">monty.operator</span> <span class="k">import</span> <span class="n">operator_from_str</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">operator_from_str</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">parse_version</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">),</span> <span class="n">parse_version</span><span class="p">(</span><span class="n">version_string</span><span class="p">))</span></div></div>


<span class="k">class</span> <span class="nc">FakeProcess</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This object is attached to a :class:`Task` instance if the task has not been submitted</span>
<span class="sd">    This trick allows us to simulate a process that is still running so that</span>
<span class="sd">    we can safely poll task.process.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot wait a FakeProcess&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">communicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot communicate with a FakeProcess&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot kill a FakeProcess&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">returncode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">MyTimedelta</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A customized version of timedelta whose __str__ method doesn&#39;t print microseconds.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">days</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">microseconds</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">days</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">microseconds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove microseconds from timedelta default __str__&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MyTimedelta</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
        <span class="n">microsec</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">microsec</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">microsec</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">as_timedelta</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert delta into a MyTimedelta object.&quot;&quot;&quot;</span>
        <span class="c1"># Cannot monkey patch the __class__ and must pass through __new__ as the object is immutable.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span> <span class="k">return</span> <span class="n">delta</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">days</span><span class="p">,</span> <span class="n">delta</span><span class="o">.</span><span class="n">seconds</span><span class="p">,</span> <span class="n">delta</span><span class="o">.</span><span class="n">microseconds</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TaskDateTimes</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Small object containing useful :class:`datetime.datatime` objects associated to important events.</span>

<span class="sd">    .. attributes:</span>

<span class="sd">        init: initialization datetime</span>
<span class="sd">        submission: submission datetime</span>
<span class="sd">        start: Begin of execution.</span>
<span class="sd">        end: End of execution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">submission</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Initialization done on: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">submission</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Submitted on: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">submission</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Started on: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">app</span><span class="p">(</span><span class="s2">&quot;Completed on: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reinitialize the counters.&quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_runtime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:class:`timedelta` with the run-time, None if the Task is not running&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>

        <span class="k">return</span> <span class="n">MyTimedelta</span><span class="o">.</span><span class="n">as_timedelta</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_time_inqueue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`timedelta` with the time spent in the Queue, None if the Task is not running</span>

<span class="sd">        .. note:</span>

<span class="sd">            This value is always greater than the real value computed by the resource manager</span>
<span class="sd">            as we start to count only when check_status sets the `Task` status to S_RUN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">submission</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">submission</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">submission</span>
            <span class="c1"># This happens when we read the exact start datetime from the ABINIT log file.</span>
            <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">MyTimedelta</span><span class="o">.</span><span class="n">as_timedelta</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">TaskError</span><span class="p">(</span><span class="n">NodeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base Exception for :class:`Task` methods&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">TaskRestartError</span><span class="p">(</span><span class="n">TaskError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception raised while trying to restart the :class:`Task`.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">Task</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">with_metaclass</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span><span class="p">,</span> <span class="n">Node</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Task is a node that performs some kind of calculation.</span>
<span class="sd">    This is base class providing low-level methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Use class attributes for TaskErrors so that we don&#39;t have to import them.</span>
    <span class="n">Error</span> <span class="o">=</span> <span class="n">TaskError</span>
    <span class="n">RestartError</span> <span class="o">=</span> <span class="n">TaskRestartError</span>

    <span class="c1"># List of `AbinitEvent` subclasses that are tested in the check_status method.</span>
    <span class="c1"># Subclasses should provide their own list if they need to check the converge status.</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Prefixes for Abinit (input, output, temporary) files.</span>
    <span class="n">Prefix</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Prefix&quot;</span><span class="p">,</span> <span class="s2">&quot;idata odata tdata&quot;</span><span class="p">)</span>
    <span class="n">pj</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span>

    <span class="n">prefix</span> <span class="o">=</span> <span class="n">Prefix</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="s2">&quot;indata&quot;</span><span class="p">,</span> <span class="s2">&quot;in&quot;</span><span class="p">),</span> <span class="n">pj</span><span class="p">(</span><span class="s2">&quot;outdata&quot;</span><span class="p">,</span> <span class="s2">&quot;out&quot;</span><span class="p">),</span> <span class="n">pj</span><span class="p">(</span><span class="s2">&quot;tmpdata&quot;</span><span class="p">,</span> <span class="s2">&quot;tmp&quot;</span><span class="p">))</span>
    <span class="k">del</span> <span class="n">Prefix</span><span class="p">,</span> <span class="n">pj</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            input: :class:`AbinitInput` object.</span>
<span class="sd">            workdir: Path to the working directory.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">            deps: Dictionary specifying the dependency of this node.</span>
<span class="sd">                  None means that this Task has no dependency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Init the node</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Task</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_input</span> <span class="o">=</span> <span class="nb">input</span>

        <span class="k">if</span> <span class="n">workdir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_workdir</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_manager</span><span class="p">(</span><span class="n">manager</span><span class="p">)</span>

        <span class="c1"># Handle possible dependencies.</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_deps</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>

        <span class="c1"># Date-time associated to submission, start and end.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span> <span class="o">=</span> <span class="n">TaskDateTimes</span><span class="p">()</span>

        <span class="c1"># Count the number of restarts.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_qjob</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abi_errors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># two flags that provide, dynamically, information on the scaling behavious of a task. If any process of fixing</span>
        <span class="c1"># finds none scaling behaviour, they should be switched. If a task type is clearly not scaling they should be</span>
        <span class="c1"># swiched.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mem_scales</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_scales</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return state is pickled as the contents for the instance.</span>

<span class="sd">        In this case we just remove the process since Subprocess objects cannot be pickled.</span>
<span class="sd">        This is the reason why we have to store the returncode in self._returncode instead</span>
<span class="sd">        of using self.process.returncode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;_process&quot;</span><span class="p">]}</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">set_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="p">,</span> <span class="n">chroot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the working directory. Cannot be set more than once unless chroot is True&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">chroot</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;workdir&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">workdir</span> <span class="o">!=</span> <span class="n">workdir</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;self.workdir != workdir: </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span>  <span class="n">workdir</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">workdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>

        <span class="c1"># Files required for the execution.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;run.abi&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;run.abo&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;run.files&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">job_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;job.sh&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;run.log&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;run.err&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;__startlock__&quot;</span><span class="p">))</span>
        <span class="c1"># This file is produced by Abinit if nprocs &gt; 1 and MPI_ABORT.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mpiabort_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;__ABI_MPIABORTFILE__&quot;</span><span class="p">))</span>

        <span class="c1"># Directories with input|output|temporary data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;indata&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;outdata&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span> <span class="o">=</span> <span class="n">Directory</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;tmpdata&quot;</span><span class="p">))</span>

        <span class="c1"># stderr and output file of the queue manager. Note extensions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;queue.qerr&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span> <span class="o">=</span> <span class="n">File</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;queue.qout&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">set_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">manager</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the :class:`TaskManager` used to launch the Task.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">work</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The :class:`Work` containing this `Task`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_work</span>

    <span class="k">def</span> <span class="nf">set_work</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">work</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the :class:`Work` associated to this `Task`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_work&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_work</span> <span class="o">=</span> <span class="n">work</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_work</span> <span class="o">!=</span> <span class="n">work</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;self._work != work&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The :class:`Flow` containing this `Task`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="o">.</span><span class="n">flow</span>

    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The position of the task in the :class:`Flow`&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">task</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find the position of </span><span class="si">%s</span><span class="s2"> in flow </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pos_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String representation of self.pos&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;w&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;_t&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_launches</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of launches performed. This number includes both possible ABINIT restarts</span>
<span class="sd">        as well as possible launches done due to errors encountered with the resource manager</span>
<span class="sd">        or the hardware/software.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">num_launches</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qads</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;AbinitInput object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input</span>

    <span class="k">def</span> <span class="nf">get_inpvar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">varname</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the value of the ABINIT variable varname, None if not present.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">varname</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the values of the ABINIT variables in the input file. Return dict with old values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="n">old_values</span> <span class="o">=</span> <span class="p">{</span><span class="n">vname</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">vname</span><span class="p">)</span> <span class="k">for</span> <span class="n">vname</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="n">old_values</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Setting input variables: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Old values: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">old_values</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">old_values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initial_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initial structure of the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">structure</span>

    <span class="k">def</span> <span class="nf">make_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_header</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct the input file of the calculation.&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">with_header</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">ipath_from_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the path of the input file with extension ext.</span>
<span class="sd">        Use it when the file does not exist yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">idata</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">opath_from_ext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the path of the output file with extension ext.</span>
<span class="sd">        Use it when the file does not exist yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">odata</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Path to the executable associated to the task (internally stored in self._executable).</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_executable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">executable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the executable associate to this task.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span> <span class="o">=</span> <span class="n">executable</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># Attach a fake process so that we can poll it.</span>
            <span class="k">return</span> <span class="n">FakeProcess</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_abinit_task</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this task is a subclass of AbinitTask.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AbinitTask</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_anaddb_task</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this task is a subclass of OpticTask.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AnaddbTask</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_optic_task</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this task is a subclass of OpticTask.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">OpticTask</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_completed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the task has been executed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">can_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The task can run if its status is &lt; S_SUB and all the other dependencies (if any) are done!&quot;&quot;&quot;</span>
        <span class="n">all_ok</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">stat</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span> <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps_status</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span> <span class="ow">and</span> <span class="n">all_ok</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cancel the job. Returns 1 if job was cancelled.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>

        <span class="n">exit_status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">cancel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exit_status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;manager.cancel returned exit_status: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">exit_status</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Remove output files and reset the status.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Job </span><span class="si">%s</span><span class="s2"> cancelled by user&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">with_fixed_mpi_omp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disable autoparal and force execution with `mpi_procs` MPI processes</span>
<span class="sd">        and `omp_threads` OpenMP threads. Useful for generating benchmarks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">manager</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;manager&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">manager</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">new_with_fixed_mpi_omp</span><span class="p">(</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="n">omp_threads</span><span class="p">)</span>

    <span class="c1">#def set_max_ncores(self, max_ncores):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    manager = self.manager if hasattr(self, &quot;manager&quot;) else self.flow.manager</span>
    <span class="c1">#    self.manager = manager.new_with_max_ncores(mpi_procs, omp_threads)</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">_on_done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fix_ofiles</span><span class="p">()</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">_on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Fix output file names.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fix_ofiles</span><span class="p">()</span>

        <span class="c1"># Get results</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ok</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called once the `Task` has reached status S_OK.</span>
<span class="sd">        Subclasses should provide their own implementation</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary that must contain at least the following entries:</span>
<span class="sd">                returncode:</span>
<span class="sd">                    0 on success.</span>
<span class="sd">                message:</span>
<span class="sd">                    a string that should provide a human-readable description of what has been performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">returncode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Calling on_all_ok of the base class!&quot;</span><span class="p">)</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">fix_ofiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the task reaches S_OK.</span>
<span class="sd">        It changes the extension of particular output files</span>
<span class="sd">        produced by Abinit so that the &#39;official&#39; extension</span>
<span class="sd">        is preserved e.g. out_1WF14 --&gt; out_1WF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filepaths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>
        <span class="c1">#logger.info(&quot;in fix_ofiles with filepaths %s&quot; % list(filepaths))</span>

        <span class="n">old2new</span> <span class="o">=</span> <span class="n">FilepathFixer</span><span class="p">()</span><span class="o">.</span><span class="n">fix_paths</span><span class="p">(</span><span class="n">filepaths</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">old2new</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;will rename old </span><span class="si">%s</span><span class="s2"> to new </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">))</span>
            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">_restart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">submit</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by restart once we have finished preparing the task for restarting.</span>

<span class="sd">        Return:</span>
<span class="sd">            True if task has been restarted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Restarted on </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>

        <span class="c1"># Increase the counter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Restarted, num_restarts </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span><span class="p">)</span>

        <span class="c1"># Reset datetimes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># Remove the lock file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">submit</span><span class="p">:</span>
            <span class="c1"># Relaunch the task.</span>
            <span class="n">fired</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fired</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Restart failed&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fired</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">fired</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restart the calculation.  Subclasses should provide a concrete version that</span>
<span class="sd">        performs all the actions needed for preparing the restart and then calls self._restart</span>
<span class="sd">        to restart the task. The default implementation is empty.</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if job was restarted, 0 otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Calling the **empty** restart method of the base class&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if child process has terminated. Set and return returncode attribute.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">,</span> <span class="s2">&quot;status set to Done&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wait for child process to terminate. Set and return returncode attribute.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">,</span> <span class="s2">&quot;status set to Done&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span>

    <span class="k">def</span> <span class="nf">communicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached.</span>
<span class="sd">        Wait for process to terminate. The optional input argument should be a string to be sent to the</span>
<span class="sd">        child process, or None, if no data should be sent to the child.</span>

<span class="sd">        communicate() returns a tuple (stdoutdata, stderrdata).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stdoutdata</span><span class="p">,</span> <span class="n">stderrdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="nb">input</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">returncode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">,</span> <span class="s2">&quot;status set to Done&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stdoutdata</span><span class="p">,</span> <span class="n">stderrdata</span>

    <span class="k">def</span> <span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Kill the child.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="s2">&quot;status set to Error by task.kill&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">returncode</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">returncode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The child return code, set by poll() and wait() (and indirectly by communicate()).</span>
<span class="sd">        A None value indicates that the process hasn&#39;t terminated yet.</span>
<span class="sd">        A negative value -N indicates that the child was terminated by signal N (Unix only).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_returncode</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the task status. Mainly used if we made a silly mistake in the initial</span>
<span class="sd">        setup of the queue manager and we want to fix it and rerun the task.</span>

<span class="sd">        Returns:</span>
<span class="sd">            0 on success, 1 if reset failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Can only reset tasks that are done.</span>
        <span class="c1"># One should be able to reset &#39;Submitted&#39; tasks (sometimes, they are not in the queue</span>
        <span class="c1"># and we want to restart them)</span>
        <span class="c1">#if self.status != self.S_SUB and self.status &lt; self.S_DONE: return 1</span>

        <span class="c1"># Remove output files otherwise the EventParser will think the job is still running</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Reset on </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_qjob</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Reset finalized flags.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="o">.</span><span class="n">finalized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow</span><span class="o">.</span><span class="n">finalized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="nd">@return_none_if_raise</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">queue_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Queue identifier returned by the Queue manager. None if not set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qjob</span><span class="o">.</span><span class="n">qid</span>

    <span class="nd">@property</span>
    <span class="nd">@return_none_if_raise</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">qname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Queue name identifier returned by the Queue manager. None if not set&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">qjob</span><span class="o">.</span><span class="n">qname</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qjob</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qjob</span>

    <span class="k">def</span> <span class="nf">set_qjob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qjob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set info on queue after submission.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qjob</span> <span class="o">=</span> <span class="n">qjob</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if we are submitting jobs via a queue manager.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;shell&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_cores</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of CPUs used to run the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">num_cores</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mpi_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of CPUs used for MPI.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mpi_procs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">omp_threads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of CPUs used for OpenMP.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">omp_threads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mem_per_proc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Memory per MPI process.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Memory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="p">,</span> <span class="s2">&quot;Mb&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the status of the task.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status</span>

    <span class="k">def</span> <span class="nf">lock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lock the task, source is the :class:`Node` that applies the lock.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trying to lock a task with status </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Locked by node </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">source_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unlock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">check_status</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unlock the task, set its status to `S_READY` so that the scheduler can submit it.</span>
<span class="sd">        source_node is the :class:`Node` that removed the lock</span>
<span class="sd">        Call task.check_status if check_status is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Trying to unlock a task with status </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span>
        <span class="k">if</span> <span class="n">check_status</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_status</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Unlocked by </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">source_node</span><span class="p">)</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">set_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set and return the status of the task.</span>

<span class="sd">        Args:</span>
<span class="sd">            status: Status object or string representation of the status</span>
<span class="sd">            msg: string with human-readable message used in the case of errors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># truncate string if it&#39;s long. msg will be logged in the object and we don&#39;t want to waste memory.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[:</span><span class="mi">2000</span><span class="p">]</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">... snip ...</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="c1"># Locked files must be explicitly unlocked</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span> <span class="ow">or</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span>
                 <span class="s2">&quot;Locked files must be explicitly unlocked before calling set_status but</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="s2">&quot;task.status = </span><span class="si">%s</span><span class="s2">, input status = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="n">status</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>

        <span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">.</span><span class="n">as_status</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>

        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_status&quot;</span><span class="p">):</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="n">status</span>

        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_RUN</span><span class="p">:</span>
            <span class="c1"># Set datetimes.start when the task enters S_RUN</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

        <span class="c1"># Add new entry to history only if the status has changed.</span>
        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">submission</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Submitted with MPI=</span><span class="si">%s</span><span class="s2">, Omp=</span><span class="si">%s</span><span class="s2">, Memproc=</span><span class="si">%.1f</span><span class="s2"> [Gb] </span><span class="si">%s</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mpi_procs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omp_threads</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_per_proc</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s2">&quot;Gb&quot;</span><span class="p">),</span> <span class="n">msg</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Task completed </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Status set to S_ABI_CRITICAL due to: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Status changed to </span><span class="si">%s</span><span class="s2">. msg: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="c1">#######################################################</span>
        <span class="c1"># The section belows contains callbacks that should not</span>
        <span class="c1"># be executed if we are in spectator_mode</span>
        <span class="c1">#######################################################</span>
        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span>
            <span class="c1"># Execute the callback</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_on_done</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
            <span class="c1"># Finalize the task.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_on_ok</span><span class="p">()</span>

                <span class="c1"># here we remove the output files of the task and of its parents.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="o">.</span><span class="n">policy</span> <span class="o">==</span> <span class="s2">&quot;task&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clean_output_files</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="c1"># Because _on_ok might have changed the status.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">send_signal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">status</span>

    <span class="k">def</span> <span class="nf">check_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function checks the status of the task by inspecting the output and the</span>
<span class="sd">        error files produced by the application and by the queue manager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1) see it the job is blocked</span>
        <span class="c1"># 2) see if an error occured at submitting the job the job was submitted, TODO these problems can be solved</span>
        <span class="c1"># 3) see if there is output</span>
        <span class="c1"># 4) see if abinit reports problems</span>
        <span class="c1"># 5) see if both err files exist and are empty</span>
        <span class="c1"># 6) no output and no err files, the job must still be running</span>
        <span class="c1"># 7) try to find out what caused the problems</span>
        <span class="c1"># 8) there is a problem but we did not figure out what ...</span>
        <span class="c1"># 9) the only way of landing here is if there is a output file but no err files...</span>

        <span class="c1"># 1) A locked task can only be unlocked by calling set_status explicitly.</span>
        <span class="c1"># an errored task, should not end up here but just to be sure</span>
        <span class="n">black_list</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_LOCKED</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">)</span>
        <span class="c1">#if self.status in black_list: return self.status</span>

        <span class="c1"># 2) Check the returncode of the job script</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;job.sh return code: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">Perhaps the job was not submitted properly?&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># If we have an abort file produced by Abinit</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpiabort_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Found ABINIT abort file&quot;</span><span class="p">)</span>

        <span class="c1"># Analyze the stderr file for Fortran runtime errors.</span>
        <span class="c1"># getsize is 0 if the file is empty or it does not exist.</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">getsize</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="c1"># Analyze the stderr file of the resource manager runtime errors.</span>
        <span class="c1"># TODO: Why are we looking for errors in queue.qerr?</span>
        <span class="n">qerr_info</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">getsize</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">qerr_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="c1"># Analyze the stdout file of the resource manager (needed for PBS !)</span>
        <span class="n">qout_info</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">getsize</span><span class="p">():</span>
            <span class="n">qout_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="c1"># Start to check ABINIT status if the output file has been created.</span>
        <span class="c1">#if self.output_file.getsize() != 0:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">report</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> exception while parsing event_report:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">report</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;got None report!&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">report</span><span class="o">.</span><span class="n">run_completed</span><span class="p">:</span>
                <span class="c1"># Here we  set the correct timing data reported by Abinit</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">start_datetime</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">end_datetime</span>

                <span class="c1"># Check if the calculation converged.</span>
                <span class="n">not_ok</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">filter_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CRITICAL_EVENTS</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">not_ok</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_UNCONVERGED</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;status set to unconverged based on abiout&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;status set to ok based on abiout&quot;</span><span class="p">)</span>

            <span class="c1"># Calculation still running or errors?</span>
            <span class="k">if</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                <span class="c1"># Abinit reported problems</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Found errors in report&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">abi_errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">abi_errors</span> <span class="o">=</span> <span class="p">[</span><span class="n">error</span><span class="p">]</span>

                <span class="c1"># The job is unfixable due to ABINIT errors</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: Found Errors or Bugs in ABINIT main output!&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="n">report</span><span class="o">.</span><span class="n">errors</span><span class="p">))</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># 5)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">err_msg</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">qerr_info</span><span class="p">:</span>
                    <span class="c1"># there is output and no errors</span>
                    <span class="c1"># The job still seems to be running</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_RUN</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;there is output and no errors: job still seems to be running&#39;</span><span class="p">)</span>

        <span class="c1"># 6)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;output_file does not exists&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
                <span class="c1"># No output at allThe job is still in the queue.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span>

        <span class="c1"># 7) Analyze the files of the resource manager and abinit and execution err (mvs)</span>
        <span class="c1"># MG: This section has been disabled: several portability issues</span>
        <span class="c1"># Need more robust logic in error_parser, perhaps logic provided by users via callbacks.</span>
        <span class="k">if</span> <span class="kc">False</span> <span class="ow">and</span> <span class="p">(</span><span class="n">qerr_info</span> <span class="ow">or</span> <span class="n">qout_info</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pymatgen.io.abinit.scheduler_error_parsers</span> <span class="k">import</span> <span class="n">get_parser</span>
            <span class="n">scheduler_parser</span> <span class="o">=</span> <span class="n">get_parser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="p">,</span> <span class="n">err_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qerr_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                                          <span class="n">out_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">run_err_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">scheduler_parser</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span>
                                       <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Cannot find scheduler_parser for qtype </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">qadapter</span><span class="o">.</span><span class="n">QTYPE</span><span class="p">)</span>

            <span class="n">scheduler_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">scheduler_parser</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                <span class="c1"># Store the queue errors in the task</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span> <span class="o">=</span> <span class="n">scheduler_parser</span><span class="o">.</span><span class="n">errors</span>
                <span class="c1"># The job is killed or crashed and we know what happened</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;scheduler errors found:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">scheduler_parser</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_QCRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">lennone</span><span class="p">(</span><span class="n">qerr_info</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if only qout_info, we are not necessarily in QCRITICAL state,</span>
                <span class="c1"># since there will always be info in the qout file</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Found unknown message in the queue qerr file: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">qerr_info</span><span class="p">))</span>
                <span class="c1">#try:</span>
                <span class="c1">#    rt = self.datetimes.get_runtime().seconds</span>
                <span class="c1">#except:</span>
                <span class="c1">#    rt = -1.0</span>
                <span class="c1">#tl = self.manager.qadapter.timelimit</span>
                <span class="c1">#if rt &gt; tl:</span>
                <span class="c1">#    msg += &#39;set to error : runtime (%s) exceded walltime (%s)&#39; % (rt, tl)</span>
                <span class="c1">#    print(msg)</span>
                <span class="c1">#    return self.set_status(self.S_ERROR, msg=msg)</span>
                <span class="c1"># The job may be killed or crashed but we don&#39;t know what happened</span>
                <span class="c1"># It may also be that an innocent message was written to qerr, so we wait for a while</span>
                <span class="c1"># it is set to QCritical, we will attempt to fix it by running on more resources</span>

        <span class="c1"># 8) analyzing the err files and abinit output did not identify a problem</span>
        <span class="c1"># but if the files are not empty we do have a problem but no way of solving it:</span>
        <span class="c1"># The job is killed or crashed but we don&#39;t know what happend</span>
        <span class="c1"># it is set to QCritical, we will attempt to fix it by running on more resources</span>
        <span class="k">if</span> <span class="n">err_msg</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Found error message:</span><span class="se">\n</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1">#return self.set_status(self.S_QCRITICAL, msg=msg)</span>

        <span class="c1"># 9) if we still haven&#39;t returned there is no indication of any error and the job can only still be running</span>
        <span class="c1"># but we should actually never land here, or we have delays in the file system ....</span>
        <span class="c1"># print(&#39;the job still seems to be running maybe it is hanging without producing output... &#39;)</span>

        <span class="c1"># Check time of last modification.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">get_stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_mtime</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">frozen_timeout</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Task seems to be frozen, last change more than </span><span class="si">%s</span><span class="s2"> [s] ago&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">policy</span><span class="o">.</span><span class="n">frozen_timeout</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Handle weird case in which either run.abo, or run.log have not been produced</span>
        <span class="c1">#if self.status not in (self.S_INIT, self.S_READY) and (not self.output.file.exists or not self.log_file.exits):</span>
        <span class="c1">#    msg = &quot;Task have been submitted but cannot find the log file or the output file&quot;</span>
        <span class="c1">#    return self.set_status(self.S_ERROR, msg)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_RUN</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;final option: nothing seems to be wrong, the job must still be running&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reduce_memory_demand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that can be called by the scheduler to decrease the memory demand of a specific task.</span>
<span class="sd">        Returns True in case of success, False in case of Failure.</span>
<span class="sd">        Should be overwritten by specific tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">speed_up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that can be called by the flow to decrease the time needed for a specific task.</span>
<span class="sd">        Returns True in case of success, False in case of Failure</span>
<span class="sd">        Should be overwritten by specific tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">out_to_in</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move an output file to the output data directory of the `Task`</span>
<span class="sd">        and rename the file so that ABINIT will read it as an input data file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The absolute path of the new file in the indata directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">in_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">out_file</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="s2">&quot;in&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">in_file</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">islink</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Will overwrite </span><span class="si">%s</span><span class="s2"> with </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">out_file</span><span class="p">))</span>

        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">out_file</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dest</span>

    <span class="k">def</span> <span class="nf">inlink_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a symbolic link to the specified file in the</span>
<span class="sd">        directory containing the input files of the task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Creating symbolic link to not existent file </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filepath</span><span class="p">)</span>

        <span class="c1"># Extract the Abinit extension and add the prefix for input files.</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">abiext</span> <span class="o">=</span> <span class="n">abi_splitext</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

        <span class="n">infile</span> <span class="o">=</span> <span class="s2">&quot;in_&quot;</span> <span class="o">+</span> <span class="n">abiext</span>
        <span class="n">infile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>

        <span class="c1"># Link path to dest if dest link does not exist.</span>
        <span class="c1"># else check that it points to the expected file.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Linking path </span><span class="si">%s</span><span class="s2"> --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">infile</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">infile</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">infile</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span> <span class="o">!=</span> <span class="n">filepath</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;infile </span><span class="si">%s</span><span class="s2"> does not point to filepath </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">filepath</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create symbolic links to the output files produced by the other tasks.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This method should be called only when the calculation is READY because</span>
<span class="sd">            it uses a heuristic approach to find the file to link.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="n">filepaths</span><span class="p">,</span> <span class="n">exts</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">get_filepaths_and_exts</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">ext</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">filepaths</span><span class="p">,</span> <span class="n">exts</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Need path </span><span class="si">%s</span><span class="s2"> with ext </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ext</span><span class="p">))</span>
                <span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ipath_from_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                    <span class="c1"># Try netcdf file.</span>
                    <span class="c1"># TODO: this case should be treated in a cleaner way.</span>
                    <span class="n">path</span> <span class="o">+=</span> <span class="s2">&quot;.nc&quot;</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span> <span class="n">dest</span> <span class="o">+=</span> <span class="s2">&quot;.nc&quot;</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2"> is needed by this task but it does not exist&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dest</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">):</span> <span class="c1"># NC --&gt; NC file</span>
                    <span class="n">dest</span> <span class="o">+=</span> <span class="s2">&quot;.nc&quot;</span>

                <span class="c1"># Link path to dest if dest link does not exist.</span>
                <span class="c1"># else check that it points to the expected file.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Linking path </span><span class="si">%s</span><span class="s2"> --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dest</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># check links but only if we haven&#39;t performed the restart.</span>
                    <span class="c1"># in this case, indeed we may have replaced the file pointer with the</span>
                    <span class="c1"># previous output file of the present task.</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="o">!=</span> <span class="n">path</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_restarts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Destination:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="se">\n</span><span class="s2">does not point to path:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public method called before submitting the task.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method calls self.setup after having performed additional operations</span>
<span class="sd">        such as the creation of the symbolic links needed to connect different tasks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">make_links</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_event_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyzes the main logfile of the calculation for possible Errors or Warnings.</span>
<span class="sd">        If the ABINIT abort file is found, the error found in this file are added to</span>
<span class="sd">        the output report.</span>

<span class="sd">        Args:</span>
<span class="sd">            source: &quot;output&quot; for the main output file,&quot;log&quot; for the log file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`EventReport` instance or None if the source file file does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># By default, we inspect the main log file.</span>
        <span class="n">ofile</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;output&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">,</span>
            <span class="s2">&quot;log&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="p">}[</span><span class="n">source</span><span class="p">]</span>

        <span class="n">parser</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">EventsParser</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ofile</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpiabort_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># ABINIT abort file without log!</span>
                <span class="n">abort_report</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpiabort_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">abort_report</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">report</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">ofile</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="c1">#self._prev_reports[source] = report</span>

            <span class="c1"># Add events found in the ABI_MPIABORTFILE.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpiabort_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Found ABI_MPIABORTFILE!!!!!&quot;</span><span class="p">)</span>
                <span class="n">abort_report</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpiabort_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">abort_report</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Found more than one event in ABI_MPIABORTFILE&quot;</span><span class="p">)</span>

                <span class="c1"># Weird case: empty abort file, let&#39;s skip the part</span>
                <span class="c1"># below and hope that the log file contains the error message.</span>
                <span class="c1">#if not len(abort_report): return report</span>

                <span class="c1"># Add it to the initial report only if it differs</span>
                <span class="c1"># from the last one found in the main log file.</span>
                <span class="n">last_abort_event</span> <span class="o">=</span> <span class="n">abort_report</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">report</span> <span class="ow">and</span> <span class="n">last_abort_event</span> <span class="o">!=</span> <span class="n">report</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">report</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_abort_event</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">report</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_abort_event</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">report</span>

        <span class="c1">#except parser.Error as exc:</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c1"># Return a report with an error entry with info on the exception.</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: Exception while parsing ABINIT events:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ofile</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">report_exception</span><span class="p">(</span><span class="n">ofile</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns :class:`NodeResults` instance.</span>
<span class="sd">        Subclasses should extend this method (if needed) by adding</span>
<span class="sd">        specialized code that performs some kind of post-processing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check whether the process completed.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">returncode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;return code is None, you should call wait, communicate or poll&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_DONE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Task is not completed&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Results</span><span class="o">.</span><span class="n">from_node</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">is_abspath</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively move self.workdir to another location. This is similar to the Unix &quot;mv&quot; command.</span>
<span class="sd">        The destination path must not already exist. If the destination already exists</span>
<span class="sd">        but is not a directory, it may be overwritten depending on os.rename() semantics.</span>

<span class="sd">        Be default, dest is located in the parent directory of self.workdir.</span>
<span class="sd">        Use is_abspath=True to specify an absolute path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_abspath</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">),</span> <span class="n">dest</span><span class="p">)</span>

        <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">in_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the input data files used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">out_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the output data files produced.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">tmp_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the input data files produced.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">list_filepaths</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">path_in_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the absolute path of filename in the top-level working directory.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_basename</span><span class="p">,</span> <span class="n">dest_basename</span><span class="p">,</span> <span class="n">datadir</span><span class="o">=</span><span class="s2">&quot;outdir&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename a file located in datadir.</span>

<span class="sd">        src_basename and dest_basename are the basename of the source file</span>
<span class="sd">        and of the destination file, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">directory</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;indir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="p">,</span>
            <span class="s2">&quot;outdir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">,</span>
            <span class="s2">&quot;tmpdir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="p">,</span>
        <span class="p">}[</span><span class="n">datadir</span><span class="p">]</span>

        <span class="n">src</span> <span class="o">=</span> <span class="n">directory</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="n">src_basename</span><span class="p">)</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">directory</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="n">dest_basename</span><span class="p">)</span>

        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the working directory and the input files of the :class:`Task`.</span>
<span class="sd">        It does not overwrite files if they already exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create dirs for input, output and tmp data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">makedirs</span><span class="p">()</span>

        <span class="c1"># Write files file and input file.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filesfile_string</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">make_input</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">write_jobfile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_wildcard</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all files and directories in the working directory</span>

<span class="sd">        Args:</span>
<span class="sd">            exclude_wildcard: Optional string with regular expressions separated by |.</span>
<span class="sd">                Files matching one of the regular expressions will be preserved.</span>
<span class="sd">                example: exclude_wildcard=&quot;*.nc|*.txt&quot; preserves all the files whose extension is in [&quot;nc&quot;, &quot;txt&quot;].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_wildcard</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">WildCard</span><span class="p">(</span><span class="n">exclude_wildcard</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">dirnames</span><span class="p">,</span> <span class="n">filenames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">w</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">filenames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all the files listed in filenames.&quot;&quot;&quot;</span>
        <span class="n">filenames</span> <span class="o">=</span> <span class="n">list_strings</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">dirnames</span><span class="p">,</span> <span class="n">fnames</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clean_output_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">follow_parents</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the task reaches S_OK. It removes all the output files</span>
<span class="sd">        produced by the task that are not needed by its children as well as the output files</span>
<span class="sd">        produced by its parents if no other node needs them.</span>

<span class="sd">        Args:</span>
<span class="sd">            follow_parents: If true, the output files of the parents nodes will be removed if possible.</span>

<span class="sd">        Return:</span>
<span class="sd">            list with the absolute paths of the files that have been removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Calling task.clean_output_files on a task whose status != S_OK&quot;</span><span class="p">)</span>

        <span class="c1"># Remove all files in tmpdir.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="c1"># Find the file extensions that should be preserved since these files are still</span>
        <span class="c1"># needed by the children who haven&#39;t reached S_OK</span>
        <span class="n">except_exts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span> <span class="k">continue</span>
            <span class="c1"># Find the position of self in child.deps and add the extensions.</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">dep</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">except_exts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>

        <span class="c1"># Remove the files in the outdir of the task but keep except_exts.</span>
        <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="o">.</span><span class="n">exts</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">except_exts</span><span class="p">)</span>
        <span class="c1">#print(&quot;Will remove its extensions: &quot;, exts)</span>
        <span class="n">paths</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">remove_exts</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">follow_parents</span><span class="p">:</span> <span class="k">return</span> <span class="n">paths</span>

        <span class="c1"># Remove the files in the outdir of my parents if all the possible dependencies have been fulfilled.</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parents</span><span class="p">():</span>

            <span class="c1"># Here we build a dictionary file extension --&gt; list of child nodes requiring this file from parent</span>
            <span class="c1"># e.g {&quot;WFK&quot;: [node1, node2]}</span>
            <span class="n">ext2nodes</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">child</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span><span class="p">:</span>
                    <span class="n">ext2nodes</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

            <span class="c1"># Remove extension only if no node depends on it!</span>
            <span class="n">except_exts</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">ext2nodes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">lst</span><span class="p">]</span>
            <span class="n">exts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc</span><span class="o">.</span><span class="n">exts</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">except_exts</span><span class="p">)</span>
            <span class="c1">#print(&quot;%s removes extensions %s from parent node %s&quot; % (self, exts, parent))</span>
            <span class="n">paths</span> <span class="o">+=</span> <span class="n">parent</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">remove_exts</span><span class="p">(</span><span class="n">exts</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Removed files: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">paths</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">paths</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Base class does not provide any hook.&quot;&quot;&quot;</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starts the calculation by performing the following steps:</span>

<span class="sd">            - build dirs and files</span>
<span class="sd">            - call the _setup method</span>
<span class="sd">            - execute the job file by executing/submitting the job script.</span>

<span class="sd">        Main entry point for the `Launcher`.</span>

<span class="sd">        ==============  ==============================================================</span>
<span class="sd">        kwargs          Meaning</span>
<span class="sd">        ==============  ==============================================================</span>
<span class="sd">        autoparal       False to skip the autoparal step (default True)</span>
<span class="sd">        exec_args       List of arguments passed to executable.</span>
<span class="sd">        ==============  ==============================================================</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if task was started, 0 otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_SUB</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="s2">&quot;Task status: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Found lock file: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Started on </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup</span><span class="p">()</span>

        <span class="c1"># Add the variables needed to connect the node.</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="n">cvars</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">connecting_vars</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Adding connecting vars </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">cvars</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">cvars</span><span class="p">)</span>

            <span class="c1"># Get (python) data from other nodes</span>
            <span class="n">d</span><span class="o">.</span><span class="n">apply_getters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Automatic parallelization</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;autoparal&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;autoparal_run&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">autoparal_run</span><span class="p">()</span>
            <span class="c1">#except QueueAdapterError as exc:</span>
            <span class="c1">#    # If autoparal cannot find a qadapter to run the calculation raises an Exception</span>
            <span class="c1">#    self.history.critical(exc)</span>
            <span class="c1">#    msg = &quot;Error while trying to run autoparal in task:%s\n%s&quot; % (repr(task), straceback())</span>
            <span class="c1">#    cprint(msg, &quot;yellow&quot;)</span>
            <span class="c1">#    self.set_status(self.S_QCRITICAL, msg=msg)</span>
            <span class="c1">#    return 0</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="c1"># Sometimes autoparal_run fails because Abinit aborts</span>
                <span class="c1"># at the level of the parser e.g. cannot find the spacegroup</span>
                <span class="c1"># due to some numerical noise in the structure.</span>
                <span class="c1"># In this case we call fix_abicritical and then we try to run autoparal again.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;First call to autoparal failed with `</span><span class="si">%s</span><span class="s2">`. Will try fix_abicritical&quot;</span> <span class="o">%</span> <span class="n">exc</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;autoparal_fake_run raised:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">straceback</span><span class="p">()</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="n">fixed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix_abicritical</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">fixed</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;fix_abicritical could not solve the problem&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="mi">0</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">autoparal_run</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Second call to autoparal succeeded!&quot;</span><span class="p">)</span>
                    <span class="c1">#cprint(&quot;Second call to autoparal succeeded!&quot;, &quot;green&quot;)</span>

                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Second call to autoparal failed with </span><span class="si">%s</span><span class="s2">. Cannot recover!&quot;</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Tried autoparal again but got:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">straceback</span><span class="p">()</span>
                    <span class="n">cprint</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ABICRITICAL</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Start the calculation in a subprocess and return.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">start_and_wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to start the task and wait for completion.</span>

<span class="sd">        Mainly used when we are submitting the task via the shell without passing through a queue manager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">retcode</span>

    <span class="k">def</span> <span class="nf">get_graphviz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;automatic&quot;</span><span class="p">,</span> <span class="n">graph_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate task graph in the DOT language (only parents and children of this task).</span>

<span class="sd">        Args:</span>
<span class="sd">            engine: [&#39;dot&#39;, &#39;neato&#39;, &#39;twopi&#39;, &#39;circo&#39;, &#39;fdp&#39;, &#39;sfdp&#39;, &#39;patchwork&#39;, &#39;osage&#39;]</span>
<span class="sd">            graph_attr: Mapping of (attribute, value) pairs for the graph.</span>
<span class="sd">            node_attr: Mapping of (attribute, value) pairs set for all nodes.</span>
<span class="sd">            edge_attr: Mapping of (attribute, value) pairs set for all edges.</span>

<span class="sd">        Returns: graphviz.Digraph &lt;https://graphviz.readthedocs.io/en/stable/api.html#digraph&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># https://www.graphviz.org/doc/info/</span>
        <span class="kn">from</span> <span class="nn">graphviz</span> <span class="k">import</span> <span class="n">Digraph</span>
        <span class="n">fg</span> <span class="o">=</span> <span class="n">Digraph</span><span class="p">(</span><span class="s2">&quot;task&quot;</span><span class="p">,</span> <span class="c1"># filename=&quot;task_%s.gv&quot; % os.path.basename(self.workdir),</span>
            <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;dot&quot;</span> <span class="k">if</span> <span class="n">engine</span> <span class="o">==</span> <span class="s2">&quot;automatic&quot;</span> <span class="k">else</span> <span class="n">engine</span><span class="p">)</span>

        <span class="c1"># Set graph attributes.</span>
        <span class="c1">#fg.attr(label=&quot;%s@%s&quot; % (self.__class__.__name__, self.relworkdir))</span>
        <span class="n">fg</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="c1">#fg.attr(fontcolor=&quot;white&quot;, bgcolor=&#39;purple:pink&#39;)</span>
        <span class="c1">#fg.attr(rankdir=&quot;LR&quot;, pagedir=&quot;BL&quot;)</span>
        <span class="c1">#fg.attr(constraint=&quot;false&quot;, pack=&quot;true&quot;, packMode=&quot;clust&quot;)</span>
        <span class="n">fg</span><span class="o">.</span><span class="n">node_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;lightblue2&#39;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;filled&#39;</span><span class="p">)</span>

        <span class="c1"># Add input attributes.</span>
        <span class="k">if</span> <span class="n">graph_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fg</span><span class="o">.</span><span class="n">graph_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">graph_attr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fg</span><span class="o">.</span><span class="n">node_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">node_attr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edge_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fg</span><span class="o">.</span><span class="n">edge_attr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">edge_attr</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">node_kwargs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="c1">#shape=&quot;circle&quot;,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">color_hex</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;pos_str&quot;</span><span class="p">)</span> <span class="k">else</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">pos_str</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="n">edge_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">arrowType</span><span class="o">=</span><span class="s2">&quot;vee&quot;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s2">&quot;solid&quot;</span><span class="p">)</span>
        <span class="n">cluster_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rankdir</span><span class="o">=</span><span class="s2">&quot;LR&quot;</span><span class="p">,</span> <span class="n">pagedir</span><span class="o">=</span><span class="s2">&quot;BL&quot;</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s2">&quot;rounded&quot;</span><span class="p">,</span> <span class="n">bgcolor</span><span class="o">=</span><span class="s2">&quot;azure2&quot;</span><span class="p">)</span>

        <span class="c1"># Build cluster with tasks.</span>
        <span class="n">cluster_name</span> <span class="o">=</span> <span class="s2">&quot;cluster</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">work</span><span class="o">.</span><span class="n">name</span>
        <span class="k">with</span> <span class="n">fg</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">cluster_name</span><span class="p">)</span> <span class="k">as</span> <span class="n">wg</span><span class="p">:</span>
            <span class="n">wg</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="o">**</span><span class="n">cluster_kwargs</span><span class="p">)</span>
            <span class="n">wg</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="n">wg</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">node_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

            <span class="c1"># Connect task to children.</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
                <span class="c1"># Test if child is in the same work.</span>
                <span class="n">myg</span> <span class="o">=</span> <span class="n">wg</span> <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">work</span> <span class="k">else</span> <span class="n">fg</span>
                <span class="n">myg</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">node_kwargs</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
                <span class="c1"># Find file extensions required by this task</span>
                <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">dep</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">edge_label</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">deps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
                <span class="n">myg</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">edge_label</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">color_hex</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">edge_kwargs</span><span class="p">)</span>

            <span class="c1"># Connect task to parents</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parents</span><span class="p">():</span>
                <span class="c1"># Test if parent is in the same work.</span>
                <span class="n">myg</span> <span class="o">=</span> <span class="n">wg</span> <span class="k">if</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">work</span> <span class="k">else</span> <span class="n">fg</span>
                <span class="n">myg</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">node_kwargs</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
                <span class="c1"># Find file extensions required by self (task)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">dep</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="n">edge_label</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">exts</span><span class="p">)</span>
                <span class="n">myg</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">edge_label</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">parent</span><span class="o">.</span><span class="n">color_hex</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">edge_kwargs</span><span class="p">)</span>

        <span class="c1"># Treat the case in which we have a work producing output for other tasks.</span>
        <span class="c1">#for work in self:</span>
        <span class="c1">#    children = work.get_children()</span>
        <span class="c1">#    if not children: continue</span>
        <span class="c1">#    cluster_name = &quot;cluster%s&quot; % work.name</span>
        <span class="c1">#    seen = set()</span>
        <span class="c1">#    for child in children:</span>
        <span class="c1">#        # This is not needed, too much confusing</span>
        <span class="c1">#        #fg.edge(cluster_name, child.name, color=work.color_hex, **edge_kwargs)</span>
        <span class="c1">#        # Find file extensions required by work</span>
        <span class="c1">#        i = [dep.node for dep in child.deps].index(work)</span>
        <span class="c1">#        for ext in child.deps[i].exts:</span>
        <span class="c1">#            out = &quot;%s (%s)&quot; % (ext, work.name)</span>
        <span class="c1">#            fg.node(out)</span>
        <span class="c1">#            fg.edge(out, child.name, **edge_kwargs)</span>
        <span class="c1">#            key = (cluster_name, out)</span>
        <span class="c1">#            if key not in seen:</span>
        <span class="c1">#                fg.edge(cluster_name, out, color=work.color_hex, **edge_kwargs)</span>
        <span class="c1">#                seen.add(key)</span>

        <span class="k">return</span> <span class="n">fg</span>


<span class="k">class</span> <span class="nc">DecreaseDemandsError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    exception to be raised by a task if the request to decrease some demand, load or memory, could not be performed</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="AbinitTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask">[docs]</a><span class="k">class</span> <span class="nc">AbinitTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class defining an ABINIT calculation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Results</span> <span class="o">=</span> <span class="n">TaskResults</span>

<div class="viewcode-block" id="AbinitTask.from_input"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.from_input">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_input</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of `AbinitTask` from an ABINIT input.</span>

<span class="sd">        Args:</span>
<span class="sd">            ainput: `AbinitInput` object.</span>
<span class="sd">            workdir: Path to the working directory.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span></div>

<div class="viewcode-block" id="AbinitTask.temp_shell_task"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.temp_shell_task">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">temp_shell_task</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a Task with a temporary workdir. The task is executed via the shell with 1 MPI proc.</span>
<span class="sd">        Mainly used for invoking Abinit to get important parameters needed to prepare the real task.</span>

<span class="sd">        Args:</span>
<span class="sd">            mpi_procs: Number of MPI processes to use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Build a simple manager to run the job in a shell subprocess</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="n">workdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span> <span class="k">if</span> <span class="n">workdir</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">workdir</span>
        <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">TaskManager</span><span class="o">.</span><span class="n">from_user_config</span><span class="p">()</span>

        <span class="c1"># Construct the task and run it</span>
        <span class="n">task</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_input</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="o">.</span><span class="n">to_shell_manager</span><span class="p">(</span><span class="n">mpi_procs</span><span class="o">=</span><span class="n">mpi_procs</span><span class="p">))</span>
        <span class="n">task</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s1">&#39;temp_shell_task&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">task</span></div>

<div class="viewcode-block" id="AbinitTask.setup"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abinit has the very *bad* habit of changing the file extension by appending the characters in [A,B ..., Z]</span>
<span class="sd">        to the output file, and this breaks a lot of code that relies of the use of a unique file extension.</span>
<span class="sd">        Here we fix this issue by renaming run.abo to run.abo_[number] if the output file &quot;run.abo&quot; already</span>
<span class="sd">        exists. A few lines of code in python, a lot of problems if you try to implement this trick in Fortran90.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">rename_file</span><span class="p">(</span><span class="n">afile</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Helper function to rename :class:`File` objects. Return string for logging purpose.&quot;&quot;&quot;</span>
            <span class="c1"># Find the index of the last file (if any).</span>
            <span class="c1"># TODO: Maybe it&#39;s better to use run.abo --&gt; run(1).abo</span>
            <span class="n">fnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">afile</span><span class="o">.</span><span class="n">basename</span><span class="p">)]</span>
            <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">]</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="k">if</span> <span class="n">nums</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="n">afile</span><span class="o">.</span><span class="n">path</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">afile</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">new_path</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;Will rename </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">afile</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">new_path</span><span class="p">)</span>

        <span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span> <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rename_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span> <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rename_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">logs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">logs</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Path to the executable required for running the Task.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;abinit&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pseudos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of pseudos used in the calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">pseudos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isnc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if norm-conserving calculation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">isnc</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ispaw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if PAW calculation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">ispaw</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_gs_task</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if task is GsTask subclass.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GsTask</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_dfpt_task</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if task is a DftpTask subclass.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DfptTask</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitTask.cycle_class"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.cycle_class">[docs]</a>    <span class="nd">@lazy_property</span>
    <span class="k">def</span> <span class="nf">cycle_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the subclass of ScfCycle associated to the task or</span>
<span class="sd">        None if no SCF algorithm if associated to the task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RelaxTask</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">Relaxation</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GsTask</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">GroundStateScfCycle</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_dfpt_task</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">D2DEScfCycle</span>

        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filesfile_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the list of files and prefixes needed to execute ABINIT.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>
        <span class="n">pj</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span>

        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>                 <span class="c1"># Path to the input file</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>                <span class="c1"># Path to the output file</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">idata</span><span class="p">))</span>  <span class="c1"># Prefix for input data</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">odata</span><span class="p">))</span>  <span class="c1"># Prefix for output data</span>
        <span class="n">app</span><span class="p">(</span><span class="n">pj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">tdata</span><span class="p">))</span>  <span class="c1"># Prefix for temporary data</span>

        <span class="c1"># Paths to the pseudopotential files.</span>
        <span class="c1"># Note that here the pseudos **must** be sorted according to znucl.</span>
        <span class="c1"># Here we reorder the pseudos if the order is wrong.</span>
        <span class="n">ord_pseudos</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">znucl</span> <span class="o">=</span> <span class="p">[</span><span class="n">specie</span><span class="o">.</span><span class="n">number</span> <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">types_of_specie</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">znucl</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">Z</span> <span class="o">==</span> <span class="n">z</span><span class="p">:</span>
                    <span class="n">ord_pseudos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find pseudo with znucl </span><span class="si">%s</span><span class="s2"> in pseudos:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pseudos</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">pseudo</span> <span class="ow">in</span> <span class="n">ord_pseudos</span><span class="p">:</span>
            <span class="n">app</span><span class="p">(</span><span class="n">pseudo</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

<div class="viewcode-block" id="AbinitTask.set_pconfs"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.set_pconfs">[docs]</a>    <span class="k">def</span> <span class="nf">set_pconfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pconfs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the list of autoparal configurations.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pconfs</span> <span class="o">=</span> <span class="n">pconfs</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pconfs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;List of autoparal configurations.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pconfs</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="AbinitTask.uses_paral_kgb"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.uses_paral_kgb">[docs]</a>    <span class="k">def</span> <span class="nf">uses_paral_kgb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the task is a GS Task and uses paral_kgb with the given value.&quot;&quot;&quot;</span>
        <span class="n">paral_kgb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_inpvar</span><span class="p">(</span><span class="s2">&quot;paral_kgb&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># paral_kgb is used only in the GS part.</span>
        <span class="k">return</span> <span class="n">paral_kgb</span> <span class="o">==</span> <span class="n">value</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">GsTask</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_change_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_structure</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the input structure.&quot;&quot;&quot;</span>
        <span class="c1"># Compare new and old structure for logging purpose.</span>
        <span class="c1"># TODO: Write method of structure to compare self and other and return a dictionary</span>
        <span class="n">old_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">structure</span>
        <span class="n">old_lattice</span> <span class="o">=</span> <span class="n">old_structure</span><span class="o">.</span><span class="n">lattice</span>

        <span class="n">abc_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">abc</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">old_lattice</span><span class="o">.</span><span class="n">abc</span><span class="p">)</span>
        <span class="n">angles_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">old_lattice</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span>
        <span class="n">cart_diff</span> <span class="o">=</span> <span class="n">new_structure</span><span class="o">.</span><span class="n">cart_coords</span> <span class="o">-</span> <span class="n">old_structure</span><span class="o">.</span><span class="n">cart_coords</span>
        <span class="n">displs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cart_diff</span><span class="p">])</span>

        <span class="n">recs</span><span class="p">,</span> <span class="n">tol_angle</span><span class="p">,</span> <span class="n">tol_length</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">5</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">angles_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_angle</span><span class="p">):</span>
            <span class="n">recs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;new_agles - old_angles = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">angles_diff</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">abc_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_length</span><span class="p">):</span>
            <span class="n">recs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;new_abc - old_abc = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">abc_diff</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">displs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_length</span><span class="p">):</span>
            <span class="n">min_pos</span><span class="p">,</span> <span class="n">max_pos</span> <span class="o">=</span> <span class="n">displs</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span> <span class="n">displs</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
            <span class="n">recs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Mean displ: </span><span class="si">%.2E</span><span class="s2">, Max_displ: </span><span class="si">%.2E</span><span class="s2"> (site </span><span class="si">%d</span><span class="s2">), min_displ: </span><span class="si">%.2E</span><span class="s2"> (site </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">displs</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">displs</span><span class="p">[</span><span class="n">max_pos</span><span class="p">],</span> <span class="n">max_pos</span><span class="p">,</span> <span class="n">displs</span><span class="p">[</span><span class="n">min_pos</span><span class="p">],</span> <span class="n">min_pos</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Changing structure (only significant diffs are shown):&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">recs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Input and output structure seems to be equal within the given tolerances&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rec</span> <span class="ow">in</span> <span class="n">recs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">new_structure</span><span class="p">)</span>
        <span class="c1">#assert self.input.structure == new_structure</span>

<div class="viewcode-block" id="AbinitTask.autoparal_run"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.autoparal_run">[docs]</a>    <span class="k">def</span> <span class="nf">autoparal_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find an optimal set of parameters for the execution of the task</span>
<span class="sd">        This method can change the ABINIT input variables and/or the</span>
<span class="sd">        submission parameters e.g. the number of CPUs for MPI and OpenMp.</span>

<span class="sd">        Set:</span>
<span class="sd">           self.pconfs where pconfs is a :class:`ParalHints` object with the configuration reported by</span>
<span class="sd">           autoparal and optimal is the optimal configuration selected.</span>
<span class="sd">           Returns 0 if success</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">policy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">policy</span>

        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># or policy.max_ncpus in [None, 1]:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Nothing to do in autoparal, returning (None, None)&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;autoparal != 1&quot;</span><span class="p">)</span>

        <span class="c1">############################################################################</span>
        <span class="c1"># Run ABINIT in sequential to get the possible configurations with max_ncpus</span>
        <span class="c1">############################################################################</span>

        <span class="c1"># Set the variables for automatic parallelization</span>
        <span class="c1"># Will get all the possible configurations up to max_ncpus</span>
        <span class="c1"># Return immediately if max_ncpus == 1</span>
        <span class="n">max_ncpus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">max_cores</span>
        <span class="k">if</span> <span class="n">max_ncpus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>

        <span class="n">autoparal_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="o">=</span><span class="n">max_ncpus</span><span class="p">,</span> <span class="n">mem_test</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">autoparal_vars</span><span class="p">)</span>

        <span class="c1"># Run the job in a shell subprocess with mpi_procs = 1</span>
        <span class="c1"># we don&#39;t want to make a request to the queue manager for this simple job!</span>
        <span class="c1"># Return code is always != 0</span>
        <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">to_shell_manager</span><span class="p">(</span><span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="c1"># To avoid: ResourceWarning: unclosed file &lt;_io.BufferedReader name=87&gt; in py3k</span>
        <span class="n">process</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1">#process.stdout.close()</span>

        <span class="c1"># Remove the variables added for the automatic parallelization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">autoparal_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c1">##############################################################</span>
        <span class="c1"># Parse the autoparal configurations from the main output file</span>
        <span class="c1">##############################################################</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">ParalHintsParser</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pconfs</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">parser</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
            <span class="c1"># In principle Abinit should have written a complete log file</span>
            <span class="c1"># because we called .wait() but sometimes the Yaml doc is incomplete and</span>
            <span class="c1"># the parser raises. Let&#39;s wait 5 secs and then try again.</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pconfs</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">parser</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Error while parsing Autoparal section:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">straceback</span><span class="p">())</span>
                <span class="k">return</span> <span class="mi">2</span>

        <span class="c1">######################################################</span>
        <span class="c1"># Select the optimal configuration according to policy</span>
        <span class="c1">######################################################</span>
        <span class="n">optconf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_optconf</span><span class="p">(</span><span class="n">pconfs</span><span class="p">)</span>

        <span class="c1">####################################################</span>
        <span class="c1"># Change the input file and/or the submission script</span>
        <span class="c1">####################################################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">optconf</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>

        <span class="c1"># Write autoparal configurations to JSON file.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">pconfs</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;optimal_conf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optconf</span>
        <span class="n">json_pretty_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;autoparal.json&quot;</span><span class="p">))</span>

        <span class="c1">##############</span>
        <span class="c1"># Finalization</span>
        <span class="c1">##############</span>
        <span class="c1"># Reset the status, remove garbage files ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;finished autoparal run&#39;</span><span class="p">)</span>

        <span class="c1"># Remove the output file since Abinit likes to create new files</span>
        <span class="c1"># with extension .outA, .outB if the file already exists.</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="AbinitTask.find_optconf"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.find_optconf">[docs]</a>    <span class="k">def</span> <span class="nf">find_optconf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pconfs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the optimal Parallel configuration.&quot;&quot;&quot;</span>
        <span class="c1"># Save pconfs for future reference.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_pconfs</span><span class="p">(</span><span class="n">pconfs</span><span class="p">)</span>

        <span class="c1"># Select the partition on which we&#39;ll be running and set MPI/OMP cores.</span>
        <span class="n">optconf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">select_qadapter</span><span class="p">(</span><span class="n">pconfs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">optconf</span></div>

<div class="viewcode-block" id="AbinitTask.select_files"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.select_files">[docs]</a>    <span class="k">def</span> <span class="nf">select_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function used to select the files of a task.</span>

<span class="sd">        Args:</span>
<span class="sd">            what: string with the list of characters selecting the file type</span>
<span class="sd">                  Possible choices:</span>
<span class="sd">                    i ==&gt; input_file,</span>
<span class="sd">                    o ==&gt; output_file,</span>
<span class="sd">                    f ==&gt; files_file,</span>
<span class="sd">                    j ==&gt; job_file,</span>
<span class="sd">                    l ==&gt; log_file,</span>
<span class="sd">                    e ==&gt; stderr_file,</span>
<span class="sd">                    q ==&gt; qout_file,</span>
<span class="sd">                    all ==&gt; all files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">([</span>
            <span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">files_file</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;j&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">job_file</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;l&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qout_file</span><span class="p">),</span>
        <span class="p">])</span>

        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;path&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">choices</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

        <span class="n">selected</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">what</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">selected</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">choices</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="s2">&quot;path&quot;</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Wrong keyword </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">c</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">selected</span></div>

<div class="viewcode-block" id="AbinitTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        general restart used when scheduler problems have been taken care of</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span></div>

    <span class="c1">#@check_spectator</span>
<div class="viewcode-block" id="AbinitTask.reset_from_scratch"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.reset_from_scratch">[docs]</a>    <span class="k">def</span> <span class="nf">reset_from_scratch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restart from scratch, this is to be used if a job is restarted with more resources after a crash</span>

<span class="sd">        Move output files produced in workdir to _reset otherwise check_status continues</span>
<span class="sd">        to see the task as crashed even if the job did not run</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create reset directory if not already done.</span>
        <span class="n">reset_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;_reset&quot;</span><span class="p">)</span>
        <span class="n">reset_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reset_dir</span><span class="p">,</span> <span class="s2">&quot;_counter&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">reset_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">reset_dir</span><span class="p">)</span>
            <span class="n">num_reset</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">reset_file</span><span class="p">,</span> <span class="s2">&quot;rt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">num_reset</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

        <span class="c1"># Move files to reset and append digit with reset index.</span>
        <span class="k">def</span> <span class="nf">move_file</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span> <span class="k">return</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reset_dir</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_reset</span><span class="p">)))</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t move file </span><span class="si">{}</span><span class="s2">. exc: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;output_file&quot;</span><span class="p">,</span> <span class="s2">&quot;log_file&quot;</span><span class="p">,</span> <span class="s2">&quot;stderr_file&quot;</span><span class="p">,</span> <span class="s2">&quot;qout_file&quot;</span><span class="p">,</span> <span class="s2">&quot;qerr_file&quot;</span><span class="p">):</span>
            <span class="n">move_file</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">))</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">reset_file</span><span class="p">,</span> <span class="s2">&quot;wt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_reset</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="c1"># Reset datetimes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">(</span><span class="n">submit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="c1">#@check_spectator</span>
<div class="viewcode-block" id="AbinitTask.fix_abicritical"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.fix_abicritical">[docs]</a>    <span class="k">def</span> <span class="nf">fix_abicritical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        method to fix crashes/error caused by abinit</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if task has been fixed else 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">event_handlers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_handlers</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">event_handlers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;Empty list of event handlers. Cannot fix abi_critical errors&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">count</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">event_handlers</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">report</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_event_report</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">report</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;get_event_report returned None&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Note we have loop over all possible events (slow, I know)</span>
        <span class="c1"># because we can have handlers for Error, Bug or Warning</span>
        <span class="c1"># (ideally only for CriticalWarnings but this is not done yet)</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">report</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">handler</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_handlers</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">handler</span><span class="o">.</span><span class="n">can_handle</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">done</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;handler </span><span class="si">%s</span><span class="s2"> will try to fix event </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="n">handle_task_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
                            <span class="n">done</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">count</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;We encountered AbiCritical events that could not be fixed&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span></div>

    <span class="c1">#@check_spectator</span>
<div class="viewcode-block" id="AbinitTask.fix_queue_critical"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.fix_queue_critical">[docs]</a>    <span class="k">def</span> <span class="nf">fix_queue_critical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function tries to fix critical events originating from the queue submission system.</span>

<span class="sd">        General strategy, first try to increase resources in order to fix the problem,</span>
<span class="sd">        if this is not possible, call a task specific method to attempt to decrease the demands.</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if task has been fixed else 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pymatgen.io.abinit.scheduler_error_parsers</span> <span class="k">import</span> <span class="n">NodeFailureError</span><span class="p">,</span> <span class="n">MemoryCancelError</span><span class="p">,</span> <span class="n">TimeCancelError</span>
        <span class="c1">#assert isinstance(self.manager, TaskManager)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;fixing queue critical&#39;</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="s2">&quot;task.fix_queue_critical: &quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span><span class="p">:</span>
            <span class="c1"># TODO</span>
            <span class="c1"># paral_kgb = 1 leads to nasty sigegv that are seen as Qcritical errors!</span>
            <span class="c1"># Try to fallback to the conjugate gradient.</span>
            <span class="c1">#if self.uses_paral_kgb(1):</span>
            <span class="c1">#    logger.critical(&quot;QCRITICAL with PARAL_KGB==1. Will try CG!&quot;)</span>
            <span class="c1">#    self.set_vars(paral_kgb=0)</span>
            <span class="c1">#    self.reset_from_scratch()</span>
            <span class="c1">#    return</span>
            <span class="c1"># queue error but no errors detected, try to solve by increasing ncpus if the task scales</span>
            <span class="c1"># if resources are at maximum the task is definitively turned to errored</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_scales</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_scales</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_resources</span><span class="p">()</span>  <span class="c1"># acts either on the policy or on the qadapter</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                    <span class="n">ret</span> <span class="o">+=</span> <span class="s2">&quot;increased resources&quot;</span>
                    <span class="k">return</span> <span class="n">ret</span>
                <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;unknown queue error, could not increase resources any further&#39;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;unknown queue error, no options left&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fix_qcritical: received </span><span class="si">%d</span><span class="s2"> queue_errors&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;type_list: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">qe</span><span class="p">)</span> <span class="k">for</span> <span class="n">qe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;fixing: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">NodeFailureError</span><span class="p">):</span>
                    <span class="c1"># if the problematic node is known, exclude it</span>
                    <span class="k">if</span> <span class="n">error</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">exclude_nodes</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;excluding nodes&#39;</span><span class="p">)</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;Node error but no node identified.&#39;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">MemoryCancelError</span><span class="p">):</span>
                    <span class="c1"># ask the qadapter to provide more resources, i.e. more cpu&#39;s so more total memory if the code</span>
                    <span class="c1"># scales this should fix the memeory problem</span>
                    <span class="c1"># increase both max and min ncpu of the autoparalel and rerun autoparalel</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_scales</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_ncpus</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;increased ncps to solve memory problem&#39;</span><span class="p">)</span>
                            <span class="k">return</span>
                        <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;increasing ncpus failed&#39;</span><span class="p">)</span>

                    <span class="c1"># if the max is reached, try to increase the memory per cpu:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_mem</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;increased mem&#39;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;increasing mem failed&#39;</span><span class="p">)</span>

                    <span class="c1"># if this failed ask the task to provide a method to reduce the memory demand</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reduce_memory_demand</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;decreased mem demand&#39;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="n">DecreaseDemandsError</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;decreasing demands failed&#39;</span><span class="p">)</span>

                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Memory error detected but the memory could not be increased neither could the</span><span class="se">\n</span><span class="s1">&#39;</span>
                           <span class="s1">&#39;memory demand be decreased. Unrecoverable error.&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">TimeCancelError</span><span class="p">):</span>
                    <span class="c1"># ask the qadapter to provide more time</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;trying to increase time&#39;</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_time</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;increased wall time&#39;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;increasing the waltime failed&#39;</span><span class="p">)</span>

                    <span class="c1"># if this fails ask the qadapter to increase the number of cpus</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_scales</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_ncpus</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;increased number of cpus&#39;</span><span class="p">)</span>
                            <span class="k">return</span>
                        <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;increase ncpus to speed up the calculation to stay in the walltime failed&#39;</span><span class="p">)</span>

                    <span class="c1"># if this failed ask the task to provide a method to speed up the task</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">speed_up</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;task speedup&#39;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="n">DecreaseDemandsError</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;decreasing demands failed&#39;</span><span class="p">)</span>

                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Time cancel error detected but the time could not be increased neither could</span><span class="se">\n</span><span class="s1">&#39;</span>
                           <span class="s1">&#39;the time demand be decreased by speedup of increasing the number of cpus.</span><span class="se">\n</span><span class="s1">&#39;</span>
                           <span class="s1">&#39;Unrecoverable error.&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;No solution provided for error </span><span class="si">%s</span><span class="s1">. Unrecoverable error.&#39;</span> <span class="o">%</span> <span class="n">error</span><span class="o">.</span><span class="n">name</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="AbinitTask.parse_timing"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AbinitTask.parse_timing">[docs]</a>    <span class="k">def</span> <span class="nf">parse_timing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the timer data in the main output file of Abinit.</span>
<span class="sd">        Requires timopt /= 0 in the input file (usually timopt = -1)</span>

<span class="sd">        Return: :class:`AbinitTimerParser` instance, None if error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.abitimer</span> <span class="k">import</span> <span class="n">AbinitTimerParser</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">AbinitTimerParser</span><span class="p">()</span>
        <span class="n">read_ok</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">read_ok</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parser</span>
        <span class="k">return</span> <span class="kc">None</span></div></div>


<span class="k">class</span> <span class="nc">ProduceHist</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class for an :class:`AbinitTask` producing a HIST file.</span>
<span class="sd">    Provide the method `open_hist` that reads and return a HIST file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hist_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the HIST file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c1"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_path</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;HIST&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the HIST file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`HistFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> reached S_OK but didn&#39;t produce a HIST file in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Open the HIST file</span>
        <span class="kn">from</span> <span class="nn">abipy.dynamics.hist</span> <span class="k">import</span> <span class="n">HistFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">HistFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Exception while reading HIST file at </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">GsTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for ground-state tasks. A ground state task produces a GSR file</span>
<span class="sd">    Provides the method `open_gsr` that reads and returns a GSR file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gsr_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the GSR file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c1"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsr_path</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;GSR&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gsr_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_gsr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the GSR file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`GsrFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gsr_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsr_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">gsr_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> reached S_OK but didn&#39;t produce a GSR file in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Open the GSR file.</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.gsr</span> <span class="k">import</span> <span class="n">GsrFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GsrFile</span><span class="p">(</span><span class="n">gsr_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Exception while reading GSR file at </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">gsr_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="kc">None</span>


<div class="viewcode-block" id="ScfTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ScfTask">[docs]</a><span class="k">class</span> <span class="nc">ScfTask</span><span class="p">(</span><span class="n">GsTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Self-consistent ground-state calculations.</span>
<span class="sd">    Provide support for in-place restart via (WFK|DEN) files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">ScfConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

<div class="viewcode-block" id="ScfTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ScfTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;SCF calculations can be restarted if we have either the WFK file or the DEN file.&quot;&quot;&quot;</span>
        <span class="c1"># Prefer WFK over DEN files since we can reuse the wavefunctions.</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;WFK&quot;</span><span class="p">,</span> <span class="s2">&quot;DEN&quot;</span><span class="p">):</span>
            <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">restart_file</span><span class="p">:</span> <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: Cannot find WFK or DEN file to restart from.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Move out --&gt; in.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c1"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c1"># Now we can resubmit the job.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Will restart from </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">restart_file</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span></div>

<div class="viewcode-block" id="ScfTask.inspect"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ScfTask.inspect">[docs]</a>    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the SCF cycle results with matplotlib.</span>

<span class="sd">        Returns</span>
<span class="sd">            `matplotlib` figure, None if some error occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">scf_cycle</span> <span class="o">=</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">GroundStateScfCycle</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">scf_cycle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;title&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">scf_cycle</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="ScfTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ScfTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ScfTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Open the GSR file and add its data to results.out</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;out&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gsr</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>
            <span class="c1"># Add files to GridFS</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">GSR</span><span class="o">=</span><span class="n">gsr</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div></div>


<span class="k">class</span> <span class="nc">CollinearThenNonCollinearScfTask</span><span class="p">(</span><span class="n">ScfTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A specialized ScfTaks that performs an initial SCF run with nsppol = 2.</span>
<span class="sd">    The spin polarized WFK file is then used to start a non-collinear SCF run (nspinor == 2)</span>
<span class="sd">    initialized from the previous WFK file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CollinearThenNonCollinearScfTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>
        <span class="c1"># Enforce nspinor = 1, nsppol = 2 and prtwf = 1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">set_spin_mode</span><span class="p">(</span><span class="s2">&quot;polarized&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">prtwf</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collinear_done</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CollinearThenNonCollinearScfTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_on_ok</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">collinear_done</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">set_spin_mode</span><span class="p">(</span><span class="s2">&quot;spinor&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collinear_done</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restart</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">results</span>


<div class="viewcode-block" id="NscfTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.NscfTask">[docs]</a><span class="k">class</span> <span class="nc">NscfTask</span><span class="p">(</span><span class="n">GsTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Non-Self-consistent GS calculation. Provide in-place restart via WFK files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">NscfConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">200</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

<div class="viewcode-block" id="NscfTask.setup"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.NscfTask.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NSCF calculations should use the same FFT mesh as the one employed in the GS task</span>
<span class="sd">        (in principle, it&#39;s possible to interpolate inside Abinit but tests revealed some numerical noise</span>
<span class="sd">        Here we change the input file of the NSCF task to have the same FFT mesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;DEN&quot;</span> <span class="ow">in</span> <span class="n">dep</span><span class="o">.</span><span class="n">exts</span><span class="p">:</span>
                <span class="n">parent_task</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">node</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot find parent node producing DEN file&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">parent_task</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="n">den_mesh</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="n">den_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">gsr</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">read_dimvalue</span><span class="p">(</span><span class="s2">&quot;number_of_grid_points_vector1&quot;</span><span class="p">)</span>
            <span class="n">den_mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">gsr</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">read_dimvalue</span><span class="p">(</span><span class="s2">&quot;number_of_grid_points_vector2&quot;</span><span class="p">)</span>
            <span class="n">den_mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">gsr</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">read_dimvalue</span><span class="p">(</span><span class="s2">&quot;number_of_grid_points_vector3&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ispaw</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ngfftdg</span><span class="o">=</span><span class="n">den_mesh</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">ngfft</span><span class="o">=</span><span class="n">den_mesh</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">NscfTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span></div>

<div class="viewcode-block" id="NscfTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.NscfTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;NSCF calculations can be restarted only if we have the WFK file.&quot;&quot;&quot;</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s2">&quot;WFK&quot;</span>
        <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">restart_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: Cannot find the WFK file to restart from.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Move out --&gt; in.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c1"># Add the appropriate variable for restarting.</span>
        <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c1"># Now we can resubmit the job.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Will restart from </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">restart_file</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span></div>

<div class="viewcode-block" id="NscfTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.NscfTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">NscfTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Read the GSR file.</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;out&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gsr</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>
            <span class="c1"># Add files to GridFS</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">GSR</span><span class="o">=</span><span class="n">gsr</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div></div>


<div class="viewcode-block" id="RelaxTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.RelaxTask">[docs]</a><span class="k">class</span> <span class="nc">RelaxTask</span><span class="p">(</span><span class="n">GsTask</span><span class="p">,</span> <span class="n">ProduceHist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Task for structural optimizations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO possible ScfConvergenceWarning?</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">RelaxConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

<div class="viewcode-block" id="RelaxTask.get_final_structure"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.RelaxTask.get_final_structure">[docs]</a>    <span class="k">def</span> <span class="nf">get_final_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read the final structure from the GSR file.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">gsr</span><span class="o">.</span><span class="n">structure</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot find the GSR file with the final structure to restart from.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="RelaxTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.RelaxTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restart the structural relaxation.</span>

<span class="sd">        Structure relaxations can be restarted only if we have the WFK file or the DEN or the GSR file</span>
<span class="sd">        from which we can read the last structure (mandatory) and the wavefunctions (not mandatory but useful).</span>
<span class="sd">        Prefer WFK over other files since we can reuse the wavefunctions.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The problem in the present approach is that some parameters in the input</span>
<span class="sd">            are computed from the initial structure and may not be consistent with</span>
<span class="sd">            the modification of the structure done during the structure relaxation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">restart_file</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Try to restart from the WFK file if possible.</span>
        <span class="c1"># FIXME: This part has been disabled because WFK=IO is a mess if paral_kgb == 1</span>
        <span class="c1"># This is also the reason why I wrote my own MPI-IO code for the GW part!</span>
        <span class="n">wfk_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;WFK&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">wfk_file</span><span class="p">:</span>
            <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="s2">&quot;WFK&quot;</span><span class="p">)</span>
            <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">wfk_file</span><span class="p">)</span>

        <span class="c1"># Fallback to DEN file. Note that here we look for out_DEN instead of out_TIM?_DEN</span>
        <span class="c1"># This happens when the previous run completed and task.on_done has been performed.</span>
        <span class="c1"># ********************************************************************************</span>
        <span class="c1"># Note that it&#39;s possible to have an undetected error if we have multiple restarts</span>
        <span class="c1"># and the last relax died badly. In this case indeed out_DEN is the file produced</span>
        <span class="c1"># by the last run that has executed on_done.</span>
        <span class="c1"># ********************************************************************************</span>
        <span class="k">if</span> <span class="n">restart_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;.nc&quot;</span><span class="p">):</span>
                <span class="n">out_den</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;out_DEN&quot;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">out_den</span><span class="p">):</span>
                    <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="s2">&quot;DEN&quot;</span><span class="p">)</span>
                    <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">out_den</span><span class="p">)</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">restart_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Try to restart from the last TIM?_DEN file.</span>
            <span class="c1"># This should happen if the previous run didn&#39;t complete in clean way.</span>
            <span class="c1"># Find the last TIM?_DEN file.</span>
            <span class="n">last_timden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">find_last_timden_file</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">last_timden</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">last_timden</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">):</span>
                    <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;out_DEN.nc&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;out_DEN&quot;</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">last_timden</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">ofile</span><span class="p">)</span>
                <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>
                <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="s2">&quot;DEN&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">restart_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Don&#39;t raise RestartError as we can still change the structure.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot find the WFK|DEN|TIM?_DEN file to restart from.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Add the appropriate variable for restarting.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Will restart from </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">restart_file</span><span class="p">)</span>

        <span class="c1"># FIXME Here we should read the HIST file but restartxf if broken!</span>
        <span class="c1">#self.set_vars({&quot;restartxf&quot;: -1})</span>

        <span class="c1"># Read the relaxed structure from the GSR file and change the input.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_change_structure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_final_structure</span><span class="p">())</span>

        <span class="c1"># Now we can resubmit the job.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span></div>

<div class="viewcode-block" id="RelaxTask.inspect"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.RelaxTask.inspect">[docs]</a>    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the evolution of the structural relaxation with matplotlib.</span>

<span class="sd">        Args:</span>
<span class="sd">            what: Either &quot;hist&quot; or &quot;scf&quot;. The first option (default) extracts data</span>
<span class="sd">                from the HIST file and plot the evolution of the structural</span>
<span class="sd">                parameters, forces, pressures and energies.</span>
<span class="sd">                The second option, extracts data from the main output file and</span>
<span class="sd">                plot the evolution of the SCF cycles (etotal, residuals, etc).</span>

<span class="sd">        Returns:</span>
<span class="sd">            `matplotlib` figure, None if some error occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">what</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;what&quot;</span><span class="p">,</span> <span class="s2">&quot;hist&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;hist&quot;</span><span class="p">:</span>
            <span class="c1"># Read the hist file to get access to the structure.</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_hist</span><span class="p">()</span> <span class="k">as</span> <span class="n">hist</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hist</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">hist</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;scf&quot;</span><span class="p">:</span>
            <span class="c1"># Get info on the different SCF cycles</span>
            <span class="n">relaxation</span> <span class="o">=</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">Relaxation</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;title&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">relaxation</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">relaxation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong value for what </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">what</span><span class="p">)</span></div>

<div class="viewcode-block" id="RelaxTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.RelaxTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">RelaxTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Open the GSR file and add its data to results.out</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_gsr</span><span class="p">()</span> <span class="k">as</span> <span class="n">gsr</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;out&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gsr</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>
            <span class="c1"># Add files to GridFS</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">GSR</span><span class="o">=</span><span class="n">gsr</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="RelaxTask.reduce_dilatmx"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.RelaxTask.reduce_dilatmx">[docs]</a>    <span class="k">def</span> <span class="nf">reduce_dilatmx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mf">1.01</span><span class="p">):</span>
        <span class="n">actual_dilatmx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_inpvar</span><span class="p">(</span><span class="s1">&#39;dilatmx&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="n">new_dilatmx</span> <span class="o">=</span> <span class="n">actual_dilatmx</span> <span class="o">-</span> <span class="nb">min</span><span class="p">((</span><span class="n">actual_dilatmx</span><span class="o">-</span><span class="n">target</span><span class="p">),</span> <span class="n">actual_dilatmx</span><span class="o">*</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">dilatmx</span><span class="o">=</span><span class="n">new_dilatmx</span><span class="p">)</span></div>

<div class="viewcode-block" id="RelaxTask.fix_ofiles"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.RelaxTask.fix_ofiles">[docs]</a>    <span class="k">def</span> <span class="nf">fix_ofiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Note that ABINIT produces lots of out_TIM1_DEN files for each step.</span>
<span class="sd">        Here we list all TIM*_DEN files, we select the last one and we rename it in out_DEN</span>

<span class="sd">        This change is needed so that we can specify dependencies with the syntax {node: &quot;DEN&quot;}</span>
<span class="sd">        without having to know the number of iterations needed to converge the run in node!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RelaxTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">fix_ofiles</span><span class="p">()</span>

        <span class="c1"># Find the last TIM?_DEN file.</span>
        <span class="n">last_timden</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">find_last_timden_file</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">last_timden</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot find TIM?_DEN files&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Rename last TIMDEN with out_DEN.</span>
        <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;out_DEN&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">last_timden</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.nc&quot;</span><span class="p">):</span> <span class="n">ofile</span> <span class="o">+=</span> <span class="s2">&quot;.nc&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Renaming last_denfile </span><span class="si">%s</span><span class="s2"> --&gt; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">last_timden</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">ofile</span><span class="p">))</span>
        <span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">last_timden</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">ofile</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">DfptTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for DFPT tasks (Phonons, DdeTask, DdkTask, ElasticTask ...)</span>
<span class="sd">    Mainly used to implement methods that are common to DFPT calculations with Abinit.</span>
<span class="sd">    Provide the method `open_ddb` that reads and return a Ddb file.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This class should not be instantiated directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO:</span>
    <span class="c1"># for the time being we don&#39;t discern between GS and PhononCalculations.</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">ScfConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Get info about DFT perturbation from input file.</span>
        <span class="n">qpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;qpt&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">rfphon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfphon&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">rfatpol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfatpol&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">rfelfd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfelfd&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">rfstrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfstrs&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">rfdir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rfdir&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">irdddk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;irdddk&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">dfpt_info</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rfphon</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dfpt_info</span> <span class="o">=</span> <span class="s2">&quot;qpt: </span><span class="si">{}</span><span class="s2">, rfphon: </span><span class="si">{}</span><span class="s2">, rfatpol: </span><span class="si">{}</span><span class="s2">, rfdir: </span><span class="si">{}</span><span class="s2">, irdddk: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">qpt</span><span class="p">,</span> <span class="n">rfphon</span><span class="p">,</span> <span class="n">rfatpol</span><span class="p">,</span> <span class="n">rfdir</span><span class="p">,</span> <span class="n">irdddk</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">rfelfd</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dfpt_info</span> <span class="o">=</span> <span class="s2">&quot;qpt: </span><span class="si">{}</span><span class="s2">, rfelfd: </span><span class="si">{}</span><span class="s2"> rfdir: </span><span class="si">{}</span><span class="s2">, irdddk: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">qpt</span><span class="p">,</span> <span class="n">rfelfd</span><span class="p">,</span> <span class="n">rfdir</span><span class="p">,</span> <span class="n">irdddk</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">rfstrs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dfpt_info</span> <span class="o">=</span> <span class="s2">&quot;qpt: </span><span class="si">{}</span><span class="s2">, rfstrs: </span><span class="si">{}</span><span class="s2">, rfdir: </span><span class="si">{}</span><span class="s2">, irdddk: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">qpt</span><span class="p">,</span> <span class="n">rfstrs</span><span class="p">,</span> <span class="n">rfdir</span><span class="p">,</span> <span class="n">irdddk</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">, node_id=</span><span class="si">%s</span><span class="s2">, workdir=</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">relworkdir</span><span class="p">,</span> <span class="n">dfpt_info</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># this usually happens when workdir has not been initialized</span>
            <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">, node_id=</span><span class="si">%s</span><span class="s2">, workdir=None, </span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_id</span><span class="p">,</span> <span class="n">dfpt_info</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddb_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the DDB file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c1"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ddb_path</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DDB&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ddb_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_ddb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the DDB file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`DdbFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ddb_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddb_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ddb_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> reached S_OK but didn&#39;t produce a DDB file in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Open the DDB file.</span>
        <span class="kn">from</span> <span class="nn">abipy.dfpt.ddb</span> <span class="k">import</span> <span class="n">DdbFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DdbFile</span><span class="p">(</span><span class="n">ddb_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Exception while reading DDB file at </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ddb_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the default behaviour of make_links. More specifically, this method</span>
<span class="sd">        implements the logic required to connect DFPT calculation to `DDK` files.</span>
<span class="sd">        Remember that DDK is an extension introduced in AbiPy to deal with the</span>
<span class="sd">        irdddk input variable and the fact that the 3 files with du/dk produced by Abinit</span>
<span class="sd">        have a file extension constructed from the number of atom (e.g. 1WF[3natom +1]).</span>

<span class="sd">        AbiPy uses the user-friendly syntax deps={node: &quot;DDK&quot;} to specify that</span>
<span class="sd">        the children will read the DDK from `node` but this also means that</span>
<span class="sd">        we have to implement extract logic to handle this case at runtime.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deps</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dep</span><span class="o">.</span><span class="n">exts</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="s2">&quot;DDK&quot;</span><span class="p">:</span>
                    <span class="n">ddk_task</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">node</span>
                    <span class="n">out_ddk</span> <span class="o">=</span> <span class="n">ddk_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DDK&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">out_ddk</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> didn&#39;t produce the DDK file&quot;</span> <span class="o">%</span> <span class="n">ddk_task</span><span class="p">)</span>

                    <span class="c1"># Get (fortran) idir and costruct the name of the 1WF expected by Abinit</span>
                    <span class="n">rfdir</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ddk_task</span><span class="o">.</span><span class="n">input</span><span class="p">[</span><span class="s2">&quot;rfdir&quot;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">rfdir</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Only one direction should be specifned in rfdir but rfdir = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">rfdir</span><span class="p">)</span>

                    <span class="n">idir</span> <span class="o">=</span> <span class="n">rfdir</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">ddk_case</span> <span class="o">=</span> <span class="n">idir</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ddk_task</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>

                    <span class="n">infile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;in_1WF</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ddk_case</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">out_ddk</span><span class="p">,</span> <span class="n">infile</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="s2">&quot;WFK&quot;</span><span class="p">:</span>
                    <span class="n">gs_task</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">node</span>
                    <span class="n">out_wfk</span> <span class="o">=</span> <span class="n">gs_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;WFK&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">out_wfk</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> didn&#39;t produce the WFK file&quot;</span> <span class="o">%</span> <span class="n">gs_task</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;in_WFK&quot;</span><span class="p">)):</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">out_wfk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;in_WFK&quot;</span><span class="p">))</span>

                <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="s2">&quot;DEN&quot;</span><span class="p">:</span>
                    <span class="n">gs_task</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">node</span>
                    <span class="n">out_wfk</span> <span class="o">=</span> <span class="n">gs_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DEN&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">out_wfk</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> didn&#39;t produce the DEN file&quot;</span> <span class="o">%</span> <span class="n">gs_task</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;in_DEN&quot;</span><span class="p">)):</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">out_wfk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;in_DEN&quot;</span><span class="p">))</span>

                <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="s2">&quot;1WF&quot;</span><span class="p">:</span>
                    <span class="n">gs_task</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">node</span>
                    <span class="n">out_wfk</span> <span class="o">=</span> <span class="n">gs_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;1WF&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">out_wfk</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> didn&#39;t produce the 1WF file&quot;</span> <span class="o">%</span> <span class="n">gs_task</span><span class="p">)</span>
                    <span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;in_&quot;</span> <span class="o">+</span> <span class="n">out_wfk</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">out_wfk</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="s2">&quot;1DEN&quot;</span><span class="p">:</span>
                    <span class="n">gs_task</span> <span class="o">=</span> <span class="n">dep</span><span class="o">.</span><span class="n">node</span>
                    <span class="n">out_wfk</span> <span class="o">=</span> <span class="n">gs_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DEN&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">out_wfk</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> didn&#39;t produce the 1DEN file&quot;</span> <span class="o">%</span> <span class="n">gs_task</span><span class="p">)</span>
                    <span class="n">dest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">path_in</span><span class="p">(</span><span class="s2">&quot;in_&quot;</span> <span class="o">+</span> <span class="n">out_wfk</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dest</span><span class="p">):</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">symlink</span><span class="p">(</span><span class="n">out_wfk</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to handle extension: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">dep</span><span class="o">.</span><span class="n">exts</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">DdeTask</span><span class="p">(</span><span class="n">DfptTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Task for DDE calculations (perturbation wrt electric field).&quot;&quot;&quot;</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">61</span><span class="p">,</span> <span class="mi">158</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DdeTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_file</span><span class="p">(</span><span class="n">DDB</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DDE&quot;</span><span class="p">),</span> <span class="s2">&quot;t&quot;</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">DteTask</span><span class="p">(</span><span class="n">DfptTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Task for DTE calculations.&quot;&quot;&quot;</span>
    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">204</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">204</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="c1"># @check_spectator</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;autoparal&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">DteTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DteTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_file</span><span class="p">(</span><span class="n">DDB</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DDE&quot;</span><span class="p">),</span> <span class="s2">&quot;t&quot;</span><span class="p">))</span>


<div class="viewcode-block" id="DdkTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.DdkTask">[docs]</a><span class="k">class</span> <span class="nc">DdkTask</span><span class="p">(</span><span class="n">DfptTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Task for DDK calculations.&quot;&quot;&quot;</span>
    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">204</span><span class="p">,</span> <span class="mi">204</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="c1">#@check_spectator</span>
    <span class="k">def</span> <span class="nf">_on_ok</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DdkTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_on_ok</span><span class="p">()</span>
        <span class="c1"># Client code expects to find du/dk in DDK file.</span>
        <span class="c1"># Here I create a symbolic link out_1WF13 --&gt; out_DDK</span>
        <span class="c1"># so that we can use deps={ddk_task: &quot;DDK&quot;} in the high-level API.</span>
        <span class="c1"># The price to pay is that we have to handle the DDK extension in make_links.</span>
        <span class="c1"># See DfptTask.make_links</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">symlink_abiext</span><span class="p">(</span><span class="s1">&#39;1WF&#39;</span><span class="p">,</span> <span class="s1">&#39;DDK&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="DdkTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.DdkTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">DdkTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_file</span><span class="p">(</span><span class="n">DDK</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DDK&quot;</span><span class="p">),</span> <span class="s2">&quot;t&quot;</span><span class="p">))</span></div></div>


<span class="k">class</span> <span class="nc">BecTask</span><span class="p">(</span><span class="n">DfptTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Task for the calculation of Born effective charges.</span>

<span class="sd">    bec_deps = {ddk_task: &quot;DDK&quot; for ddk_task in ddk_tasks}</span>
<span class="sd">    bec_deps.update({scf_task: &quot;WFK&quot;})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">122</span><span class="p">,</span> <span class="mi">122</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>


<div class="viewcode-block" id="PhononTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.PhononTask">[docs]</a><span class="k">class</span> <span class="nc">PhononTask</span><span class="p">(</span><span class="n">DfptTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DFPT calculations for a single atomic perturbation.</span>
<span class="sd">    Provide support for in-place restart via (1WF|1DEN) files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">250</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

<div class="viewcode-block" id="PhononTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.PhononTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Phonon calculations can be restarted only if we have the 1WF file or the 1DEN file.</span>
<span class="sd">        from which we can read the first-order wavefunctions or the first order density.</span>
<span class="sd">        Prefer 1WF over 1DEN since we can reuse the wavefunctions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Abinit adds the idir-ipert index at the end of the file and this breaks the extension</span>
        <span class="c1"># e.g. out_1WF4, out_DEN4. find_1wf_files and find_1den_files returns the list of files found</span>
        <span class="n">restart_file</span><span class="p">,</span> <span class="n">irdvars</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># Highest priority to the 1WF file because restart is more efficient.</span>
        <span class="n">wf_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">find_1wf_files</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">wf_files</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">restart_file</span> <span class="o">=</span> <span class="n">wf_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">path</span>
            <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="s2">&quot;1WF&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wf_files</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">restart_file</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Found more than one 1WF file. Restart is ambiguous!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">restart_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">den_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">find_1den_files</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">den_files</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">restart_file</span> <span class="o">=</span> <span class="n">den_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">path</span>
                <span class="n">irdvars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ird1den&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">den_files</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">restart_file</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Found more than one 1DEN file. Restart is ambiguous!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">restart_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Raise because otherwise restart is equivalent to a run from scratch --&gt; infinite loop!</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: Cannot find the 1WF|1DEN file to restart from.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Move file.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Will restart from </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">restart_file</span><span class="p">)</span>
        <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c1"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c1"># Now we can resubmit the job.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span></div>

<div class="viewcode-block" id="PhononTask.inspect"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.PhononTask.inspect">[docs]</a>    <span class="k">def</span> <span class="nf">inspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the Phonon SCF cycle results with matplotlib.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `matplotlib` figure, None if some error occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scf_cycle</span> <span class="o">=</span> <span class="n">abiinspect</span><span class="o">.</span><span class="n">PhononScfCycle</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scf_cycle</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;title&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">scf_cycle</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PhononTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.PhononTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PhononTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">DDB</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DDB&quot;</span><span class="p">),</span> <span class="s2">&quot;t&quot;</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="ElasticTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.ElasticTask">[docs]</a><span class="k">class</span> <span class="nc">ElasticTask</span><span class="p">(</span><span class="n">DfptTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DFPT calculations for a single strain perturbation (uniaxial or shear strain).</span>
<span class="sd">    Provide support for in-place restart via (1WF|1DEN) files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">204</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span></div>


<div class="viewcode-block" id="EphTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.EphTask">[docs]</a><span class="k">class</span> <span class="nc">EphTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for electron-phonon calculations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span></div>


<span class="k">class</span> <span class="nc">ManyBodyTask</span><span class="p">(</span><span class="n">AbinitTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for Many-body tasks (Screening, Sigma, Bethe-Salpeter)</span>
<span class="sd">    Mainly used to implement methods that are common to MBPT calculations with Abinit.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This class should not be instantiated directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">reduce_memory_demand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method that can be called by the scheduler to decrease the memory demand of a specific task.</span>
<span class="sd">        Returns True in case of success, False in case of Failure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The first digit governs the storage of W(q), the second digit the storage of u(r)</span>
        <span class="c1"># Try to avoid the storage of u(r) first since reading W(q) from file will lead to a drammatic slowdown.</span>
        <span class="n">prev_gwmem</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_inpvar</span><span class="p">(</span><span class="s2">&quot;gwmem&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">11</span><span class="p">))</span>
        <span class="n">first_dig</span><span class="p">,</span> <span class="n">second_dig</span> <span class="o">=</span> <span class="n">prev_gwmem</span> <span class="o">//</span> <span class="mi">10</span><span class="p">,</span> <span class="n">prev_gwmem</span> <span class="o">%</span> <span class="mi">10</span>

        <span class="k">if</span> <span class="n">second_dig</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">gwmem</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%.2d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">first_dig</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">first_dig</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">gwmem</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%.2d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="mi">00</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># gwmem 00 d&#39;oh!</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">ScrTask</span><span class="p">(</span><span class="n">ManyBodyTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tasks for SCREENING calculations &quot;&quot;&quot;</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="c1">#def inspect(self, **kwargs):</span>
    <span class="c1">#    &quot;&quot;&quot;Plot graph showing the number of q-points computed and the wall-time used&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scr_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the SCR file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c1"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scr_path</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;SCR.nc&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scr_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_scr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the SIGRES file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`ScrFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scr_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scr_path</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">scr_path</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> didn&#39;t produce a SCR.nc file in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Open the GSR file and add its data to results.out</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.scr</span> <span class="k">import</span> <span class="n">ScrFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ScrFile</span><span class="p">(</span><span class="n">scr_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Exception while reading SCR file at </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">scr_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="kc">None</span>


<div class="viewcode-block" id="SigmaTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.SigmaTask">[docs]</a><span class="k">class</span> <span class="nc">SigmaTask</span><span class="p">(</span><span class="n">ManyBodyTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tasks for SIGMA calculations. Provides support for in-place restart via QPS files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">QPSConvergenceWarning</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

<div class="viewcode-block" id="SigmaTask.restart"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.SigmaTask.restart">[docs]</a>    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># G calculations can be restarted only if we have the QPS file</span>
        <span class="c1"># from which we can read the results of the previous step.</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s2">&quot;QPS&quot;</span>
        <span class="n">restart_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">restart_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: Cannot find the QPS file to restart from.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">restart_file</span><span class="p">)</span>

        <span class="c1"># Add the appropriate variable for restarting.</span>
        <span class="n">irdvars</span> <span class="o">=</span> <span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c1"># Now we can resubmit the job.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Will restart from </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">restart_file</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span></div>

    <span class="c1">#def inspect(self, **kwargs):</span>
    <span class="c1">#    &quot;&quot;&quot;Plot graph showing the number of k-points computed and the wall-time used&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sigres_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the SIGRES file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c1"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigres_path</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;SIGRES&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigres_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

<div class="viewcode-block" id="SigmaTask.open_sigres"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.SigmaTask.open_sigres">[docs]</a>    <span class="k">def</span> <span class="nf">open_sigres</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the SIGRES file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`SigresFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigres_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigres_path</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sigres_path</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> didn&#39;t produce a SIGRES file in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Open the SIGRES file and add its data to results.out</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.gw</span> <span class="k">import</span> <span class="n">SigresFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SigresFile</span><span class="p">(</span><span class="n">sigres_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Exception while reading SIGRES file at </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sigres_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="SigmaTask.get_scissors_builder"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.SigmaTask.get_scissors_builder">[docs]</a>    <span class="k">def</span> <span class="nf">get_scissors_builder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an instance of :class:`ScissorsBuilder` from the SIGRES file.</span>

<span class="sd">        Raise:</span>
<span class="sd">            `RuntimeError` if SIGRES file is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.scissors</span> <span class="k">import</span> <span class="n">ScissorsBuilder</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigres_path</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ScissorsBuilder</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigres_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot find SIGRES file!&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SigmaTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.SigmaTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SigmaTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Open the SIGRES file and add its data to results.out</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_sigres</span><span class="p">()</span> <span class="k">as</span> <span class="n">sigres</span><span class="p">:</span>
            <span class="c1">#results[&quot;out&quot;].update(sigres.as_dict())</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">SIGRES</span><span class="o">=</span><span class="n">sigres</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div></div>


<span class="k">class</span> <span class="nc">BseTask</span><span class="p">(</span><span class="n">ManyBodyTask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Task for Bethe-Salpeter calculations.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The BSE codes provides both iterative and direct schemes for the computation of the dielectric function.</span>
<span class="sd">        The direct diagonalization cannot be restarted whereas Haydock and CG support restarting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CRITICAL_EVENTS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">events</span><span class="o">.</span><span class="n">HaydockConvergenceWarning</span><span class="p">,</span>
        <span class="c1">#events.BseIterativeDiagoConvergenceWarning,</span>
    <span class="p">]</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="k">def</span> <span class="nf">restart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        BSE calculations with Haydock can be restarted only if we have the</span>
<span class="sd">        excitonic Hamiltonian and the HAYDR_SAVE file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: This version seems to work but the main output file is truncated</span>
        <span class="c1"># TODO: Handle restart if CG method is used</span>
        <span class="c1"># TODO: restart should receive a list of critical events</span>
        <span class="c1"># the log file is complete though.</span>
        <span class="n">irdvars</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Move the BSE blocks to indata.</span>
        <span class="c1"># This is done only once at the end of the first run.</span>
        <span class="c1"># Successive restarts will use the BSR|BSC files in the indir directory</span>
        <span class="c1"># to initialize the excitonic Hamiltonian</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;BSR&quot;</span><span class="p">,</span> <span class="s2">&quot;BSC&quot;</span><span class="p">):</span>
            <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ofile</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">irdvars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
            <span class="c1"># outdir does not contain the BSR|BSC file.</span>
            <span class="c1"># This means that num_restart &gt; 1 and the files should be in task.indir</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;BSR&quot;</span><span class="p">,</span> <span class="s2">&quot;BSC&quot;</span><span class="p">):</span>
                <span class="n">ifile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ifile</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: Cannot find BSR|BSC files in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indir</span><span class="p">))</span>

        <span class="c1"># Rename HAYDR_SAVE files</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;HAYDR_SAVE&quot;</span><span class="p">,</span> <span class="s2">&quot;HAYDC_SAVE&quot;</span><span class="p">):</span>
            <span class="n">ofile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="n">ext</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ofile</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">irdvars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">irdvars_for_ext</span><span class="p">(</span><span class="n">ext</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_to_in</span><span class="p">(</span><span class="n">ofile</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">RestartError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: Cannot find the HAYDR_SAVE file to restart from.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Add the appropriate variable for restarting.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">irdvars</span><span class="p">)</span>

        <span class="c1"># Now we can resubmit the job.</span>
        <span class="c1">#self.history.info(&quot;Will restart from %s&quot;, restart_file)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">()</span>

    <span class="c1">#def inspect(self, **kwargs):</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    Plot the Haydock iterations with matplotlib.</span>
    <span class="c1">#</span>
    <span class="c1">#    Returns</span>
    <span class="c1">#        `matplotlib` figure, None if some error occurred.</span>
    <span class="c1">#    &quot;&quot;&quot;</span>
    <span class="c1">#    haydock_cycle = abiinspect.HaydockIterations.from_file(self.output_file.path)</span>
    <span class="c1">#    if haydock_cycle is not None:</span>
    <span class="c1">#        if &quot;title&quot; not in kwargs: kwargs[&quot;title&quot;] = str(self)</span>
    <span class="c1">#        return haydock_cycle.plot(**kwargs)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mdf_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Absolute path of the MDF file. Empty string if file is not present.&quot;&quot;&quot;</span>
        <span class="c1"># Lazy property to avoid multiple calls to has_abiext.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdf_path</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;MDF.nc&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mdf_path</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span> <span class="n">path</span>

    <span class="k">def</span> <span class="nf">open_mdf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open the MDF file located in the in self.outdir.</span>
<span class="sd">        Returns :class:`MdfFile` object, None if file could not be found or file is not readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mdf_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mdf_path</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">mdf_path</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> didn&#39;t produce a MDF file in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Open the DFF file and add its data to results.out</span>
        <span class="kn">from</span> <span class="nn">abipy.electrons.bse</span> <span class="k">import</span> <span class="n">MdfFile</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">MdfFile</span><span class="p">(</span><span class="n">mdf_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Exception while reading MDF file at </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mdf_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">BseTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_mdf</span><span class="p">()</span> <span class="k">as</span> <span class="n">mdf</span><span class="p">:</span>
            <span class="c1">#results[&quot;out&quot;].update(mdf.as_dict())</span>
            <span class="c1">#epsilon_infinity optical_gap</span>
            <span class="n">results</span><span class="o">.</span><span class="n">register_gridfs_files</span><span class="p">(</span><span class="n">MDF</span><span class="o">=</span><span class="n">mdf</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>


<div class="viewcode-block" id="OpticTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.OpticTask">[docs]</a><span class="k">class</span> <span class="nc">OpticTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Task for the computation of optical spectra with optic i.e.</span>
<span class="sd">    RPA without local-field effects and velocity operator computed from DDK files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">204</span><span class="p">,</span> <span class="mi">102</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optic_input</span><span class="p">,</span> <span class="n">nscf_node</span><span class="p">,</span> <span class="n">ddk_nodes</span><span class="p">,</span> <span class="n">use_ddknc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of :class:`OpticTask` from an string containing the input.</span>

<span class="sd">        Args:</span>
<span class="sd">            optic_input: :class:`OpticInput` object with optic variables.</span>
<span class="sd">            nscf_node: The task that will produce the WFK file with the KS energies or path to the WFK file.</span>
<span class="sd">            ddk_nodes: List of :class:`DdkTask` nodes that will produce the DDK files or list of DDK filepaths.</span>
<span class="sd">                Order (x, y, z)</span>
<span class="sd">            workdir: Path to the working directory.</span>
<span class="sd">            manager: :class:`TaskManager` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert paths to FileNodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nscf_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">nscf_node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ddk_nodes</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ddk_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="c1">#print(self.nscf_node, self.ddk_nodes)</span>

        <span class="c1"># Use DDK extension instead of 1WF</span>
        <span class="k">if</span> <span class="n">use_ddknc</span><span class="p">:</span>
            <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="s2">&quot;DDK.nc&quot;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="s2">&quot;1WF&quot;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span><span class="p">}</span>

        <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">nscf_node</span><span class="p">:</span> <span class="s2">&quot;WFK&quot;</span><span class="p">})</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">OpticTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">optic_input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>

<div class="viewcode-block" id="OpticTask.set_workdir"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.OpticTask.set_workdir">[docs]</a>    <span class="k">def</span> <span class="nf">set_workdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workdir</span><span class="p">,</span> <span class="n">chroot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the working directory of the task.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OpticTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_workdir</span><span class="p">(</span><span class="n">workdir</span><span class="p">,</span> <span class="n">chroot</span><span class="o">=</span><span class="n">chroot</span><span class="p">)</span>
        <span class="c1"># Small hack: the log file of optics is actually the main output file.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_file</span></div>

<div class="viewcode-block" id="OpticTask.set_vars"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.OpticTask.set_vars">[docs]</a>    <span class="k">def</span> <span class="nf">set_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optic does not use `get` or `ird` variables hence we should never try</span>
<span class="sd">        to change the input when we connect this task</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;OpticTask intercepted set_vars with args </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;autoparal&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;autoparal&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;max_ncpus&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">max_ncpus</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;max_ncpus&quot;</span><span class="p">])</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Path to the executable required for running the :class:`OpticTask`.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;optic&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filesfile_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the list of files and prefixes needed to execute ABINIT.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="c1">#optic.in     ! Name of input file</span>
        <span class="c1">#optic.out    ! Unused</span>
        <span class="c1">#optic        ! Root name for all files that will be produced</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>                           <span class="c1"># Path to the input file</span>
        <span class="n">app</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;unused&quot;</span><span class="p">))</span>           <span class="c1"># Path to the output file</span>
        <span class="n">app</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">.</span><span class="n">odata</span><span class="p">))</span>  <span class="c1"># Prefix for output data</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">wfk_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the WFK file produced by the NSCF run.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nscf_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;WFK&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddk_filepaths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the DDK files produced by the DDK runs.&quot;&quot;&quot;</span>
        <span class="c1"># This to support new version of optic that used DDK.nc</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">ddk_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DDK.nc&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ddk_task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">paths</span>

        <span class="c1"># This is deprecated and can be removed when new version of Abinit is released.</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ddk_task</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;1WF&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ddk_task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_nodes</span><span class="p">]</span>

<div class="viewcode-block" id="OpticTask.make_input"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.OpticTask.make_input">[docs]</a>    <span class="k">def</span> <span class="nf">make_input</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct and write the input file of the calculation.&quot;&quot;&quot;</span>
        <span class="c1"># Set the file paths.</span>
        <span class="n">all_files</span> <span class="o">=</span><span class="p">{</span><span class="s2">&quot;ddkfile_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="n">ddk</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">ddk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_filepaths</span><span class="p">)}</span>
        <span class="n">all_files</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;wfkfile&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfk_filepath</span><span class="p">})</span>
        <span class="n">files_nml</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;FILES&quot;</span><span class="p">:</span> <span class="n">all_files</span><span class="p">}</span>
        <span class="n">files</span><span class="o">=</span> <span class="n">nmltostring</span><span class="p">(</span><span class="n">files_nml</span><span class="p">)</span>

        <span class="c1"># Get the input specified by the user</span>
        <span class="n">user_file</span> <span class="o">=</span> <span class="n">nmltostring</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>

        <span class="c1"># Join them.</span>
        <span class="k">return</span> <span class="n">files</span> <span class="o">+</span> <span class="n">user_file</span></div>

<div class="viewcode-block" id="OpticTask.setup"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.OpticTask.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public method called before submitting the task.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="OpticTask.make_links"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.OpticTask.make_links">[docs]</a>    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optic allows the user to specify the paths of the input file.</span>
<span class="sd">        hence we don&#39;t need to create symbolic links.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="OpticTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.OpticTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">OpticTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="OpticTask.fix_abicritical"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.OpticTask.fix_abicritical">[docs]</a>    <span class="k">def</span> <span class="nf">fix_abicritical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cannot fix abicritical errors for optic</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">0</span></div>

    <span class="c1">#@check_spectator</span>
<div class="viewcode-block" id="OpticTask.reset_from_scratch"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.OpticTask.reset_from_scratch">[docs]</a>    <span class="k">def</span> <span class="nf">reset_from_scratch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        restart from scratch, this is to be used if a job is restarted with more resources after a crash</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Move output files produced in workdir to _reset otherwise check_status continues</span>
        <span class="c1"># to see the task as crashed even if the job did not run</span>
        <span class="c1"># Create reset directory if not already done.</span>
        <span class="n">reset_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;_reset&quot;</span><span class="p">)</span>
        <span class="n">reset_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reset_dir</span><span class="p">,</span> <span class="s2">&quot;_counter&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">reset_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">reset_dir</span><span class="p">)</span>
            <span class="n">num_reset</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">reset_file</span><span class="p">,</span> <span class="s2">&quot;rt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">num_reset</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

        <span class="c1"># Move files to reset and append digit with reset index.</span>
        <span class="k">def</span> <span class="nf">move_file</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">exists</span><span class="p">:</span> <span class="k">return</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reset_dir</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">basename</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_reset</span><span class="p">)))</span>
            <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t move file </span><span class="si">{}</span><span class="s2">. exc: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;output_file&quot;</span><span class="p">,</span> <span class="s2">&quot;log_file&quot;</span><span class="p">,</span> <span class="s2">&quot;stderr_file&quot;</span><span class="p">,</span> <span class="s2">&quot;qout_file&quot;</span><span class="p">,</span> <span class="s2">&quot;qerr_file&quot;</span><span class="p">,</span> <span class="s2">&quot;mpiabort_file&quot;</span><span class="p">):</span>
            <span class="n">move_file</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">))</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">reset_file</span><span class="p">,</span> <span class="s2">&quot;wt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_reset</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">start_lockfile</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="c1"># Reset datetimes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datetimes</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">(</span><span class="n">submit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="OpticTask.fix_queue_critical"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.OpticTask.fix_queue_critical">[docs]</a>    <span class="k">def</span> <span class="nf">fix_queue_critical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function tries to fix critical events originating from the queue submission system.</span>

<span class="sd">        General strategy, first try to increase resources in order to fix the problem,</span>
<span class="sd">        if this is not possible, call a task specific method to attempt to decrease the demands.</span>

<span class="sd">        Returns:</span>
<span class="sd">            1 if task has been fixed else 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pymatgen.io.abinit.scheduler_error_parsers</span> <span class="k">import</span> <span class="n">NodeFailureError</span><span class="p">,</span> <span class="n">MemoryCancelError</span><span class="p">,</span> <span class="n">TimeCancelError</span>
        <span class="c1">#assert isinstance(self.manager, TaskManager)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_scales</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_scales</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_resources</span><span class="p">()</span>  <span class="c1"># acts either on the policy or on the qadapter</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                    <span class="k">return</span>
                <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;unknown queue error, could not increase resources any further&#39;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;unknown queue error, no options left&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">error</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_errors</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;fixing: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">NodeFailureError</span><span class="p">):</span>
                    <span class="c1"># if the problematic node is known, exclude it</span>
                    <span class="k">if</span> <span class="n">error</span><span class="o">.</span><span class="n">nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">exclude_nodes</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;excluding nodes&#39;</span><span class="p">)</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;Node error but no node identified.&#39;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">MemoryCancelError</span><span class="p">):</span>
                    <span class="c1"># ask the qadapter to provide more resources, i.e. more cpu&#39;s so more total memory if the code</span>
                    <span class="c1"># scales this should fix the memeory problem</span>
                    <span class="c1"># increase both max and min ncpu of the autoparalel and rerun autoparalel</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem_scales</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_ncpus</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;increased ncps to solve memory problem&#39;</span><span class="p">)</span>
                            <span class="k">return</span>
                        <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;increasing ncpus failed&#39;</span><span class="p">)</span>

                    <span class="c1"># if the max is reached, try to increase the memory per cpu:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_mem</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;increased mem&#39;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;increasing mem failed&#39;</span><span class="p">)</span>

                    <span class="c1"># if this failed ask the task to provide a method to reduce the memory demand</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reduce_memory_demand</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;decreased mem demand&#39;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="n">DecreaseDemandsError</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;decreasing demands failed&#39;</span><span class="p">)</span>

                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Memory error detected but the memory could not be increased neither could the</span><span class="se">\n</span><span class="s1">&#39;</span>
                           <span class="s1">&#39;memory demand be decreased. Unrecoverable error.&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">FixQueueCriticalError</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">TimeCancelError</span><span class="p">):</span>
                    <span class="c1"># ask the qadapter to provide more time</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_time</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;increased wall time&#39;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;increasing the walltime failed&#39;</span><span class="p">)</span>

                    <span class="c1"># if this fails ask the qadapter to increase the number of cpus</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_scales</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">increase_ncpus</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;increased number of cpus&#39;</span><span class="p">)</span>
                            <span class="k">return</span>
                        <span class="k">except</span> <span class="n">ManagerIncreaseError</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;increase ncpus to speed up the calculation to stay in the walltime failed&#39;</span><span class="p">)</span>

                    <span class="c1"># if this failed ask the task to provide a method to speed up the task</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">speed_up</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">reset_from_scratch</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_READY</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;task speedup&#39;</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">except</span> <span class="n">DecreaseDemandsError</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;decreasing demands failed&#39;</span><span class="p">)</span>

                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Time cancel error detected but the time could not be increased neither could</span><span class="se">\n</span><span class="s1">&#39;</span>
                           <span class="s1">&#39;the time demand be decreased by speedup of increasing the number of cpus.</span><span class="se">\n</span><span class="s1">&#39;</span>
                           <span class="s1">&#39;Unrecoverable error.&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;No solution provided for error </span><span class="si">%s</span><span class="s1">. Unrecoverable error.&#39;</span> <span class="o">%</span> <span class="n">error</span><span class="o">.</span><span class="n">name</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_ERROR</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="OpticTask.autoparal_run"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.OpticTask.autoparal_run">[docs]</a>    <span class="k">def</span> <span class="nf">autoparal_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find an optimal set of parameters for the execution of the Optic task</span>
<span class="sd">        This method can change the submission parameters e.g. the number of CPUs for MPI and OpenMp.</span>

<span class="sd">        Returns 0 if success</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">policy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">policy</span>

        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># or policy.max_ncpus in [None, 1]:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Nothing to do in autoparal, returning (None, None)&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;autoparal != 1&quot;</span><span class="p">)</span>

        <span class="c1">############################################################################</span>
        <span class="c1"># Run ABINIT in sequential to get the possible configurations with max_ncpus</span>
        <span class="c1">############################################################################</span>

        <span class="c1"># Set the variables for automatic parallelization</span>
        <span class="c1"># Will get all the possible configurations up to max_ncpus</span>
        <span class="c1"># Return immediately if max_ncpus == 1</span>
        <span class="n">max_ncpus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">max_cores</span>
        <span class="k">if</span> <span class="n">max_ncpus</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>

        <span class="n">autoparal_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">autoparal</span><span class="o">=</span><span class="n">policy</span><span class="o">.</span><span class="n">autoparal</span><span class="p">,</span> <span class="n">max_ncpus</span><span class="o">=</span><span class="n">max_ncpus</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">autoparal_vars</span><span class="p">)</span>

        <span class="c1"># Run the job in a shell subprocess with mpi_procs = 1</span>
        <span class="c1"># we don&#39;t want to make a request to the queue manager for this simple job!</span>
        <span class="c1"># Return code is always != 0</span>
        <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">to_shell_manager</span><span class="p">(</span><span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="c1"># To avoid: ResourceWarning: unclosed file &lt;_io.BufferedReader name=87&gt; in py3k</span>
        <span class="n">process</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1">#process.stdout.close()</span>

        <span class="c1"># Remove the variables added for the automatic parallelization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input</span><span class="o">.</span><span class="n">remove_vars</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">autoparal_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="c1">##############################################################</span>
        <span class="c1"># Parse the autoparal configurations from the main output file</span>
        <span class="c1">##############################################################</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">ParalHintsParser</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pconfs</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">parser</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
            <span class="c1"># In principle Abinit should have written a complete log file</span>
            <span class="c1"># because we called .wait() but sometimes the Yaml doc is incomplete and</span>
            <span class="c1"># the parser raises. Let&#39;s wait 5 secs and then try again.</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pconfs</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">parser</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Error while parsing Autoparal section:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">straceback</span><span class="p">())</span>
                <span class="k">return</span> <span class="mi">2</span>

        <span class="c1">######################################################</span>
        <span class="c1"># Select the optimal configuration according to policy</span>
        <span class="c1">######################################################</span>
        <span class="c1">#optconf = self.find_optconf(pconfs)</span>
        <span class="c1"># Select the partition on which we&#39;ll be running and set MPI/OMP cores.</span>
        <span class="n">optconf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">select_qadapter</span><span class="p">(</span><span class="n">pconfs</span><span class="p">)</span>

        <span class="c1">####################################################</span>
        <span class="c1"># Change the input file and/or the submission script</span>
        <span class="c1">####################################################</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_vars</span><span class="p">(</span><span class="n">optconf</span><span class="o">.</span><span class="n">vars</span><span class="p">)</span>

        <span class="c1"># Write autoparal configurations to JSON file.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">pconfs</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;optimal_conf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optconf</span>
        <span class="n">json_pretty_dump</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;autoparal.json&quot;</span><span class="p">))</span>

        <span class="c1">##############</span>
        <span class="c1"># Finalization</span>
        <span class="c1">##############</span>
        <span class="c1"># Reset the status, remove garbage files ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S_INIT</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;finished auto paralell&#39;</span><span class="p">)</span>

        <span class="c1"># Remove the output file since Abinit likes to create new files</span>
        <span class="c1"># with extension .outA, .outB if the file already exists.</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="c1">#os.remove(self.log_file.path)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stderr_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">0</span></div></div>


<div class="viewcode-block" id="AnaddbTask"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AnaddbTask">[docs]</a><span class="k">class</span> <span class="nc">AnaddbTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Task for Anaddb runs (post-processing of DFPT calculations).&quot;&quot;&quot;</span>

    <span class="n">color_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">204</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="o">/</span> <span class="mi">255</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anaddb_input</span><span class="p">,</span> <span class="n">ddb_node</span><span class="p">,</span>
                 <span class="n">gkk_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">md_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddk_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an instance of :class:`AnaddbTask` from a string containing the input.</span>

<span class="sd">        Args:</span>
<span class="sd">            anaddb_input: string with the anaddb variables.</span>
<span class="sd">            ddb_node: The node that will produce the DDB file. Accept :class:`Task`, :class:`Work` or filepath.</span>
<span class="sd">            gkk_node: The node that will produce the GKK file (optional). Accept :class:`Task`, :class:`Work` or filepath.</span>
<span class="sd">            md_node: The node that will produce the MD file (optional). Accept `Task`, `Work` or filepath.</span>
<span class="sd">            gkk_node: The node that will produce the GKK file (optional). Accept `Task`, `Work` or filepath.</span>
<span class="sd">            workdir: Path to the working directory (optional).</span>
<span class="sd">            manager: :class:`TaskManager` object (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Keep a reference to the nodes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">ddb_node</span><span class="p">)</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span><span class="p">:</span> <span class="s2">&quot;DDB&quot;</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">gkk_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span><span class="p">:</span> <span class="s2">&quot;GKK&quot;</span><span class="p">})</span>

        <span class="c1"># I never used it!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">md_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">md_node</span><span class="p">:</span> <span class="s2">&quot;MD&quot;</span><span class="p">})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span> <span class="o">=</span> <span class="n">Node</span><span class="o">.</span><span class="n">as_node</span><span class="p">(</span><span class="n">ddk_node</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">deps</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span><span class="p">:</span> <span class="s2">&quot;DDK&quot;</span><span class="p">})</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">AnaddbTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">anaddb_input</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span> <span class="n">deps</span><span class="o">=</span><span class="n">deps</span><span class="p">)</span>

<div class="viewcode-block" id="AnaddbTask.temp_shell_task"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AnaddbTask.temp_shell_task">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">temp_shell_task</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">ddb_node</span><span class="p">,</span> <span class="n">mpi_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">gkk_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">md_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddk_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">workdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a :class:`AnaddbTask` with a temporary workdir. The task is executed via</span>
<span class="sd">        the shell with 1 MPI proc. Mainly used for post-processing the DDB files.</span>

<span class="sd">        Args:</span>
<span class="sd">            mpi_procs: Number of MPI processes to use.</span>
<span class="sd">            anaddb_input: string with the anaddb variables.</span>
<span class="sd">            ddb_node: The node that will produce the DDB file. Accept :class:`Task`, :class:`Work` or filepath.</span>

<span class="sd">        See `AnaddbInit` for the meaning of the other arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Build a simple manager to run the job in a shell subprocess</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="n">workdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span> <span class="k">if</span> <span class="n">workdir</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">workdir</span>
        <span class="k">if</span> <span class="n">manager</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">TaskManager</span><span class="o">.</span><span class="n">from_user_config</span><span class="p">()</span>

        <span class="c1"># Construct the task and run it</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ddb_node</span><span class="p">,</span>
                   <span class="n">gkk_node</span><span class="o">=</span><span class="n">gkk_node</span><span class="p">,</span> <span class="n">md_node</span><span class="o">=</span><span class="n">md_node</span><span class="p">,</span> <span class="n">ddk_node</span><span class="o">=</span><span class="n">ddk_node</span><span class="p">,</span>
                   <span class="n">workdir</span><span class="o">=</span><span class="n">workdir</span><span class="p">,</span> <span class="n">manager</span><span class="o">=</span><span class="n">manager</span><span class="o">.</span><span class="n">to_shell_manager</span><span class="p">(</span><span class="n">mpi_procs</span><span class="o">=</span><span class="n">mpi_procs</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">executable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Path to the executable required for running the :class:`AnaddbTask`.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executable</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;anaddb&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filesfile_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;String with the list of files and prefixes needed to execute ABINIT.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">append</span>

        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>          <span class="c1"># 1) Path of the input file</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_file</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>         <span class="c1"># 2) Path of the output file</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddb_filepath</span><span class="p">)</span>             <span class="c1"># 3) Input derivative database e.g. t13.ddb.in</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">md_filepath</span><span class="p">)</span>              <span class="c1"># 4) Output molecular dynamics e.g. t13.md</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gkk_filepath</span><span class="p">)</span>             <span class="c1"># 5) Input elphon matrix elements  (GKK file)</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">path_join</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">))</span>  <span class="c1"># 6) Base name for elphon output files e.g. t13</span>
        <span class="n">app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_filepath</span><span class="p">)</span>             <span class="c1"># 7) File containing ddk filenames for elphon/transport.</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddb_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input DDB file.&quot;&quot;&quot;</span>
        <span class="c1"># This is not very elegant! A possible approach could to be path self.ddb_node.outdir!</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span><span class="p">,</span> <span class="n">FileNode</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span><span class="o">.</span><span class="n">filepath</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddb_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DDB&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s2">&quot;DDB_FILE_DOES_NOT_EXIST&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">md_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input MD file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="s2">&quot;MD_FILE_DOES_NOT_EXIST&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">md_node</span><span class="p">,</span> <span class="n">FileNode</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span><span class="o">.</span><span class="n">filepath</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;MD&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s2">&quot;MD_FILE_DOES_NOT_EXIST&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gkk_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input GKK file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="s2">&quot;GKK_FILE_DOES_NOT_EXIST&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span><span class="p">,</span> <span class="n">FileNode</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span><span class="o">.</span><span class="n">filepath</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gkk_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;GKK&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s2">&quot;GKK_FILE_DOES_NOT_EXIST&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ddk_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns (at runtime) the absolute path of the input DKK file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="s2">&quot;DDK_FILE_DOES_NOT_EXIST&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span><span class="p">,</span> <span class="n">FileNode</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span><span class="o">.</span><span class="n">filepath</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ddk_node</span><span class="o">.</span><span class="n">outdir</span><span class="o">.</span><span class="n">has_abiext</span><span class="p">(</span><span class="s2">&quot;DDK&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span> <span class="k">if</span> <span class="n">path</span> <span class="k">else</span> <span class="s2">&quot;DDK_FILE_DOES_NOT_EXIST&quot;</span>

<div class="viewcode-block" id="AnaddbTask.setup"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AnaddbTask.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Public method called before submitting the task.&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="AnaddbTask.make_links"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AnaddbTask.make_links">[docs]</a>    <span class="k">def</span> <span class="nf">make_links</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Anaddb allows the user to specify the paths of the input file.</span>
<span class="sd">        hence we don&#39;t need to create symbolic links.</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="AnaddbTask.open_phbst"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AnaddbTask.open_phbst">[docs]</a>    <span class="k">def</span> <span class="nf">open_phbst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open PHBST file produced by Anaddb and returns :class:`PhbstFile` object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.dfpt.phonons</span> <span class="k">import</span> <span class="n">PhbstFile</span>
        <span class="n">phbst_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;run.abo_PHBST.nc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">phbst_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> reached S_OK but didn&#39;t produce a PHBST file in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PhbstFile</span><span class="p">(</span><span class="n">phbst_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Exception while reading GSR file at </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">phbst_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="AnaddbTask.open_phdos"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AnaddbTask.open_phdos">[docs]</a>    <span class="k">def</span> <span class="nf">open_phdos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open PHDOS file produced by Anaddb and returns :class:`PhdosFile` object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">abipy.dfpt.phonons</span> <span class="k">import</span> <span class="n">PhdosFile</span>
        <span class="n">phdos_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">workdir</span><span class="p">,</span> <span class="s2">&quot;run.abo_PHDOS.nc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">phdos_path</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">S_OK</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> reached S_OK but didn&#39;t produce a PHBST file in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outdir</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PhdosFile</span><span class="p">(</span><span class="n">phdos_path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;Exception while reading GSR file at </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">phdos_path</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">exc</span><span class="p">)))</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="AnaddbTask.get_results"><a class="viewcode-back" href="../../../../pymatgen.io.abinit.tasks.html#pymatgen.io.abinit.tasks.AnaddbTask.get_results">[docs]</a>    <span class="k">def</span> <span class="nf">get_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">AnaddbTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 2018.9.12 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../pymatgen.html" >pymatgen</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2011, Pymatgen Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.0.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>