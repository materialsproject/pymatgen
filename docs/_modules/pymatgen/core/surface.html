<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pymatgen.core.surface &#8212; pymatgen 2017.8.4 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/proBlue.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2017.8.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pymatgen 2017.8.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../pymatgen.html" accesskey="U">pymatgen</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.core.surface</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="c1"># Copyright (c) Pymatgen Development Team.</span>
<span class="c1"># Distributed under the terms of the MIT License.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># New Py&gt;=3.5 import</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">gcd</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># Deprecated import from Py3.5 onwards.</span>
    <span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">gcd</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">squareform</span>
<span class="kn">from</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="k">import</span> <span class="n">linkage</span><span class="p">,</span> <span class="n">fcluster</span>

<span class="kn">from</span> <span class="nn">monty.fractions</span> <span class="k">import</span> <span class="n">lcm</span>

<span class="kn">from</span> <span class="nn">pymatgen.core.periodic_table</span> <span class="k">import</span> <span class="n">get_el_sp</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="k">import</span> <span class="n">Structure</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.lattice</span> <span class="k">import</span> <span class="n">Lattice</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.sites</span> <span class="k">import</span> <span class="n">PeriodicSite</span>

<span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="k">import</span> <span class="n">SpacegroupAnalyzer</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.coord_utils</span> <span class="k">import</span> <span class="n">in_coord_list</span>
<span class="kn">from</span> <span class="nn">pymatgen.analysis.structure_matcher</span> <span class="k">import</span> <span class="n">StructureMatcher</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module implements representations of slabs and surfaces, as well as</span>
<span class="sd">algorithms for generating them. If you use this module, please consider</span>
<span class="sd">citing the following work::</span>

<span class="sd">    R. Tran, Z. Xu, B. Radhakrishnan, D. Winston, W. Sun, K. A. Persson,</span>
<span class="sd">    S. P. Ong, &quot;Surface Energies of Elemental Crystals&quot;, Scientific Data,</span>
<span class="sd">    2016, 3:160080, doi: 10.1038/sdata.2016.80.</span>

<span class="sd">as well as::</span>

<span class="sd">    Sun, W.; Ceder, G. Efficient creation and convergence of surface slabs,</span>
<span class="sd">    Surface Science, 2013, 617, 53â€“59, doi:10.1016/j.susc.2013.05.016.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Richard Tran, Wenhao Sun, Zihan Xu, Shyue Ping Ong&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2014, The Materials Virtual Lab&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.1&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Shyue Ping Ong&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;ongsp@ucsd.edu&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;6/10/14&quot;</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="Slab"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.Slab">[docs]</a><span class="k">class</span> <span class="nc">Slab</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subclass of Structure representing a Slab. Implements additional</span>
<span class="sd">    attributes pertaining to slabs, but the init method does not</span>
<span class="sd">    actually implement any algorithm that creates a slab. This is a</span>
<span class="sd">    DUMMY class who&#39;s init method only holds information about the</span>
<span class="sd">    slab. Also has additional methods that returns other information</span>
<span class="sd">    about a slab such as the surface area, normal, and atom adsorption.</span>

<span class="sd">    Note that all Slabs have the surface normal oriented in the c-direction.</span>
<span class="sd">    This means the lattice vectors a and b are in the surface plane and the c</span>
<span class="sd">    vector is out of the surface plane (though not necessary perpendicular to</span>
<span class="sd">    the surface.)</span>

<span class="sd">    .. attribute:: miller_index</span>

<span class="sd">        Miller index of plane parallel to surface.</span>

<span class="sd">    .. attribute:: scale_factor</span>

<span class="sd">        Final computed scale factor that brings the parent cell to the</span>
<span class="sd">        surface cell.</span>

<span class="sd">    .. attribute:: shift</span>

<span class="sd">        The shift value in Angstrom that indicates how much this</span>
<span class="sd">        slab has been shifted.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span>
                 <span class="n">oriented_unit_cell</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">,</span>
                 <span class="n">validate_proximity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">site_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a Slab structure, a structure object with additional information</span>
<span class="sd">        and methods pertaining to slabs.</span>

<span class="sd">        Args:</span>
<span class="sd">            lattice (Lattice/3x3 array): The lattice, either as a</span>
<span class="sd">                :class:`pymatgen.core.lattice.Lattice` or</span>
<span class="sd">                simply as any 2D array. Each row should correspond to a lattice</span>
<span class="sd">                vector. E.g., [[10,0,0], [20,10,0], [0,0,30]] specifies a</span>
<span class="sd">                lattice with lattice vectors [10,0,0], [20,10,0] and [0,0,30].</span>
<span class="sd">            species ([Specie]): Sequence of species on each site. Can take in</span>
<span class="sd">                flexible input, including:</span>

<span class="sd">                i.  A sequence of element / specie specified either as string</span>
<span class="sd">                    symbols, e.g. [&quot;Li&quot;, &quot;Fe2+&quot;, &quot;P&quot;, ...] or atomic numbers,</span>
<span class="sd">                    e.g., (3, 56, ...) or actual Element or Specie objects.</span>

<span class="sd">                ii. List of dict of elements/species and occupancies, e.g.,</span>
<span class="sd">                    [{&quot;Fe&quot; : 0.5, &quot;Mn&quot;:0.5}, ...]. This allows the setup of</span>
<span class="sd">                    disordered structures.</span>
<span class="sd">            coords (Nx3 array): list of fractional/cartesian coordinates of</span>
<span class="sd">                each species.</span>
<span class="sd">            miller_index ([h, k, l]): Miller index of plane parallel to</span>
<span class="sd">                surface. Note that this is referenced to the input structure. If</span>
<span class="sd">                you need this to be based on the conventional cell,</span>
<span class="sd">                you should supply the conventional structure.</span>
<span class="sd">            oriented_unit_cell (Structure): The oriented_unit_cell from which</span>
<span class="sd">                this Slab is created (by scaling in the c-direction).</span>
<span class="sd">            shift (float): The shift in the c-direction applied to get the</span>
<span class="sd">                termination.</span>
<span class="sd">            scale_factor (array): scale_factor Final computed scale factor</span>
<span class="sd">                that brings the parent cell to the surface cell.</span>
<span class="sd">            validate_proximity (bool): Whether to check if there are sites</span>
<span class="sd">                that are less than 0.01 Ang apart. Defaults to False.</span>
<span class="sd">            coords_are_cartesian (bool): Set to True if you are providing</span>
<span class="sd">                coordinates in cartesian coordinates. Defaults to False.</span>
<span class="sd">            site_properties (dict): Properties associated with the sites as a</span>
<span class="sd">                dict of sequences, e.g., {&quot;magmom&quot;:[5,5,5,5]}. The sequences</span>
<span class="sd">                have to be the same length as the atomic species and</span>
<span class="sd">                fractional_coords. Defaults to None for no properties.</span>
<span class="sd">            energy (float): A value for the energy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span> <span class="o">=</span> <span class="n">oriented_unit_cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">miller_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span> <span class="o">=</span> <span class="n">scale_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">energy</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Slab</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">lattice</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">validate_proximity</span><span class="o">=</span><span class="n">validate_proximity</span><span class="p">,</span>
            <span class="n">to_unit_cell</span><span class="o">=</span><span class="n">to_unit_cell</span><span class="p">,</span>
            <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="n">coords_are_cartesian</span><span class="p">,</span>
            <span class="n">site_properties</span><span class="o">=</span><span class="n">site_properties</span><span class="p">)</span>

<div class="viewcode-block" id="Slab.get_orthogonal_c_slab"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.Slab.get_orthogonal_c_slab">[docs]</a>    <span class="k">def</span> <span class="nf">get_orthogonal_c_slab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns a Slab where the normal (c lattice vector) is</span>
<span class="sd">        &quot;forced&quot; to be exactly orthogonal to the surface a and b lattice</span>
<span class="sd">        vectors. **Note that this breaks inherent symmetries in the slab.**</span>
<span class="sd">        It should be pointed out that orthogonality is not required to get good</span>
<span class="sd">        surface energies, but it can be useful in cases where the slabs are</span>
<span class="sd">        subsequently used for postprocessing of some kind, e.g. generating</span>
<span class="sd">        GBs or interfaces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="n">new_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">new_c</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">new_c</span><span class="p">)</span>
        <span class="n">new_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">new_c</span><span class="p">)</span> <span class="o">*</span> <span class="n">new_c</span>
        <span class="n">new_latt</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">new_c</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Slab</span><span class="p">(</span><span class="n">lattice</span><span class="o">=</span><span class="n">new_latt</span><span class="p">,</span> <span class="n">species</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">,</span>
                    <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">,</span> <span class="n">miller_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span>
                    <span class="n">oriented_unit_cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">,</span>
                    <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="n">scale_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">,</span>
                    <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span></div>

<div class="viewcode-block" id="Slab.get_tasker2_slabs"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.Slab.get_tasker2_slabs">[docs]</a>    <span class="k">def</span> <span class="nf">get_tasker2_slabs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">same_species_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of slabs that have been Tasker 2 corrected.</span>

<span class="sd">        Args:</span>
<span class="sd">            tol (float): Tolerance to determine if atoms are within same plane.</span>
<span class="sd">                This is a fractional tolerance, not an absolute one.</span>
<span class="sd">            same_species_only (bool): If True, only that are of the exact same</span>
<span class="sd">                species as the atom at the outermost surface are considered for</span>
<span class="sd">                moving. Otherwise, all atoms regardless of species that is</span>
<span class="sd">                within tol are considered for moving. Default is True (usually</span>
<span class="sd">                the desired behavior).</span>

<span class="sd">        Returns:</span>
<span class="sd">            ([Slab]) List of tasker 2 corrected slabs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>
        <span class="n">slabs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">sortedcsites</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">site</span><span class="p">:</span> <span class="n">site</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>

        <span class="c1"># Determine what fraction the slab is of the total cell size in the</span>
        <span class="c1"># c direction. Round to nearest rational number.</span>
        <span class="n">nlayers_total</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">c</span><span class="p">))</span>
        <span class="n">nlayers_slab</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">sortedcsites</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span> <span class="n">sortedcsites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
                                 <span class="o">*</span> <span class="n">nlayers_total</span><span class="p">))</span>
        <span class="n">slab_ratio</span> <span class="o">=</span> <span class="n">nlayers_slab</span> <span class="o">/</span> <span class="n">nlayers_total</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">symm_structure</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">get_symmetrized_structure</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">equi_index</span><span class="p">(</span><span class="n">site</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">equi_sites</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">equi_sites</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">i</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot determine equi index!&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">surface_site</span><span class="p">,</span> <span class="n">shift</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">sortedcsites</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">slab_ratio</span><span class="p">),</span>
                                    <span class="p">(</span><span class="n">sortedcsites</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">slab_ratio</span><span class="p">)]:</span>
            <span class="n">tomove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">fixed</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span> <span class="n">surface_site</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="p">(</span>
                        <span class="p">(</span><span class="ow">not</span> <span class="n">same_species_only</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span> <span class="o">==</span> <span class="n">surface_site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">):</span>
                    <span class="n">tomove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fixed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>

            <span class="c1"># Sort and group the sites by the species and symmetry equivalence</span>
            <span class="n">tomove</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tomove</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">equi_index</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

            <span class="n">grouped</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">sites</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
                <span class="n">tomove</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">equi_index</span><span class="p">(</span><span class="n">s</span><span class="p">))]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tomove</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">]):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Odd number of sites to divide! Try changing &quot;</span>
                              <span class="s2">&quot;the tolerance to ensure even division of &quot;</span>
                              <span class="s2">&quot;sites or create supercells in a or b directions &quot;</span>
                              <span class="s2">&quot;to allow for atoms to be moved!&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">combinations</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">:</span>
                <span class="n">combinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))])</span>

            <span class="k">for</span> <span class="n">selection</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">combinations</span><span class="p">):</span>
                <span class="n">species</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">fixed</span><span class="p">]</span>
                <span class="n">fcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">fixed</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tomove</span><span class="p">:</span>
                    <span class="n">species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                            <span class="n">fcoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Move unselected atom to the opposite surface.</span>
                        <span class="n">fcoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shift</span><span class="p">])</span>

                <span class="c1"># sort by species to put all similar species together.</span>
                <span class="n">sp_fcoord</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">fcoords</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">species</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sp_fcoord</span><span class="p">]</span>
                <span class="n">fcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sp_fcoord</span><span class="p">]</span>
                <span class="n">slab</span> <span class="o">=</span> <span class="n">Slab</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">fcoords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>
                <span class="n">slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">StructureMatcher</span><span class="p">()</span>
        <span class="n">unique</span> <span class="o">=</span> <span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">group_structures</span><span class="p">(</span><span class="n">slabs</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">unique</span></div>

<div class="viewcode-block" id="Slab.is_symmetric"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.Slab.is_symmetric">[docs]</a>    <span class="k">def</span> <span class="nf">is_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if slab is symmetric, i.e., contains inversion symmetry.</span>

<span class="sd">        Args:</span>
<span class="sd">            symprec (float): Symmetry precision used for SpaceGroup analyzer.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (bool) Whether slab contains inversion symmetry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">laue</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;-1&quot;</span><span class="p">,</span> <span class="s2">&quot;2/m&quot;</span><span class="p">,</span> <span class="s2">&quot;mmm&quot;</span><span class="p">,</span> <span class="s2">&quot;4/m&quot;</span><span class="p">,</span> <span class="s2">&quot;4/mmm&quot;</span><span class="p">,</span>
                <span class="s2">&quot;-3&quot;</span><span class="p">,</span> <span class="s2">&quot;-3m&quot;</span><span class="p">,</span> <span class="s2">&quot;6/m&quot;</span><span class="p">,</span> <span class="s2">&quot;6/mmm&quot;</span><span class="p">,</span> <span class="s2">&quot;m-3&quot;</span><span class="p">,</span> <span class="s2">&quot;m-3m&quot;</span><span class="p">]</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">)</span>
        <span class="n">pg</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">get_point_group_symbol</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">pg</span><span class="p">)</span> <span class="ow">in</span> <span class="n">laue</span></div>

<div class="viewcode-block" id="Slab.get_sorted_structure"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.Slab.get_sorted_structure">[docs]</a>    <span class="k">def</span> <span class="nf">get_sorted_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a sorted copy of the structure. The parameters have the same</span>
<span class="sd">        meaning as in list.sort. By default, sites are sorted by the</span>
<span class="sd">        electronegativity of the species. Note that Slab has to override this</span>
<span class="sd">        because of the different __init__ args.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: Specifies a function of one argument that is used to extract</span>
<span class="sd">                a comparison key from each list element: key=str.lower. The</span>
<span class="sd">                default value is None (compare the elements directly).</span>
<span class="sd">            reverse (bool): If set to True, then the list elements are sorted</span>
<span class="sd">                as if each comparison were reversed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Slab</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">,</span> <span class="n">site_properties</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">site_properties</span><span class="p">)</span></div>

<div class="viewcode-block" id="Slab.copy"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.Slab.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method to get a copy of the structure, with options to add</span>
<span class="sd">        site properties.</span>

<span class="sd">        Args:</span>
<span class="sd">            site_properties (dict): Properties to add or override. The</span>
<span class="sd">                properties are specified in the same way as the constructor,</span>
<span class="sd">                i.e., as a dict of the form {property: [values]}. The</span>
<span class="sd">                properties should be in the order of the *original* structure</span>
<span class="sd">                if you are performing sanitization.</span>
<span class="sd">            sanitize (bool): If True, this method will return a sanitized</span>
<span class="sd">                structure. Sanitization performs a few things: (i) The sites are</span>
<span class="sd">                sorted by electronegativity, (ii) a LLL lattice reduction is</span>
<span class="sd">                carried out to obtain a relatively orthogonalized cell,</span>
<span class="sd">                (iii) all fractional coords for sites are mapped into the</span>
<span class="sd">                unit cell.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the Structure, with optionally new site_properties and</span>
<span class="sd">            optionally sanitized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span>
        <span class="k">if</span> <span class="n">site_properties</span><span class="p">:</span>
            <span class="n">props</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">site_properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Slab</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">,</span> <span class="n">site_properties</span><span class="o">=</span><span class="n">props</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dipole</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the dipole of the Slab in the direction of the surface</span>
<span class="sd">        normal. Note that the Slab must be oxidation state-decorated for this</span>
<span class="sd">        to work properly. Otherwise, the Slab will always have a dipole of 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dipole</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">mid_pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">charge</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="s2">&quot;oxi_state&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">amt</span>
                          <span class="k">for</span> <span class="n">sp</span><span class="p">,</span> <span class="n">amt</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
            <span class="n">dipole</span> <span class="o">+=</span> <span class="n">charge</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">coords</span> <span class="o">-</span> <span class="n">mid_pt</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="n">normal</span>
        <span class="k">return</span> <span class="n">dipole</span>

<div class="viewcode-block" id="Slab.is_polar"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.Slab.is_polar">[docs]</a>    <span class="k">def</span> <span class="nf">is_polar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol_dipole_per_unit_area</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the surface is polar by computing the dipole per unit</span>
<span class="sd">        area. Note that the Slab must be oxidation state-decorated for this</span>
<span class="sd">        to work properly. Otherwise, the Slab will always be non-polar.</span>

<span class="sd">        Args:</span>
<span class="sd">            tol_dipole_per_unit_area (float): A tolerance. If the dipole</span>
<span class="sd">                magnitude per unit area is less than this value, the Slab is</span>
<span class="sd">                considered non-polar. Defaults to 1e-3, which is usually</span>
<span class="sd">                pretty good. Normalized dipole per unit area is used as it is</span>
<span class="sd">                more reliable than using the total, which tends to be larger for</span>
<span class="sd">                slabs with larger surface areas.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dip_per_unit_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dipole</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_area</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dip_per_unit_area</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_dipole_per_unit_area</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the surface normal vector of the slab</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">normal</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">normal</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">surface_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the surface area of the slab</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<div class="viewcode-block" id="Slab.add_adsorbate_atom"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.Slab.add_adsorbate_atom">[docs]</a>    <span class="k">def</span> <span class="nf">add_adsorbate_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">specie</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the structure of single atom adsorption.</span>
<span class="sd">        slab structure from the Slab class(in [0, 0, 1])</span>

<span class="sd">        Args:</span>
<span class="sd">            indices ([int]): Indices of sites on which to put the absorbate.</span>
<span class="sd">                Absorbed atom will be displaced relative to the center of</span>
<span class="sd">                these sites.</span>
<span class="sd">            specie (Specie/Element/str): adsorbed atom species</span>
<span class="sd">            distance (float): between centers of the adsorbed atom and the</span>
<span class="sd">                given site in Angstroms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Let&#39;s do the work in cartesian coords</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">*</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">specie</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">composition</span>
        <span class="n">outs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;Slab Summary (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">comp</span><span class="o">.</span><span class="n">formula</span><span class="p">,</span>
            <span class="s2">&quot;Reduced Formula: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">comp</span><span class="o">.</span><span class="n">reduced_formula</span><span class="p">,</span>
            <span class="s2">&quot;Miller index: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span> <span class="p">),</span>
            <span class="s2">&quot;Shift: </span><span class="si">%.4f</span><span class="s2">, Scale Factor: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="o">.</span><span class="fm">__str__</span><span class="p">())]</span>
        <span class="n">to_s</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">%0.6f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">x</span>
        <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;abc   : &quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">to_s</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">abc</span><span class="p">]))</span>
        <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;angles: &quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">to_s</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">angles</span><span class="p">]))</span>
        <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Sites (</span><span class="si">{i}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">site</span><span class="o">.</span><span class="n">species_string</span><span class="p">,</span>
                                  <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">to_s</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
                                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">])]))</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>

<div class="viewcode-block" id="Slab.as_dict"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.Slab.as_dict">[docs]</a>    <span class="k">def</span> <span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Slab</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;@module&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;@class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;oriented_unit_cell&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;miller_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;shift&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span>
        <span class="k">return</span> <span class="n">d</span></div>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Slab.from_dict"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.Slab.from_dict">[docs]</a>    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;lattice&quot;</span><span class="p">])</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="n">PeriodicSite</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span> <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;sites&quot;</span><span class="p">]]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Slab</span><span class="p">(</span>
            <span class="n">lattice</span><span class="o">=</span><span class="n">lattice</span><span class="p">,</span>
            <span class="n">species</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
            <span class="n">miller_index</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;miller_index&quot;</span><span class="p">],</span>
            <span class="n">oriented_unit_cell</span><span class="o">=</span><span class="n">Structure</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;oriented_unit_cell&quot;</span><span class="p">]),</span>
            <span class="n">shift</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;shift&quot;</span><span class="p">],</span> <span class="n">scale_factor</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">],</span>
            <span class="n">site_properties</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">site_properties</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="SlabGenerator"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.SlabGenerator">[docs]</a><span class="k">class</span> <span class="nc">SlabGenerator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class generates different slabs using shift values determined by where</span>
<span class="sd">    a unique termination can be found along with other criterias such as where a</span>
<span class="sd">    termination doesn&#39;t break a polyhedral bond. The shift value then indicates</span>
<span class="sd">    where the slab layer will begin and terminate in the slab-vacuum system.</span>

<span class="sd">    .. attribute:: oriented_unit_cell</span>

<span class="sd">        A unit cell of the parent structure with the miller</span>
<span class="sd">        index of plane parallel to surface</span>

<span class="sd">    .. attribute:: parent</span>

<span class="sd">        Parent structure from which Slab was derived.</span>

<span class="sd">    .. attribute:: lll_reduce</span>

<span class="sd">        Whether or not the slabs will be orthogonalized</span>

<span class="sd">    .. attribute:: center_slab</span>

<span class="sd">        Whether or not the slabs will be centered between</span>
<span class="sd">        the vacuum layer</span>

<span class="sd">    .. attribute:: slab_scale_factor</span>

<span class="sd">        Final computed scale factor that brings the parent cell to the</span>
<span class="sd">        surface cell.</span>

<span class="sd">    .. attribute:: miller_index</span>

<span class="sd">        Miller index of plane parallel to surface.</span>

<span class="sd">    .. attribute:: min_slab_size</span>

<span class="sd">        Minimum size in angstroms of layers containing atoms</span>

<span class="sd">    .. attribute:: min_vac_size</span>

<span class="sd">        Minimize size in angstroms of layers containing vacuum</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_structure</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">,</span> <span class="n">min_slab_size</span><span class="p">,</span>
                 <span class="n">min_vacuum_size</span><span class="p">,</span> <span class="n">lll_reduce</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">center_slab</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">primitive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_normal_search</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the slab scale factor and uses it to generate a unit cell</span>
<span class="sd">        of the initial structure that has been oriented by its miller index.</span>
<span class="sd">        Also stores the initial information needed later on to generate a slab.</span>

<span class="sd">        Args:</span>
<span class="sd">            initial_structure (Structure): Initial input structure. Note that to</span>
<span class="sd">                ensure that the miller indices correspond to usual</span>
<span class="sd">                crystallographic definitions, you should supply a conventional</span>
<span class="sd">                unit cell structure.</span>
<span class="sd">            miller_index ([h, k, l]): Miller index of plane parallel to</span>
<span class="sd">                surface. Note that this is referenced to the input structure. If</span>
<span class="sd">                you need this to be based on the conventional cell,</span>
<span class="sd">                you should supply the conventional structure.</span>
<span class="sd">            min_slab_size (float): In Angstroms</span>
<span class="sd">            min_vacuum_size (float): In Angstroms</span>
<span class="sd">            lll_reduce (bool): Whether to perform an LLL reduction on the</span>
<span class="sd">                eventual structure.</span>
<span class="sd">            center_slab (bool): Whether to center the slab in the cell with</span>
<span class="sd">                equal vacuum spacing from the top and bottom.</span>
<span class="sd">            primitive (bool): Whether to reduce any generated slabs to a</span>
<span class="sd">                primitive cell (this does **not** mean the slab is generated</span>
<span class="sd">                from a primitive cell, it simply means that after slab</span>
<span class="sd">                generation, we attempt to find shorter lattice vectors,</span>
<span class="sd">                which lead to less surface area and smaller cells).</span>
<span class="sd">            max_normal_search (int): If set to a positive integer, the code will</span>
<span class="sd">                conduct a search for a normal lattice vector that is as</span>
<span class="sd">                perpendicular to the surface as possible by considering</span>
<span class="sd">                multiples linear combinations of lattice vectors up to</span>
<span class="sd">                max_normal_search. This has no bearing on surface energies,</span>
<span class="sd">                but may be useful as a preliminary step to generating slabs</span>
<span class="sd">                for absorption and other sizes. It is typical that this will</span>
<span class="sd">                not be the smallest possible cell for simulation. Normality</span>
<span class="sd">                is not guaranteed, but the oriented cell will have the c</span>
<span class="sd">                vector as normal as possible (within the search range) to the</span>
<span class="sd">                surface. A value of up to the max absolute Miller index is</span>
<span class="sd">                usually sufficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">latt</span> <span class="o">=</span> <span class="n">initial_structure</span><span class="o">.</span><span class="n">lattice</span>
        <span class="n">miller_index</span> <span class="o">=</span> <span class="n">reduce_vector</span><span class="p">(</span><span class="n">miller_index</span><span class="p">)</span>
        <span class="c1"># Calculate the surface normal using the reciprocal lattice vector.</span>
        <span class="n">recp</span> <span class="o">=</span> <span class="n">latt</span><span class="o">.</span><span class="n">reciprocal_lattice_crystallographic</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">recp</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">miller_index</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>

        <span class="n">slab_scale_factor</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">non_orth_ind</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">miller_index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Lattice vector is perpendicular to surface normal, i.e.,</span>
                <span class="c1"># in plane of surface. We will simply choose this lattice</span>
                <span class="c1"># vector as one of the basis vectors.</span>
                <span class="n">slab_scale_factor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eye</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Calculate projection of lattice vector onto surface normal.</span>
                <span class="n">d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">latt</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">/</span> <span class="n">latt</span><span class="o">.</span><span class="n">abc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">non_orth_ind</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>

        <span class="c1"># We want the vector that has maximum magnitude in the</span>
        <span class="c1"># direction of the surface normal as the c-direction.</span>
        <span class="c1"># Results in a more &quot;orthogonal&quot; unit cell.</span>
        <span class="n">c_index</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">non_orth_ind</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_orth_ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lcm_miller</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">miller_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">non_orth_ind</span><span class="p">])</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">di</span><span class="p">),</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">dj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">non_orth_ind</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">lcm_miller</span> <span class="o">/</span> <span class="n">miller_index</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">lcm_miller</span> <span class="o">/</span> <span class="n">miller_index</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="n">slab_scale_factor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slab_scale_factor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">max_normal_search</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slab_scale_factor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eye</span><span class="p">[</span><span class="n">c_index</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_range</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_normal_search</span><span class="p">,</span> <span class="n">max_normal_search</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">uvw</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">index_range</span><span class="p">,</span> <span class="n">index_range</span><span class="p">,</span> <span class="n">index_range</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">uvw</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">slab_scale_factor</span> <span class="o">+</span> <span class="p">[</span><span class="n">uvw</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">latt</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">uvw</span><span class="p">)</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
                <span class="n">cosine</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">/</span> <span class="n">l</span><span class="p">)</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">uvw</span><span class="p">,</span> <span class="n">cosine</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">cosine</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
                    <span class="c1"># If cosine of 1 is found, no need to search further.</span>
                    <span class="k">break</span>
            <span class="c1"># We want the indices with the maximum absolute cosine,</span>
            <span class="c1"># but smallest possible length.</span>
            <span class="n">uvw</span><span class="p">,</span> <span class="n">cosine</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">slab_scale_factor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uvw</span><span class="p">)</span>

        <span class="n">slab_scale_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slab_scale_factor</span><span class="p">)</span>

        <span class="c1"># Let&#39;s make sure we have a left-handed crystallographic system</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">slab_scale_factor</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">slab_scale_factor</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Make sure the slab_scale_factor is reduced to avoid</span>
        <span class="c1"># unnecessarily large slabs</span>

        <span class="n">reduced_scale_factor</span> <span class="o">=</span> <span class="p">[</span><span class="n">reduce_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">slab_scale_factor</span><span class="p">]</span>
        <span class="n">slab_scale_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reduced_scale_factor</span><span class="p">)</span>

        <span class="n">single</span> <span class="o">=</span> <span class="n">initial_structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">single</span><span class="o">.</span><span class="n">make_supercell</span><span class="p">(</span><span class="n">slab_scale_factor</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">single</span><span class="p">,</span>
                                                       <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">initial_structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lll_reduce</span> <span class="o">=</span> <span class="n">lll_reduce</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_slab</span> <span class="o">=</span> <span class="n">center_slab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slab_scale_factor</span> <span class="o">=</span> <span class="n">slab_scale_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span> <span class="o">=</span> <span class="n">miller_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_vac_size</span> <span class="o">=</span> <span class="n">min_vacuum_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_slab_size</span> <span class="o">=</span> <span class="n">min_slab_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primitive</span> <span class="o">=</span> <span class="n">primitive</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span> <span class="o">=</span> <span class="n">normal</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proj_height</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>

<div class="viewcode-block" id="SlabGenerator.get_slab"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.SlabGenerator.get_slab">[docs]</a>    <span class="k">def</span> <span class="nf">get_slab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method takes in shift value for the c lattice direction and</span>
<span class="sd">        generates a slab based on the given shift. You should rarely use this</span>
<span class="sd">        method. Instead, it is used by other generation algorithms to obtain</span>
<span class="sd">        all slabs.</span>

<span class="sd">        Arg:</span>
<span class="sd">            shift (float): A shift value in Angstrom that determines how much a</span>
<span class="sd">                slab should be shifted.</span>
<span class="sd">            tol (float): Tolerance to determine primitive cell.</span>
<span class="sd">            energy (float): An energy to assign to the slab.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Slab) A Slab object with a particular shifted oriented unit cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proj_height</span>
        <span class="n">nlayers_slab</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_slab_size</span> <span class="o">/</span> <span class="n">h</span><span class="p">))</span>
        <span class="n">nlayers_vac</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_vac_size</span> <span class="o">/</span> <span class="n">h</span><span class="p">))</span>
        <span class="n">nlayers</span> <span class="o">=</span> <span class="n">nlayers_slab</span> <span class="o">+</span> <span class="n">nlayers_vac</span>

        <span class="n">species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">species_and_occu</span>
        <span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">site_properties</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="o">*</span> <span class="n">nlayers_slab</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">props</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">frac_coords</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span> <span class="o">+</span>\
                      <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">shift</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">frac_coords</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="n">new_lattice</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">nlayers</span> <span class="o">*</span> <span class="n">c</span><span class="p">]</span>
        <span class="n">frac_coords</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">frac_coords</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">nlayers</span>
        <span class="n">all_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlayers_slab</span><span class="p">):</span>
            <span class="n">fcoords</span> <span class="o">=</span> <span class="n">frac_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">fcoords</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">nlayers</span>
            <span class="n">all_coords</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fcoords</span><span class="p">)</span>

        <span class="n">slab</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">new_lattice</span><span class="p">,</span> <span class="n">species</span> <span class="o">*</span> <span class="n">nlayers_slab</span><span class="p">,</span> <span class="n">all_coords</span><span class="p">,</span>
                         <span class="n">site_properties</span><span class="o">=</span><span class="n">props</span><span class="p">)</span>

        <span class="n">scale_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slab_scale_factor</span>
        <span class="c1"># Whether or not to orthogonalize the structure</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lll_reduce</span><span class="p">:</span>
            <span class="n">lll_slab</span> <span class="o">=</span> <span class="n">slab</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sanitize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">lll_slab</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">find_mapping</span><span class="p">(</span><span class="n">slab</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">scale_factor</span><span class="p">)</span>
            <span class="n">slab</span> <span class="o">=</span> <span class="n">lll_slab</span>

        <span class="c1"># Whether or not to center the slab layer around the vacuum</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_slab</span><span class="p">:</span>
            <span class="n">avg_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">slab</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">])</span>
            <span class="n">slab</span><span class="o">.</span><span class="n">translate_sites</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slab</span><span class="p">))),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">avg_c</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">primitive</span><span class="p">:</span>
            <span class="n">prim</span> <span class="o">=</span> <span class="n">slab</span><span class="o">.</span><span class="n">get_primitive_structure</span><span class="p">(</span><span class="n">tolerance</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">energy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="n">prim</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span> <span class="n">slab</span><span class="o">.</span><span class="n">volume</span> <span class="o">*</span> <span class="n">energy</span>
            <span class="n">slab</span> <span class="o">=</span> <span class="n">prim</span>

        <span class="k">return</span> <span class="n">Slab</span><span class="p">(</span><span class="n">slab</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">slab</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">,</span>
                    <span class="n">slab</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span>
                    <span class="n">scale_factor</span><span class="p">,</span> <span class="n">site_properties</span><span class="o">=</span><span class="n">slab</span><span class="o">.</span><span class="n">site_properties</span><span class="p">,</span>
                    <span class="n">energy</span><span class="o">=</span><span class="n">energy</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_calculate_possible_shifts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">frac_coords</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Clustering does not work when there is only one data point.</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">frac_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">shift</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">shift</span><span class="p">)]</span>

        <span class="c1"># We cluster the sites according to the c coordinates. But we need to</span>
        <span class="c1"># take into account PBC. Let&#39;s compute a fractional c-coordinate</span>
        <span class="c1"># distance matrix that accounts for PBC.</span>
        <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proj_height</span>
        <span class="c1"># Projection of c lattice vector in</span>
        <span class="c1"># direction of surface normal.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">cdist</span> <span class="o">=</span> <span class="n">frac_coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">frac_coords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">cdist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cdist</span> <span class="o">-</span> <span class="nb">round</span><span class="p">(</span><span class="n">cdist</span><span class="p">))</span> <span class="o">*</span> <span class="n">h</span>
                <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdist</span>
                <span class="n">dist_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdist</span>

        <span class="n">condensed_m</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">condensed_m</span><span class="p">)</span>
        <span class="n">clusters</span> <span class="o">=</span> <span class="n">fcluster</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>

        <span class="c1"># Generate dict of cluster# to c val - doesn&#39;t matter what the c is.</span>
        <span class="n">c_loc</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">frac_coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">)}</span>

        <span class="c1"># Put all c into the unit cell.</span>
        <span class="n">possible_c</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">c_loc</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>

        <span class="c1"># Calculate the shifts</span>
        <span class="n">nshifts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_c</span><span class="p">)</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nshifts</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">nshifts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># There is an additional shift between the first and last c</span>
                <span class="c1"># coordinate. But this needs special handling because of PBC.</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">possible_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">possible_c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
                <span class="k">if</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">shift</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">possible_c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">possible_c</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">shifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shift</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">shift</span><span class="p">))</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">shifts</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shifts</span>

    <span class="k">def</span> <span class="nf">_get_c_ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bonds</span><span class="p">):</span>
        <span class="n">c_ranges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">bonds</span> <span class="o">=</span> <span class="p">{(</span><span class="n">get_el_sp</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="n">get_el_sp</span><span class="p">(</span><span class="n">s2</span><span class="p">)):</span> <span class="n">dist</span> <span class="k">for</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">),</span> <span class="n">dist</span> <span class="ow">in</span>
                 <span class="n">bonds</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">sp1</span><span class="p">,</span> <span class="n">sp2</span><span class="p">),</span> <span class="n">bond_dist</span> <span class="ow">in</span> <span class="n">bonds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sp1</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">nn</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span>
                            <span class="n">site</span><span class="p">,</span> <span class="n">bond_dist</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">sp2</span> <span class="ow">in</span> <span class="n">nn</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">:</span>
                            <span class="n">c_range</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                                    <span class="n">nn</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]]))</span>
                            <span class="k">if</span> <span class="n">c_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="c1"># Takes care of PBC when c coordinate of site</span>
                                <span class="c1"># goes beyond the upper boundary of the cell</span>
                                <span class="n">c_ranges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">c_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
                                <span class="n">c_ranges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                            <span class="k">elif</span> <span class="n">c_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1"># Takes care of PBC when c coordinate of site</span>
                                <span class="c1"># is below the lower boundary of the unit cell</span>
                                <span class="n">c_ranges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">c_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                                <span class="n">c_ranges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">c_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                            <span class="k">elif</span> <span class="n">c_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">c_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="n">c_ranges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c_range</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c_ranges</span>

<div class="viewcode-block" id="SlabGenerator.get_slabs"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.SlabGenerator.get_slabs">[docs]</a>    <span class="k">def</span> <span class="nf">get_slabs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_broken_bonds</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">symmetrize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns a list of slabs that are generated using the list of</span>
<span class="sd">        shift values from the method, _calculate_possible_shifts(). Before the</span>
<span class="sd">        shifts are used to create the slabs however, if the user decides to take</span>
<span class="sd">        into account whether or not a termination will break any polyhedral</span>
<span class="sd">        structure (bonds is not None), this method will filter out any shift</span>
<span class="sd">        values that do so.</span>

<span class="sd">        Args:</span>
<span class="sd">            bonds ({(specie1, specie2): max_bond_dist}: bonds are</span>
<span class="sd">                specified as a dict of tuples: float of specie1, specie2</span>
<span class="sd">                and the max bonding distance. For example, PO4 groups may be</span>
<span class="sd">                defined as {(&quot;P&quot;, &quot;O&quot;): 3}.</span>
<span class="sd">            tol (float): Threshold parameter in fcluster in order to check</span>
<span class="sd">                if two atoms are lying on the same plane. Default thresh set</span>
<span class="sd">                to 0.1 Angstrom in the direction of the surface normal.</span>
<span class="sd">            max_broken_bonds (int): Maximum number of allowable broken bonds</span>
<span class="sd">                for the slab. Use this to limit # of slabs (some structures</span>
<span class="sd">                may have a lot of slabs). Defaults to zero, which means no</span>
<span class="sd">                defined bonds must be broken.</span>
<span class="sd">            symmetrize (bool): Whether or not to ensure the surfaces of the</span>
<span class="sd">                slabs are equivalent.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ([Slab]) List of all possible terminations of a particular surface.</span>
<span class="sd">            Slabs are sorted by the # of bonds broken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c_ranges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="k">if</span> <span class="n">bonds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_c_ranges</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span>

        <span class="n">slabs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_possible_shifts</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">):</span>
            <span class="n">bonds_broken</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">c_ranges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">shift</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">bonds_broken</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">bonds_broken</span> <span class="o">&lt;=</span> <span class="n">max_broken_bonds</span><span class="p">:</span>
                <span class="c1"># For now, set the energy to be equal to no. of broken bonds</span>
                <span class="c1"># per unit cell.</span>
                <span class="n">slab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slab</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="n">bonds_broken</span><span class="p">)</span>
                <span class="n">slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span>

        <span class="c1"># Further filters out any surfaces made that might be the same</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">StructureMatcher</span><span class="p">(</span><span class="n">ltol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">stol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">primitive_cell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">scale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">new_slabs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">original_formula</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">reduced_formula</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">group_structures</span><span class="p">(</span><span class="n">slabs</span><span class="p">):</span>
            <span class="c1"># For each unique termination, symmetrize the</span>
            <span class="c1"># surfaces by removing sites from the bottom.</span>
            <span class="k">if</span> <span class="n">symmetrize</span><span class="p">:</span>
                <span class="n">slab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetrize_slab</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">original_formula</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">(</span><span class="n">slab</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">reduced_formula</span><span class="p">):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;WARNING: Stoichiometry is no longer the &quot;</span>
                                  <span class="s2">&quot;same due to symmetrization&quot;</span><span class="p">)</span>
                <span class="n">new_slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">new_slabs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span></div>

<div class="viewcode-block" id="SlabGenerator.symmetrize_slab"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.SlabGenerator.symmetrize_slab">[docs]</a>    <span class="k">def</span> <span class="nf">symmetrize_slab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slab</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method checks whether or not the two surfaces of the slab are</span>
<span class="sd">        equivalent. If the point group of the slab has an inversion symmetry (</span>
<span class="sd">        ie. belong to one of the Laue groups), then it is assumed that the</span>
<span class="sd">        surfaces should be equivalent. Otherwise, sites at the bottom of the</span>
<span class="sd">        slab will be removed until the slab is symmetric. Note that this method</span>
<span class="sd">        should only be limited to elemental structures as the removal of sites</span>
<span class="sd">        can destroy the stoichiometry of the slab. For non-elemental</span>
<span class="sd">        structures, use is_polar().</span>

<span class="sd">        Arg:</span>
<span class="sd">            slab (Structure): A single slab structure</span>
<span class="sd">            tol (float): Tolerance for SpaceGroupanalyzer.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Slab (structure): A symmetrized Slab object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">laue</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;-1&quot;</span><span class="p">,</span> <span class="s2">&quot;2/m&quot;</span><span class="p">,</span> <span class="s2">&quot;mmm&quot;</span><span class="p">,</span> <span class="s2">&quot;4/m&quot;</span><span class="p">,</span> <span class="s2">&quot;4/mmm&quot;</span><span class="p">,</span>
                <span class="s2">&quot;-3&quot;</span><span class="p">,</span> <span class="s2">&quot;-3m&quot;</span><span class="p">,</span> <span class="s2">&quot;6/m&quot;</span><span class="p">,</span> <span class="s2">&quot;6/mmm&quot;</span><span class="p">,</span> <span class="s2">&quot;m-3&quot;</span><span class="p">,</span> <span class="s2">&quot;m-3m&quot;</span><span class="p">]</span>

        <span class="n">sg</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
        <span class="n">pg</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">get_point_group_symbol</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">pg</span><span class="p">)</span> <span class="ow">in</span> <span class="n">laue</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">slab</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">asym</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">while</span> <span class="n">asym</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">)):</span>

                <span class="c1"># Keep removing sites from the bottom one by one until both</span>
                <span class="c1"># surfaces are symmetric or the number of sites removed has</span>
                <span class="c1"># exceeded 10 percent of the original slab</span>

                <span class="n">c_dir</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slab</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)]</span>

                <span class="n">slab</span><span class="o">.</span><span class="n">remove_sites</span><span class="p">([</span><span class="n">c_dir</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">c_dir</span><span class="p">))])</span>

                <span class="c1"># Check if the altered surface is symmetric</span>

                <span class="n">sg</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
                <span class="n">pg</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">get_point_group_symbol</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">pg</span><span class="p">)</span> <span class="ow">in</span> <span class="n">laue</span><span class="p">:</span>
                    <span class="n">asym</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Too many sites removed, please use a larger slab &quot;</span>
                          <span class="s2">&quot;size.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">slab</span></div></div>


<div class="viewcode-block" id="get_recp_symmetry_operation"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.get_recp_symmetry_operation">[docs]</a><span class="k">def</span> <span class="nf">get_recp_symmetry_operation</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the symmetric operations of the reciprocal lattice,</span>
<span class="sd">    to be used for hkl transformations</span>
<span class="sd">    Args:</span>
<span class="sd">        structure (Structure): conventional unit cell</span>
<span class="sd">        symprec: default is 0.001</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">recp_lattice</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice_crystallographic</span>
    <span class="c1"># get symmetry operations from input conventional unit cell</span>
    <span class="c1"># Need to make sure recp lattice is big enough, otherwise symmetry</span>
    <span class="c1"># determination will fail. We set the overall volume to 1.</span>
    <span class="n">recp_lattice</span> <span class="o">=</span> <span class="n">recp_lattice</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">recp</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">recp_lattice</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="c1"># Creates a function that uses the symmetry operations in the</span>
    <span class="c1"># structure to find Miller indices that might give repetitive slabs</span>
    <span class="n">analyzer</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">recp</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">)</span>
    <span class="n">recp_symmops</span> <span class="o">=</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">get_symmetry_operations</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">recp_symmops</span></div>


<div class="viewcode-block" id="get_symmetrically_distinct_miller_indices"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.get_symmetrically_distinct_miller_indices">[docs]</a><span class="k">def</span> <span class="nf">get_symmetrically_distinct_miller_indices</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">max_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns all symmetrically distinct indices below a certain max-index for</span>
<span class="sd">    a given structure. Analysis is based on the symmetry of the reciprocal</span>
<span class="sd">    lattice of the structure.</span>
<span class="sd">    Args:</span>
<span class="sd">        structure (Structure): input structure.</span>
<span class="sd">        max_index (int): The maximum index. For example, a max_index of 1</span>
<span class="sd">            means that (100), (110), and (111) are returned for the cubic</span>
<span class="sd">            structure. All other indices are equivalent to one of these.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">symm_ops</span> <span class="o">=</span> <span class="n">get_recp_symmetry_operation</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
    <span class="n">unique_millers</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">is_already_analyzed</span><span class="p">(</span><span class="n">miller_index</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">symm_ops</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">in_coord_list</span><span class="p">(</span><span class="n">unique_millers</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">miller_index</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_index</span><span class="p">,</span> <span class="n">max_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">r</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">miller</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">miller</span><span class="p">]):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">gcd</span><span class="p">,</span> <span class="n">miller</span><span class="p">))</span>
            <span class="n">miller</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">miller</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_already_analyzed</span><span class="p">(</span><span class="n">miller</span><span class="p">):</span>
                <span class="n">unique_millers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">miller</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unique_millers</span></div>


<div class="viewcode-block" id="generate_all_slabs"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.generate_all_slabs">[docs]</a><span class="k">def</span> <span class="nf">generate_all_slabs</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">max_index</span><span class="p">,</span> <span class="n">min_slab_size</span><span class="p">,</span> <span class="n">min_vacuum_size</span><span class="p">,</span>
                       <span class="n">bonds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">max_broken_bonds</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">lll_reduce</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">center_slab</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">primitive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">max_normal_search</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">symmetrize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function that finds all different slabs up to a certain miller index.</span>
<span class="sd">    Slabs oriented under certain Miller indices that are equivalent to other</span>
<span class="sd">    slabs in other Miller indices are filtered out using symmetry operations</span>
<span class="sd">    to get rid of any repetitive slabs. For example, under symmetry operations,</span>
<span class="sd">    CsCl has equivalent slabs in the (0,0,1), (0,1,0), and (1,0,0) direction.</span>

<span class="sd">    Args:</span>
<span class="sd">        structure (Structure): Initial input structure. Note that to</span>
<span class="sd">                ensure that the miller indices correspond to usual</span>
<span class="sd">                crystallographic definitions, you should supply a conventional</span>
<span class="sd">                unit cell structure.</span>
<span class="sd">        max_index (int): The maximum Miller index to go up to.</span>
<span class="sd">        min_slab_size (float): In Angstroms</span>
<span class="sd">        min_vacuum_size (float): In Angstroms</span>
<span class="sd">        bonds ({(specie1, specie2): max_bond_dist}: bonds are</span>
<span class="sd">            specified as a dict of tuples: float of specie1, specie2</span>
<span class="sd">            and the max bonding distance. For example, PO4 groups may be</span>
<span class="sd">            defined as {(&quot;P&quot;, &quot;O&quot;): 3}.</span>
<span class="sd">        tol (float): Threshold parameter in fcluster in order to check</span>
<span class="sd">            if two atoms are lying on the same plane. Default thresh set</span>
<span class="sd">            to 0.1 Angstrom in the direction of the surface normal.</span>
<span class="sd">        max_broken_bonds (int): Maximum number of allowable broken bonds</span>
<span class="sd">            for the slab. Use this to limit # of slabs (some structures</span>
<span class="sd">            may have a lot of slabs). Defaults to zero, which means no</span>
<span class="sd">            defined bonds must be broken.</span>
<span class="sd">        lll_reduce (bool): Whether to perform an LLL reduction on the</span>
<span class="sd">            eventual structure.</span>
<span class="sd">        center_slab (bool): Whether to center the slab in the cell with</span>
<span class="sd">            equal vacuum spacing from the top and bottom.</span>
<span class="sd">        primitive (bool): Whether to reduce any generated slabs to a</span>
<span class="sd">            primitive cell (this does **not** mean the slab is generated</span>
<span class="sd">            from a primitive cell, it simply means that after slab</span>
<span class="sd">            generation, we attempt to find shorter lattice vectors,</span>
<span class="sd">            which lead to less surface area and smaller cells).</span>
<span class="sd">        max_normal_search (int): If set to a positive integer, the code will</span>
<span class="sd">            conduct a search for a normal lattice vector that is as</span>
<span class="sd">            perpendicular to the surface as possible by considering</span>
<span class="sd">            multiples linear combinations of lattice vectors up to</span>
<span class="sd">            max_normal_search. This has no bearing on surface energies,</span>
<span class="sd">            but may be useful as a preliminary step to generating slabs</span>
<span class="sd">            for absorption and other sizes. It is typical that this will</span>
<span class="sd">            not be the smallest possible cell for simulation. Normality</span>
<span class="sd">            is not guaranteed, but the oriented cell will have the c</span>
<span class="sd">            vector as normal as possible (within the search range) to the</span>
<span class="sd">            surface. A value of up to the max absolute Miller index is</span>
<span class="sd">            usually sufficient.</span>
<span class="sd">        symmetrize (bool): Whether or not to ensure the surfaces of the</span>
<span class="sd">            slabs are equivalent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_slabs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">miller</span> <span class="ow">in</span> <span class="n">get_symmetrically_distinct_miller_indices</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span>
                                                            <span class="n">max_index</span><span class="p">):</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="n">SlabGenerator</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">miller</span><span class="p">,</span> <span class="n">min_slab_size</span><span class="p">,</span>
                            <span class="n">min_vacuum_size</span><span class="p">,</span> <span class="n">lll_reduce</span><span class="o">=</span><span class="n">lll_reduce</span><span class="p">,</span>
                            <span class="n">center_slab</span><span class="o">=</span><span class="n">center_slab</span><span class="p">,</span> <span class="n">primitive</span><span class="o">=</span><span class="n">primitive</span><span class="p">,</span>
                            <span class="n">max_normal_search</span><span class="o">=</span><span class="n">max_normal_search</span><span class="p">)</span>
        <span class="n">slabs</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">get_slabs</span><span class="p">(</span><span class="n">bonds</span><span class="o">=</span><span class="n">bonds</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">symmetrize</span><span class="o">=</span><span class="n">symmetrize</span><span class="p">,</span>
                              <span class="n">max_broken_bonds</span><span class="o">=</span><span class="n">max_broken_bonds</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slabs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has </span><span class="si">%d</span><span class="s2"> slabs... &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">miller</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">slabs</span><span class="p">)))</span>
            <span class="n">all_slabs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">slabs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">all_slabs</span></div>


<div class="viewcode-block" id="reduce_vector"><a class="viewcode-back" href="../../../pymatgen.core.surface.html#pymatgen.core.surface.reduce_vector">[docs]</a><span class="k">def</span> <span class="nf">reduce_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">):</span>

    <span class="c1"># small function to reduce vectors</span>

    <span class="n">d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">gcd</span><span class="p">,</span> <span class="n">vector</span><span class="p">))</span>
    <span class="n">vector</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">vector</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pymatgen 2017.8.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../pymatgen.html" >pymatgen</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2011, Pymatgen Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.3.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>