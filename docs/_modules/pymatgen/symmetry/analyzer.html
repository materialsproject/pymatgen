
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pymatgen.symmetry.analyzer &#8212; pymatgen 2018.9.12 documentation</title>
    <link rel="stylesheet" href="../../../_static/proBlue.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pymatgen 2018.9.12 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../pymatgen.html" accesskey="U">pymatgen</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.symmetry.analyzer</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="c1"># Copyright (c) Pymatgen Development Team.</span>
<span class="c1"># Distributed under the terms of the MIT License.</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">cos</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sin</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">Fraction</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">zip</span>
<span class="kn">import</span> <span class="nn">spglib</span>

<span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="k">import</span> <span class="n">Structure</span><span class="p">,</span> <span class="n">Molecule</span>
<span class="kn">from</span> <span class="nn">pymatgen.symmetry.structure</span> <span class="k">import</span> <span class="n">SymmetrizedStructure</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.lattice</span> <span class="k">import</span> <span class="n">Lattice</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.structure</span> <span class="k">import</span> <span class="n">PeriodicSite</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.operations</span> <span class="k">import</span> <span class="n">SymmOp</span>
<span class="kn">from</span> <span class="nn">pymatgen.util.coord</span> <span class="k">import</span> <span class="n">find_in_coord_list</span><span class="p">,</span> <span class="n">pbc_diff</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An interface to the excellent spglib library by Atsushi Togo</span>
<span class="sd">(http://spglib.sourceforge.net/) for pymatgen.</span>

<span class="sd">v1.0 - Now works with both ordered and disordered structure.</span>
<span class="sd">v2.0 - Updated for spglib 1.6.</span>
<span class="sd">v3.0 - pymatgen no longer ships with spglib. Instead, spglib (the python</span>
<span class="sd">       version) is now a dependency and the SpacegroupAnalyzer merely serves</span>
<span class="sd">       as an interface to spglib for pymatgen Structures.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Shyue Ping Ong&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2012, The Materials Project&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;3.0&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Shyue Ping Ong&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;shyuep@gmail.com&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;May 14, 2016&quot;</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="SpacegroupAnalyzer"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer">[docs]</a><span class="k">class</span> <span class="nc">SpacegroupAnalyzer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a pymatgen.core.structure.Structure object and a symprec.</span>
<span class="sd">    Uses pyspglib to perform various symmetry finding operations.</span>

<span class="sd">    Args:</span>
<span class="sd">        structure (Structure/IStructure): Structure to find symmetry</span>
<span class="sd">        symprec (float): Tolerance for symmetry finding. Defaults to 0.01,</span>
<span class="sd">            which is fairly strict and works well for properly refined</span>
<span class="sd">            structures with atoms in the proper symmetry coordinates. For</span>
<span class="sd">            structures with slight deviations from their proper atomic</span>
<span class="sd">            positions (e.g., structures relaxed with electronic structure</span>
<span class="sd">            codes), a looser tolerance of 0.1 (the value used in Materials</span>
<span class="sd">            Project) is often needed.</span>
<span class="sd">        angle_tolerance (float): Angle tolerance for symmetry finding.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_symprec</span> <span class="o">=</span> <span class="n">symprec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_angle_tol</span> <span class="o">=</span> <span class="n">angle_tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">structure</span>
        <span class="n">latt</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">frac_coords</span>
        <span class="n">unique_species</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">magmoms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">species</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span>
                                            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">unique_species</span><span class="p">:</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">unique_species</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">species</span><span class="p">)</span>
                <span class="n">zs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">g</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">species</span><span class="p">)</span>
                <span class="n">zs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_species</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">g</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="s1">&#39;magmom&#39;</span><span class="p">):</span>
                <span class="n">magmoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">magmom</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">site</span><span class="o">.</span><span class="n">is_ordered</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="s1">&#39;spin&#39;</span><span class="p">):</span>
                <span class="n">magmoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">magmoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_unique_species</span> <span class="o">=</span> <span class="n">unique_species</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_numbers</span> <span class="o">=</span> <span class="n">zs</span>
        <span class="c1"># For now, we are setting magmom to zero.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cell</span> <span class="o">=</span> <span class="n">latt</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">magmoms</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_space_group_data</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cell</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_symprec</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_space_group_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the spacegroup symbol (e.g., Pnma) for structure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (str): Spacegroup symbol for structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space_group_data</span><span class="p">[</span><span class="s2">&quot;international&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_space_group_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the international spacegroup number (e.g., 62) for structure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (int): International spacegroup number for structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_space_group_data</span><span class="p">[</span><span class="s2">&quot;number&quot;</span><span class="p">])</span>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_space_group_operations"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_space_group_operations">[docs]</a>    <span class="k">def</span> <span class="nf">get_space_group_operations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the SpacegroupOperations for the Structure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SpacgroupOperations object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SpacegroupOperations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_space_group_symbol</span><span class="p">(),</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">get_space_group_number</span><span class="p">(),</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">get_symmetry_operations</span><span class="p">())</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_space_group_symbol"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_space_group_symbol">[docs]</a>    <span class="k">def</span> <span class="nf">get_space_group_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the spacegroup symbol (e.g., Pnma) for structure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (str): Spacegroup symbol for structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space_group_data</span><span class="p">[</span><span class="s2">&quot;international&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_space_group_number"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_space_group_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_space_group_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the international spacegroup number (e.g., 62) for structure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (int): International spacegroup number for structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_space_group_data</span><span class="p">[</span><span class="s2">&quot;number&quot;</span><span class="p">])</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_hall"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_hall">[docs]</a>    <span class="k">def</span> <span class="nf">get_hall</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns Hall symbol for structure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (str): Hall symbol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space_group_data</span><span class="p">[</span><span class="s2">&quot;hall&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_point_group_symbol"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_point_group_symbol">[docs]</a>    <span class="k">def</span> <span class="nf">get_point_group_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the point group associated with the structure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Pointgroup): Point group for structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rotations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space_group_data</span><span class="p">[</span><span class="s2">&quot;rotations&quot;</span><span class="p">]</span>
        <span class="c1"># passing a 0-length rotations list to spglib can segfault</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rotations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;1&#39;</span>
        <span class="k">return</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_pointgroup</span><span class="p">(</span><span class="n">rotations</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_crystal_system"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_crystal_system">[docs]</a>    <span class="k">def</span> <span class="nf">get_crystal_system</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the crystal system for the structure, e.g., (triclinic,</span>
<span class="sd">        orthorhombic, cubic, etc.).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (str): Crystal system for structure or None if system cannot be detected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space_group_data</span><span class="p">[</span><span class="s2">&quot;number&quot;</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">j</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;triclinic&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s2">&quot;monoclinic&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
              <span class="s2">&quot;orthorhombic&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">74</span><span class="p">),</span> <span class="s2">&quot;tetragonal&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">75</span><span class="p">,</span> <span class="mi">142</span><span class="p">),</span>
              <span class="s2">&quot;trigonal&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">143</span><span class="p">,</span> <span class="mi">167</span><span class="p">),</span> <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">168</span><span class="p">,</span> <span class="mi">194</span><span class="p">),</span>
              <span class="s2">&quot;cubic&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">195</span><span class="p">,</span> <span class="mi">230</span><span class="p">)}</span>

        <span class="n">crystal_sytem</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">):</span>
                <span class="n">crystal_sytem</span> <span class="o">=</span> <span class="n">k</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">crystal_sytem</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_lattice_type"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_lattice_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_lattice_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the lattice for the structure, e.g., (triclinic,</span>
<span class="sd">        orthorhombic, cubic, etc.).This is the same than the</span>
<span class="sd">        crystal system with the exception of the hexagonal/rhombohedral</span>
<span class="sd">        lattice</span>

<span class="sd">        Returns:</span>
<span class="sd">            (str): Lattice type for structure or None if type cannot be detected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space_group_data</span><span class="p">[</span><span class="s2">&quot;number&quot;</span><span class="p">]</span>
        <span class="n">system</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crystal_system</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">146</span><span class="p">,</span> <span class="mi">148</span><span class="p">,</span> <span class="mi">155</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">161</span><span class="p">,</span> <span class="mi">166</span><span class="p">,</span> <span class="mi">167</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;rhombohedral&quot;</span>
        <span class="k">elif</span> <span class="n">system</span> <span class="o">==</span> <span class="s2">&quot;trigonal&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;hexagonal&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">system</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_symmetry_dataset"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_symmetry_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">get_symmetry_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the symmetry dataset as a dict.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (dict): With the following properties:</span>
<span class="sd">            number: International space group number</span>
<span class="sd">            international: International symbol</span>
<span class="sd">            hall: Hall symbol</span>
<span class="sd">            transformation_matrix: Transformation matrix from lattice of</span>
<span class="sd">            input cell to Bravais lattice L^bravais = L^original * Tmat</span>
<span class="sd">            origin shift: Origin shift in the setting of &quot;Bravais lattice&quot;</span>
<span class="sd">            rotations, translations: Rotation matrices and translation</span>
<span class="sd">            vectors. Space group operations are obtained by</span>
<span class="sd">            [(r,t) for r, t in zip(rotations, translations)]</span>
<span class="sd">            wyckoffs: Wyckoff letters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space_group_data</span></div>

    <span class="k">def</span> <span class="nf">_get_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the symmetry operations associated with the structure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Symmetry operations as a tuple of two equal length sequences.</span>
<span class="sd">            (rotations, translations). &quot;rotations&quot; is the numpy integer array</span>
<span class="sd">            of the rotation matrices for scaled positions</span>
<span class="sd">            &quot;translations&quot; gives the numpy float64 array of the translation</span>
<span class="sd">            vectors in scaled positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cell</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_symprec</span><span class="p">,</span>
                                <span class="n">angle_tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_angle_tol</span><span class="p">)</span>
        <span class="c1"># Sometimes spglib returns small translation vectors, e.g.</span>
        <span class="c1"># [1e-4, 2e-4, 1e-4]</span>
        <span class="c1"># (these are in fractional coordinates, so should be small denominator</span>
        <span class="c1"># fractions)</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;translations&quot;</span><span class="p">]:</span>
            <span class="n">trans</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">Fraction</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
                          <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">t</span><span class="p">])</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>

        <span class="c1"># fractional translations of 1 are more simply 0</span>
        <span class="n">trans</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;rotations&quot;</span><span class="p">],</span> <span class="n">trans</span>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_symmetry_operations"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_symmetry_operations">[docs]</a>    <span class="k">def</span> <span class="nf">get_symmetry_operations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return symmetry operations as a list of SymmOp objects.</span>
<span class="sd">        By default returns fractional coord symmops.</span>
<span class="sd">        But cartesian can be returned too.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ([SymmOp]): List of symmetry operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_symmetry</span><span class="p">()</span>
        <span class="n">symmops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span>
        <span class="n">invmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rot</span><span class="p">,</span> <span class="n">trans</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cartesian</span><span class="p">:</span>
                <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">invmat</span><span class="p">))</span>
                <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
            <span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">symmops</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_point_group_operations"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_point_group_operations">[docs]</a>    <span class="k">def</span> <span class="nf">get_point_group_operations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return symmetry operations as a list of SymmOp objects.</span>
<span class="sd">        By default returns fractional coord symmops.</span>
<span class="sd">        But cartesian can be returned too.</span>

<span class="sd">        Args:</span>
<span class="sd">            cartesian (bool): Whether to return SymmOps as cartesian or</span>
<span class="sd">                direct coordinate operations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ([SymmOp]): List of point group symmetry operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rotation</span><span class="p">,</span> <span class="n">translation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_symmetry</span><span class="p">()</span>
        <span class="n">symmops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span>
        <span class="n">invmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rot</span> <span class="ow">in</span> <span class="n">rotation</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cartesian</span><span class="p">:</span>
                <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">invmat</span><span class="p">))</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_rotation_and_translation</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">symmops</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_symmetrized_structure"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_symmetrized_structure">[docs]</a>    <span class="k">def</span> <span class="nf">get_symmetrized_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a symmetrized structure. A symmetrized structure is one where the</span>
<span class="sd">        sites have been grouped into symmetrically equivalent groups.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`pymatgen.symmetry.structure.SymmetrizedStructure` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">()</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="n">SpacegroupOperations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_space_group_symbol</span><span class="p">(),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">get_space_group_number</span><span class="p">(),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">get_symmetry_operations</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">SymmetrizedStructure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_structure</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span>
                                    <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;equivalent_atoms&quot;</span><span class="p">],</span>
                                    <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;wyckoffs&quot;</span><span class="p">])</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_refined_structure"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_refined_structure">[docs]</a>    <span class="k">def</span> <span class="nf">get_refined_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the refined structure based on detected symmetry. The refined</span>
<span class="sd">        structure is a *conventional* cell setting with atoms moved to the</span>
<span class="sd">        expected symmetry positions.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Refined structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Atomic positions have to be specified by scaled positions for spglib.</span>
        <span class="n">lattice</span><span class="p">,</span> <span class="n">scaled_positions</span><span class="p">,</span> <span class="n">numbers</span> \
            <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">refine_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symprec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_angle_tol</span><span class="p">)</span>

        <span class="n">species</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_unique_species</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">scaled_positions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">get_sorted_structure</span><span class="p">()</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.find_primitive"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.find_primitive">[docs]</a>    <span class="k">def</span> <span class="nf">find_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a primitive version of the unit cell.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A primitive cell in the input cell is searched and returned</span>
<span class="sd">            as an Structure object. If no primitive cell is found, None is</span>
<span class="sd">            returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lattice</span><span class="p">,</span> <span class="n">scaled_positions</span><span class="p">,</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">find_primitive</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cell</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_symprec</span><span class="p">)</span>

        <span class="n">species</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_unique_species</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Structure</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">scaled_positions</span><span class="p">,</span>
                         <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">get_reduced_structure</span><span class="p">()</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_ir_reciprocal_mesh"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_ir_reciprocal_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">get_ir_reciprocal_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">is_shift</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        k-point mesh of the Brillouin zone generated taken into account</span>
<span class="sd">        symmetry.The method returns the irreducible kpoints of the mesh</span>
<span class="sd">        and their weights</span>

<span class="sd">        Args:</span>
<span class="sd">            mesh (3x1 array): The number of kpoint for the mesh needed in</span>
<span class="sd">                each direction</span>
<span class="sd">            is_shift (3x1 array): Whether to shift the kpoint grid. (1, 1,</span>
<span class="sd">            1) means all points are shifted by 0.5, 0.5, 0.5.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of irreducible kpoints and their weights as a list of</span>
<span class="sd">            tuples [(ir_kpoint, weight)], with ir_kpoint given</span>
<span class="sd">            in fractional coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">is_shift</span><span class="p">])</span>
        <span class="n">mapping</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_ir_reciprocal_mesh</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell</span><span class="p">,</span> <span class="n">is_shift</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_symprec</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tmp_map</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mapping</span><span class="p">):</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span> <span class="o">/</span> <span class="n">mesh</span><span class="p">,</span>
                            <span class="n">tmp_map</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_primitive_standard_structure"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_primitive_standard_structure">[docs]</a>    <span class="k">def</span> <span class="nf">get_primitive_standard_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">international_monoclinic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives a structure with a primitive cell according to certain standards</span>
<span class="sd">        the standards are defined in Setyawan, W., &amp; Curtarolo, S. (2010).</span>
<span class="sd">        High-throughput electronic band structure calculations:</span>
<span class="sd">        Challenges and tools. Computational Materials Science,</span>
<span class="sd">        49(2), 299-312. doi:10.1016/j.commatsci.2010.05.010</span>

<span class="sd">        Returns:</span>
<span class="sd">            The structure in a primitive standardized cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_conventional_standard_structure</span><span class="p">(</span>
            <span class="n">international_monoclinic</span><span class="o">=</span><span class="n">international_monoclinic</span><span class="p">)</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lattice_type</span><span class="p">()</span>

        <span class="k">if</span> <span class="s2">&quot;P&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_space_group_symbol</span><span class="p">()</span> <span class="ow">or</span> <span class="n">lattice</span> <span class="o">==</span> <span class="s2">&quot;hexagonal&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conv</span>

        <span class="k">if</span> <span class="n">lattice</span> <span class="o">==</span> <span class="s2">&quot;rhombohedral&quot;</span><span class="p">:</span>
            <span class="c1"># check if the conventional representation is hexagonal or</span>
            <span class="c1"># rhombohedral</span>
            <span class="n">lengths</span><span class="p">,</span> <span class="n">angles</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">lengths_and_angles</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.0001</span><span class="p">:</span>
                <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                                  <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>

        <span class="k">elif</span> <span class="s2">&quot;I&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_space_group_symbol</span><span class="p">():</span>
            <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]],</span>
                              <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="s2">&quot;F&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_space_group_symbol</span><span class="p">():</span>
            <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
                              <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="s2">&quot;C&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_space_group_symbol</span><span class="p">()</span> <span class="ow">or</span> <span class="s2">&quot;A&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_space_group_symbol</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_crystal_system</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;monoclinic&quot;</span><span class="p">:</span>
                <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                                  <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                                  <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="n">new_sites</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">latt</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transf</span><span class="p">,</span> <span class="n">conv</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">conv</span><span class="p">:</span>
            <span class="n">new_s</span> <span class="o">=</span> <span class="n">PeriodicSite</span><span class="p">(</span>
                <span class="n">s</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">latt</span><span class="p">,</span>
                <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">properties</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">new_s</span><span class="o">.</span><span class="n">is_periodic_image</span><span class="p">,</span> <span class="n">new_sites</span><span class="p">)):</span>
                <span class="n">new_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_s</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lattice</span> <span class="o">==</span> <span class="s2">&quot;rhombohedral&quot;</span><span class="p">:</span>
            <span class="n">prim</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">new_sites</span><span class="p">)</span>
            <span class="n">lengths</span><span class="p">,</span> <span class="n">angles</span> <span class="o">=</span> <span class="n">prim</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">lengths_and_angles</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">180</span>
            <span class="n">new_matrix</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="n">a</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="n">a</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="n">a</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">a</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="n">a</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">a</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))]]</span>
            <span class="n">new_sites</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">latt</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">new_matrix</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">prim</span><span class="p">:</span>
                <span class="n">new_s</span> <span class="o">=</span> <span class="n">PeriodicSite</span><span class="p">(</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">latt</span><span class="p">,</span>
                    <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">new_s</span><span class="o">.</span><span class="n">is_periodic_image</span><span class="p">,</span> <span class="n">new_sites</span><span class="p">)):</span>
                    <span class="n">new_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_s</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">new_sites</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">new_sites</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_conventional_standard_structure"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_conventional_standard_structure">[docs]</a>    <span class="k">def</span> <span class="nf">get_conventional_standard_structure</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">international_monoclinic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives a structure with a conventional cell according to certain</span>
<span class="sd">        standards. The standards are defined in Setyawan, W., &amp; Curtarolo,</span>
<span class="sd">        S. (2010). High-throughput electronic band structure calculations:</span>
<span class="sd">        Challenges and tools. Computational Materials Science,</span>
<span class="sd">        49(2), 299-312. doi:10.1016/j.commatsci.2010.05.010</span>
<span class="sd">        They basically enforce as much as possible</span>
<span class="sd">        norm(a1)&lt;norm(a2)&lt;norm(a3)</span>

<span class="sd">        Returns:</span>
<span class="sd">            The structure in a conventional standardized cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-5</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_refined_structure</span><span class="p">()</span>
        <span class="n">latt</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">lattice</span>
        <span class="n">latt_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lattice_type</span><span class="p">()</span>
        <span class="n">sorted_lengths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">latt</span><span class="o">.</span><span class="n">abc</span><span class="p">)</span>
        <span class="n">sorted_dic</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([{</span><span class="s1">&#39;vec&#39;</span><span class="p">:</span> <span class="n">latt</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                              <span class="s1">&#39;length&#39;</span><span class="p">:</span> <span class="n">latt</span><span class="o">.</span><span class="n">abc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                              <span class="s1">&#39;orig_index&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">latt_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;orthorhombic&quot;</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">):</span>
            <span class="c1"># you want to keep the c axis where it is</span>
            <span class="c1"># to keep the C- settings</span>
            <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_space_group_symbol</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
                <span class="n">transf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">latt</span><span class="o">.</span><span class="n">abc</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">sorted_dic</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([{</span><span class="s1">&#39;vec&#39;</span><span class="p">:</span> <span class="n">latt</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                      <span class="s1">&#39;length&#39;</span><span class="p">:</span> <span class="n">latt</span><span class="o">.</span><span class="n">abc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                      <span class="s1">&#39;orig_index&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">transf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sorted_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;orig_index&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">latt</span><span class="o">.</span><span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_space_group_symbol</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">):</span> <span class="c1">#change to C-centering to match Setyawan/Curtarolo convention</span>
                <span class="n">transf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">latt</span><span class="o">.</span><span class="n">abc</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">sorted_dic</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([{</span><span class="s1">&#39;vec&#39;</span><span class="p">:</span> <span class="n">latt</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                      <span class="s1">&#39;length&#39;</span><span class="p">:</span> <span class="n">latt</span><span class="o">.</span><span class="n">abc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                      <span class="s1">&#39;orig_index&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">transf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sorted_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;orig_index&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">latt</span><span class="o">.</span><span class="n">abc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_dic</span><span class="p">)):</span>
                    <span class="n">transf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">sorted_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;orig_index&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">sorted_lengths</span>
            <span class="n">latt</span> <span class="o">=</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">orthorhombic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">latt_type</span> <span class="o">==</span> <span class="s2">&quot;tetragonal&quot;</span><span class="p">:</span>
            <span class="c1"># find the &quot;a&quot; vectors</span>
            <span class="c1"># it is basically the vector repeated two times</span>
            <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">sorted_lengths</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_dic</span><span class="p">)):</span>
                <span class="n">transf</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="n">sorted_dic</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="s1">&#39;orig_index&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span>
                <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">transf</span><span class="p">)</span>
            <span class="n">latt</span> <span class="o">=</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">tetragonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">latt_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;hexagonal&quot;</span><span class="p">,</span> <span class="s2">&quot;rhombohedral&quot;</span><span class="p">):</span>
            <span class="c1"># for the conventional cell representation,</span>
            <span class="c1"># we allways show the rhombohedral lattices as hexagonal</span>

            <span class="c1"># check first if we have the refined structure shows a rhombohedral</span>
            <span class="c1"># cell</span>
            <span class="c1"># if so, make a supercell</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">latt</span><span class="o">.</span><span class="n">abc</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">([</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">):</span>
                <span class="n">struct</span><span class="o">.</span><span class="n">make_supercell</span><span class="p">(((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">abc</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span>
            <span class="n">new_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">]]</span>
            <span class="n">latt</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">new_matrix</span><span class="p">)</span>
            <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">latt_type</span> <span class="o">==</span> <span class="s2">&quot;monoclinic&quot;</span><span class="p">:</span>
            <span class="c1"># You want to keep the c axis where it is to keep the C- settings</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_space_group_operations</span><span class="p">()</span><span class="o">.</span><span class="n">int_symbol</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
                <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">transf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">sorted_dic</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([{</span><span class="s1">&#39;vec&#39;</span><span class="p">:</span> <span class="n">latt</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                      <span class="s1">&#39;length&#39;</span><span class="p">:</span> <span class="n">latt</span><span class="o">.</span><span class="n">abc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                      <span class="s1">&#39;orig_index&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
                                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">])</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">sorted_dic</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;length&#39;</span><span class="p">]</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">sorted_dic</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;length&#39;</span><span class="p">]</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">latt</span><span class="o">.</span><span class="n">abc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">new_matrix</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">latt</span><span class="o">.</span><span class="n">matrix</span>
                    <span class="n">landang</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">m</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">lengths_and_angles</span>
                    <span class="k">if</span> <span class="n">landang</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">:</span>
                        <span class="c1"># if the angle is &gt; 90 we invert a and b to get</span>
                        <span class="c1"># an angle &lt; 90</span>
                        <span class="n">landang</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span>
                            <span class="p">[</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span><span class="o">.</span><span class="n">lengths_and_angles</span>
                        <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                        <span class="n">transf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">transf</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">transf</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">landang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">alpha</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">landang</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">180</span>
                        <span class="n">new_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="n">c</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)]]</span>
                        <span class="k">continue</span>

                    <span class="k">elif</span> <span class="n">landang</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                        <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                        <span class="n">transf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">transf</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">transf</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">landang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">alpha</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">landang</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">180</span>
                        <span class="n">new_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="n">c</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)]]</span>

                <span class="k">if</span> <span class="n">new_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># this if is to treat the case</span>
                    <span class="c1"># where alpha==90 (but we still have a monoclinic sg</span>
                    <span class="n">new_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">]]</span>
                    <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_dic</span><span class="p">)):</span>
                        <span class="n">transf</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">sorted_dic</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;orig_index&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1">#if not C-setting</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># try all permutations of the axis</span>
                <span class="c1"># keep the ones with the non-90 angle=alpha</span>
                <span class="c1"># and b&lt;c</span>
                <span class="n">new_matrix</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">latt</span><span class="o">.</span><span class="n">matrix</span>
                    <span class="n">landang</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">m</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">m</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]]])</span><span class="o">.</span><span class="n">lengths_and_angles</span>
                    <span class="k">if</span> <span class="n">landang</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">90</span> <span class="ow">and</span> <span class="n">landang</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">landang</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">landang</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span>
                            <span class="p">[</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">m</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]]])</span><span class="o">.</span><span class="n">lengths_and_angles</span>
                        <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                        <span class="n">transf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">transf</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="n">transf</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">landang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">alpha</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">landang</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">180</span>
                        <span class="n">new_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="n">c</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)]]</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">landang</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">90</span> <span class="ow">and</span> <span class="n">landang</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">landang</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                        <span class="n">transf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">transf</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">transf</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">landang</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">alpha</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">landang</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">180</span>
                        <span class="n">new_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">),</span> <span class="n">c</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)]]</span>
                <span class="k">if</span> <span class="n">new_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># this if is to treat the case</span>
                    <span class="c1"># where alpha==90 (but we still have a monoclinic sg</span>
                    <span class="n">new_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">sorted_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">sorted_lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">],</span>
                                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sorted_lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span>
                    <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_dic</span><span class="p">)):</span>
                        <span class="n">transf</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">sorted_dic</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="s1">&#39;orig_index&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">international_monoclinic</span><span class="p">:</span>
                <span class="c1"># The above code makes alpha the non-right angle.</span>
                <span class="c1"># The following will convert to proper international convention</span>
                <span class="c1"># that beta is the non-right angle.</span>
                <span class="n">op</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">transf</span><span class="p">)</span>
                <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">new_matrix</span><span class="p">)</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">new_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">beta</span>
                <span class="k">if</span> <span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">90</span><span class="p">:</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                    <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">transf</span><span class="p">)</span>
                    <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">new_matrix</span><span class="p">)</span>

            <span class="n">latt</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">new_matrix</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">latt_type</span> <span class="o">==</span> <span class="s2">&quot;triclinic&quot;</span><span class="p">:</span>
            <span class="c1">#we use a LLL Minkowski-like reduction for the triclinic cells</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">get_reduced_structure</span><span class="p">(</span><span class="s2">&quot;LLL&quot;</span><span class="p">)</span>

            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">latt</span><span class="o">.</span><span class="n">lengths_and_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">180</span>
                                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">latt</span><span class="o">.</span><span class="n">lengths_and_angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">new_matrix</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">test_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="n">b</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">],</span>
                          <span class="p">[</span><span class="n">c</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span>
                           <span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span> <span class="o">/</span>
                           <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span>
                           <span class="n">c</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                         <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                         <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
                                         <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)]]</span>

            <span class="k">def</span> <span class="nf">is_all_acute_or_obtuse</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="n">recp_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Lattice</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">recp_angles</span> <span class="o">&lt;=</span> <span class="mi">90</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">recp_angles</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_all_acute_or_obtuse</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">):</span>
                <span class="n">transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">test_matrix</span>

            <span class="n">test_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="n">b</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span>
                            <span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span> <span class="o">/</span>
                            <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span>
                            <span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                           <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                           <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
                                           <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)]]</span>

            <span class="k">if</span> <span class="n">is_all_acute_or_obtuse</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">):</span>
                <span class="n">transf</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">test_matrix</span>

            <span class="n">test_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">],</span>
                           <span class="p">[</span><span class="n">c</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span>
                            <span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span> <span class="o">/</span>
                            <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span>
                            <span class="n">c</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                          <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                          <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
                                          <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)]]</span>

            <span class="k">if</span> <span class="n">is_all_acute_or_obtuse</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">):</span>
                <span class="n">transf</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">test_matrix</span>

            <span class="n">test_matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span>
                            <span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span> <span class="o">/</span>
                            <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span>
                            <span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                           <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                                           <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
                                           <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span> <span class="o">/</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)]]</span>
            <span class="k">if</span> <span class="n">is_all_acute_or_obtuse</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">):</span>
                <span class="n">transf</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">new_matrix</span> <span class="o">=</span> <span class="n">test_matrix</span>

            <span class="n">latt</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">new_matrix</span><span class="p">)</span>

        <span class="n">new_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">new_struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">latt</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">,</span> <span class="n">new_coords</span><span class="p">,</span>
                               <span class="n">site_properties</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">site_properties</span><span class="p">,</span>
                               <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_struct</span><span class="o">.</span><span class="n">get_sorted_structure</span><span class="p">()</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.get_kpoint_weights"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.get_kpoint_weights">[docs]</a>    <span class="k">def</span> <span class="nf">get_kpoint_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the weights for a list of kpoints.</span>

<span class="sd">        Args:</span>
<span class="sd">            kpoints (Sequence): Sequence of kpoints. np.arrays is fine. Note</span>
<span class="sd">                that the code does not check that the list of kpoints</span>
<span class="sd">                provided does not contain duplicates.</span>
<span class="sd">            atol (float): Tolerance for fractional coordinates comparisons.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of weights, in the SAME order as kpoints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kpoints</span><span class="p">)</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">nonzero</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">kpts</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonzero</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpts</span><span class="p">):</span>
                <span class="c1"># gamma centered</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">nonzero</span><span class="p">:</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nonzero</span><span class="p">)))</span>
                    <span class="n">mesh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">)))</span>
                <span class="n">shift</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Monk</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">0.5</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nonzero</span><span class="p">)))</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">)))</span>
                <span class="n">shift</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">mapping</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_ir_reciprocal_mesh</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mesh</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell</span><span class="p">,</span> <span class="n">is_shift</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_symprec</span><span class="p">)</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span> <span class="o">/</span> <span class="n">mesh</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mapped</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kpoints</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">pbc_diff</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
                    <span class="n">mapped</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">g</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mapped</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mapping</span><span class="p">)))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">v</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapped</span><span class="o">.</span><span class="n">values</span><span class="p">()])):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to find 1:1 corresponding between input &quot;</span>
                             <span class="s2">&quot;kpoints and irreducible grid!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">w</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">]</span></div>

<div class="viewcode-block" id="SpacegroupAnalyzer.is_laue"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupAnalyzer.is_laue">[docs]</a>    <span class="k">def</span> <span class="nf">is_laue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the point group of the structure</span>
<span class="sd">            has Laue symmetry (centrosymmetry)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">laue</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;-1&quot;</span><span class="p">,</span> <span class="s2">&quot;2/m&quot;</span><span class="p">,</span> <span class="s2">&quot;mmm&quot;</span><span class="p">,</span> <span class="s2">&quot;4/m&quot;</span><span class="p">,</span> <span class="s2">&quot;4/mmm&quot;</span><span class="p">,</span>
                <span class="s2">&quot;-3&quot;</span><span class="p">,</span> <span class="s2">&quot;-3m&quot;</span><span class="p">,</span> <span class="s2">&quot;6/m&quot;</span><span class="p">,</span> <span class="s2">&quot;6/mmm&quot;</span><span class="p">,</span> <span class="s2">&quot;m-3&quot;</span><span class="p">,</span> <span class="s2">&quot;m-3m&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_point_group_symbol</span><span class="p">())</span> <span class="ow">in</span> <span class="n">laue</span></div></div>


<div class="viewcode-block" id="PointGroupAnalyzer"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.PointGroupAnalyzer">[docs]</a><span class="k">class</span> <span class="nc">PointGroupAnalyzer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to analyze the point group of a molecule. The general outline of</span>
<span class="sd">    the algorithm is as follows:</span>

<span class="sd">    1. Center the molecule around its center of mass.</span>
<span class="sd">    2. Compute the inertia tensor and the eigenvalues and eigenvectors.</span>
<span class="sd">    3. Handle the symmetry detection based on eigenvalues.</span>

<span class="sd">        a. Linear molecules have one zero eigenvalue. Possible symmetry</span>
<span class="sd">           operations are C*v or D*v</span>
<span class="sd">        b. Asymetric top molecules have all different eigenvalues. The</span>
<span class="sd">           maximum rotational symmetry in such molecules is 2</span>
<span class="sd">        c. Symmetric top molecules have 1 unique eigenvalue, which gives a</span>
<span class="sd">           unique rotation axis.  All axial point groups are possible</span>
<span class="sd">           except the cubic groups (T &amp; O) and I.</span>
<span class="sd">        d. Spherical top molecules have all three eigenvalues equal. They</span>
<span class="sd">           have the rare T, O or I point groups.</span>

<span class="sd">    .. attribute:: sch_symbol</span>

<span class="sd">        Schoenflies symbol of the detected point group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inversion_op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">inversion</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">eigen_tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                 <span class="n">matrix_tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The default settings are usually sufficient.</span>

<span class="sd">        Args:</span>
<span class="sd">            mol (Molecule): Molecule to determine point group for.</span>
<span class="sd">            tolerance (float): Distance tolerance to consider sites as</span>
<span class="sd">                symmetrically equivalent. Defaults to 0.3 Angstrom.</span>
<span class="sd">            eigen_tolerance (float): Tolerance to compare eigen values of</span>
<span class="sd">                the inertia tensor. Defaults to 0.01.</span>
<span class="sd">            matrix_tol (float): Tolerance used to generate the full set of</span>
<span class="sd">                symmetry operations of the point group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">mol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">get_centered_molecule</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_tol</span> <span class="o">=</span> <span class="n">eigen_tolerance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat_tol</span> <span class="o">=</span> <span class="n">matrix_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_analyze</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;C1v&quot;</span><span class="p">,</span> <span class="s2">&quot;C1h&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;Cs&quot;</span>

    <span class="k">def</span> <span class="nf">_analyze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;Kh&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inertia_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">total_inertia</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">coords</span>
                <span class="n">wt</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="o">.</span><span class="n">weight</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">inertia_tensor</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wt</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
                                                  <span class="o">+</span> <span class="n">c</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]:</span>
                    <span class="n">inertia_tensor</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">wt</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">inertia_tensor</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="n">wt</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">total_inertia</span> <span class="o">+=</span> <span class="n">wt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

            <span class="c1"># Normalize the inertia tensor so that it does not scale with size</span>
            <span class="c1"># of the system.  This mitigates the problem of choosing a proper</span>
            <span class="c1"># comparison tolerance for the eigenvalues.</span>
            <span class="n">inertia_tensor</span> <span class="o">/=</span> <span class="n">total_inertia</span>
            <span class="n">eigvals</span><span class="p">,</span> <span class="n">eigvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">inertia_tensor</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">principal_axes</span> <span class="o">=</span> <span class="n">eigvecs</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eigvals</span> <span class="o">=</span> <span class="n">eigvals</span>
            <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span> <span class="o">=</span> <span class="n">eigvals</span>
            <span class="n">eig_zero</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v1</span> <span class="o">*</span> <span class="n">v2</span> <span class="o">*</span> <span class="n">v3</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_tol</span> <span class="o">**</span> <span class="mi">3</span>
            <span class="n">eig_all_same</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v1</span> <span class="o">-</span> <span class="n">v2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_tol</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span>
                <span class="n">v1</span> <span class="o">-</span> <span class="n">v3</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_tol</span>
            <span class="n">eig_all_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v1</span> <span class="o">-</span> <span class="n">v2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_tol</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span>
                <span class="n">v1</span> <span class="o">-</span> <span class="n">v3</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_tol</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v2</span> <span class="o">-</span> <span class="n">v3</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_tol</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span> <span class="o">=</span> <span class="p">[</span><span class="n">SymmOp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">))]</span>
            <span class="k">if</span> <span class="n">eig_zero</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Linear molecule detected&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_proc_linear</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">eig_all_same</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Spherical top molecule detected&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_proc_sph_top</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">eig_all_diff</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Asymmetric top molecule detected&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_proc_asym_top</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Symmetric top molecule detected&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_proc_sym_top</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_proc_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">PointGroupAnalyzer</span><span class="o">.</span><span class="n">inversion_op</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;D*h&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PointGroupAnalyzer</span><span class="o">.</span><span class="n">inversion_op</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;C*v&quot;</span>

    <span class="k">def</span> <span class="nf">_proc_asym_top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles assymetric top molecules, which cannot contain rotational</span>
<span class="sd">        symmetry larger than 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_R2_axes_asym</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No rotation symmetries detected.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proc_no_rot_sym</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Dihedral group detected.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proc_dihedral</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Cyclic group detected.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proc_cyclic</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_proc_sym_top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles symetric top molecules which has one unique eigenvalue whose</span>
<span class="sd">        corresponding principal axis is a unique rotational axis.  More complex</span>
<span class="sd">        handling required to look for R2 axes perpendicular to this unique</span>
<span class="sd">        axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigvals</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_tol</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigvals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigvals</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_tol</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Eigenvalues = </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigvals</span><span class="p">)</span>
        <span class="n">unique_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_axes</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_rot_sym</span><span class="p">(</span><span class="n">unique_axis</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Rotation symmetries = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_perpendicular_r2_axis</span><span class="p">(</span><span class="n">unique_axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proc_dihedral</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proc_cyclic</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proc_no_rot_sym</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_proc_no_rot_sym</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles molecules with no rotational symmetry. Only possible point</span>
<span class="sd">        groups are C1, Cs and Ci.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;C1&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">PointGroupAnalyzer</span><span class="o">.</span><span class="n">inversion_op</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;Ci&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PointGroupAnalyzer</span><span class="o">.</span><span class="n">inversion_op</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_axes</span><span class="p">:</span>
                <span class="n">mirror_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_mirror</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">mirror_type</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;Cs&quot;</span>
                    <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_proc_cyclic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles cyclic group molecules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">main_axis</span><span class="p">,</span> <span class="n">rot</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;C</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
        <span class="n">mirror_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_mirror</span><span class="p">(</span><span class="n">main_axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mirror_type</span> <span class="o">==</span> <span class="s2">&quot;h&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">+=</span> <span class="s2">&quot;h&quot;</span>
        <span class="k">elif</span> <span class="n">mirror_type</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">+=</span> <span class="s2">&quot;v&quot;</span>
        <span class="k">elif</span> <span class="n">mirror_type</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">rotoreflection</span><span class="p">(</span><span class="n">main_axis</span><span class="p">,</span>
                                                      <span class="n">angle</span><span class="o">=</span><span class="mi">180</span> <span class="o">/</span> <span class="n">rot</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;S</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">rot</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_proc_dihedral</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles dihedral group molecules, i.e those with intersecting R2 axes</span>
<span class="sd">        and a main axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">main_axis</span><span class="p">,</span> <span class="n">rot</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;D</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
        <span class="n">mirror_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_mirror</span><span class="p">(</span><span class="n">main_axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mirror_type</span> <span class="o">==</span> <span class="s2">&quot;h&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">+=</span> <span class="s2">&quot;h&quot;</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">mirror_type</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">+=</span> <span class="s2">&quot;d&quot;</span>

    <span class="k">def</span> <span class="nf">_check_R2_axes_asym</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test for 2-fold rotation along the principal axes. Used to handle</span>
<span class="sd">        asymetric top molecules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">principal_axes</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_axis_angle_and_translation</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">180</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_find_mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Looks for mirror symmetry of specified type about axis.  Possible</span>
<span class="sd">        types are &quot;h&quot; or &quot;vd&quot;.  Horizontal (h) mirrors are perpendicular to</span>
<span class="sd">        the axis while vertical (v) or diagonal (d) mirrors are parallel.  v</span>
<span class="sd">        mirrors has atoms lying on the mirror plane while d mirrors do</span>
<span class="sd">        not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mirror_type</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># First test whether the axis itself is the normal to a mirror plane.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">reflection</span><span class="p">(</span><span class="n">axis</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SymmOp</span><span class="o">.</span><span class="n">reflection</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
            <span class="n">mirror_type</span> <span class="o">=</span> <span class="s2">&quot;h&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Iterate through all pairs of atoms to find mirror</span>
            <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">species_and_occu</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">:</span>
                    <span class="n">normal</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">coords</span> <span class="o">-</span> <span class="n">s2</span><span class="o">.</span><span class="n">coords</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                        <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">reflection</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">mirror_type</span> <span class="o">=</span> <span class="s2">&quot;d&quot;</span>
                                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">axis</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                                            <span class="n">mirror_type</span> <span class="o">=</span> <span class="s2">&quot;v&quot;</span>
                                            <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">mirror_type</span> <span class="o">=</span> <span class="s2">&quot;v&quot;</span>
                            <span class="k">break</span>

        <span class="k">return</span> <span class="n">mirror_type</span>

    <span class="k">def</span> <span class="nf">_get_smallest_set_not_on_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the smallest list of atoms with the same species and</span>
<span class="sd">        distance from origin AND does not lie on the specified axis.  This</span>
<span class="sd">        maximal set limits the possible rotational symmetry operations,</span>
<span class="sd">        since atoms lying on a test axis is irrelevant in testing rotational</span>
<span class="sd">        symmetryOperations.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">not_on_axis</span><span class="p">(</span><span class="n">site</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span>

        <span class="n">valid_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">origin_site</span><span class="p">,</span> <span class="n">dist_el_sites</span> <span class="o">=</span> <span class="n">cluster_sites</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">test_set</span> <span class="ow">in</span> <span class="n">dist_el_sites</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">valid_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">not_on_axis</span><span class="p">,</span> <span class="n">test_set</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_set</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">valid_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid_set</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">valid_sets</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_check_rot_sym</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the rotational symmetry about supplied axis.  Used only for</span>
<span class="sd">        symmetric top molecules which has possible rotational symmetry</span>
<span class="sd">        operations &gt; 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_smallest_set_not_on_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">max_sym</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_sym</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">max_sym</span> <span class="o">%</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_axis_angle_and_translation</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="mi">360</span> <span class="o">/</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">rotvalid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rotvalid</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">axis</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_check_perpendicular_r2_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks for R2 axes perpendicular to unique axis.  For handling</span>
<span class="sd">        symmetric top molecules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_smallest_set_not_on_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">min_set</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">test_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">coords</span> <span class="o">-</span> <span class="n">s2</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">test_axis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_axis_angle_and_translation</span><span class="p">(</span><span class="n">test_axis</span><span class="p">,</span> <span class="mi">180</span><span class="p">)</span>
                <span class="n">r2present</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">r2present</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">test_axis</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                    <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_proc_sph_top</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles Sperhical Top Molecules, which belongs to the T, O or I point</span>
<span class="sd">        groups.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_find_spherical_axes</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Accidental speherical top!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proc_sym_top</span><span class="p">()</span>
        <span class="n">main_axis</span><span class="p">,</span> <span class="n">rot</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">rot</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Accidental speherical top!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proc_sym_top</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">rot</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">mirror_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_mirror</span><span class="p">(</span><span class="n">main_axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mirror_type</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">PointGroupAnalyzer</span><span class="o">.</span><span class="n">inversion_op</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PointGroupAnalyzer</span><span class="o">.</span><span class="n">inversion_op</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;Th&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;Td&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;T&quot;</span>
        <span class="k">elif</span> <span class="n">rot</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">PointGroupAnalyzer</span><span class="o">.</span><span class="n">inversion_op</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PointGroupAnalyzer</span><span class="o">.</span><span class="n">inversion_op</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;Oh&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;O&quot;</span>
        <span class="k">elif</span> <span class="n">rot</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">PointGroupAnalyzer</span><span class="o">.</span><span class="n">inversion_op</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PointGroupAnalyzer</span><span class="o">.</span><span class="n">inversion_op</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;Ih&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="s2">&quot;I&quot;</span>

    <span class="k">def</span> <span class="nf">_find_spherical_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Looks for R5, R4, R3 and R2 axes in spherical top molecules.  Point</span>
<span class="sd">        group T molecules have only one unique 3-fold and one unique 2-fold</span>
<span class="sd">        axis. O molecules have one unique 4, 3 and 2-fold axes. I molecules</span>
<span class="sd">        have a unique 5-fold axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rot_present</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">origin_site</span><span class="p">,</span> <span class="n">dist_el_sites</span> <span class="o">=</span> <span class="n">cluster_sites</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
        <span class="n">test_set</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dist_el_sites</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">coords</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">test_set</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">cc2</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">([</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">],</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">rot_present</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">test_axis</span> <span class="o">=</span> <span class="n">cc1</span> <span class="o">+</span> <span class="n">cc2</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">test_axis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                        <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_axis_angle_and_translation</span><span class="p">(</span><span class="n">test_axis</span><span class="p">,</span>
                                                                    <span class="mi">180</span><span class="p">)</span>
                        <span class="n">rot_present</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">rot_present</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">test_axis</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

            <span class="n">test_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c3</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">test_axis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">rot_present</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
                        <span class="n">op</span> <span class="o">=</span> <span class="n">SymmOp</span><span class="o">.</span><span class="n">from_axis_angle_and_translation</span><span class="p">(</span>
                            <span class="n">test_axis</span><span class="p">,</span> <span class="mi">360</span> <span class="o">/</span> <span class="n">r</span><span class="p">)</span>
                        <span class="n">rot_present</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">rot_present</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">rot_sym</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">test_axis</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
                            <span class="k">break</span>
            <span class="k">if</span> <span class="n">rot_present</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">rot_present</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span>
                        <span class="n">rot_present</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="ow">or</span> <span class="n">rot_present</span><span class="p">[</span><span class="mi">5</span><span class="p">]):</span>
                <span class="k">break</span>

<div class="viewcode-block" id="PointGroupAnalyzer.get_pointgroup"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.PointGroupAnalyzer.get_pointgroup">[docs]</a>    <span class="k">def</span> <span class="nf">get_pointgroup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a PointGroup object for the molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PointGroupOperations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">mat_tol</span><span class="p">)</span></div>

<div class="viewcode-block" id="PointGroupAnalyzer.get_symmetry_operations"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.PointGroupAnalyzer.get_symmetry_operations">[docs]</a>    <span class="k">def</span> <span class="nf">get_symmetry_operations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return symmetry operations as a list of SymmOp objects.</span>
<span class="sd">        Returns Cartesian coord symmops.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ([SymmOp]): List of symmetry operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">generate_full_symmops</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span></div>

<div class="viewcode-block" id="PointGroupAnalyzer.is_valid_op"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.PointGroupAnalyzer.is_valid_op">[docs]</a>    <span class="k">def</span> <span class="nf">is_valid_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symmop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if a particular symmetry operation is a valid symmetry operation</span>
<span class="sd">        for a molecule, i.e., the operation maps all atoms to another</span>
<span class="sd">        equivalent atom.</span>

<span class="sd">        Args:</span>
<span class="sd">            symmop (SymmOp): Symmetry operation to test.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (bool): Whether SymmOp is valid for Molecule.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span><span class="o">.</span><span class="n">cart_coords</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="n">symmop</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">find_in_coord_list</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">species_and_occu</span>
                    <span class="o">==</span> <span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="nf">_get_eq_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the dictionary for mapping equivalent atoms onto each other.</span>

<span class="sd">        Args:</span>
<span class="sd">            None</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: The returned dictionary has two possible keys:</span>

<span class="sd">            ``eq_sets``:</span>
<span class="sd">            A dictionary of indices mapping to sets of indices,</span>
<span class="sd">            each key maps to indices of all equivalent atoms.</span>
<span class="sd">            The keys are guaranteed to be not equivalent.</span>

<span class="sd">            ``sym_ops``:</span>
<span class="sd">            Twofold nested dictionary.</span>
<span class="sd">            ``operations[i][j]`` gives the symmetry operation</span>
<span class="sd">            that maps atom ``i`` unto ``j``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">UNIT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">eq_sets</span><span class="p">,</span> <span class="n">operations</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">),</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="n">symm_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span>
                    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">generate_full_symmops</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symmops</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)]</span>

        <span class="k">def</span> <span class="nf">get_clustered_indices</span><span class="p">():</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">cluster_sites</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">,</span>
                                    <span class="n">give_only_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">get_clustered_indices</span><span class="p">():</span>
            <span class="n">sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reference</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">sites</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">symm_ops</span><span class="p">:</span>
                    <span class="n">rotated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">sites</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">matched_indices</span> <span class="o">=</span> <span class="n">find_in_coord_list</span><span class="p">(</span><span class="n">rotated</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">tol</span><span class="p">)</span>
                    <span class="n">matched_indices</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">index</span><span class="p">))[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">matched_indices</span><span class="p">}</span>
                    <span class="n">eq_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|=</span> <span class="n">matched_indices</span>

                    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">:</span>
                        <span class="n">operations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">:</span> <span class="n">op</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span> <span class="k">else</span> <span class="n">UNIT</span>
                                         <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">matched_indices</span><span class="p">}</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">matched_indices</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                <span class="n">operations</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span> <span class="k">else</span> <span class="n">UNIT</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">matched_indices</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">:</span>
                            <span class="n">operations</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">op</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span> <span class="k">else</span> <span class="n">UNIT</span><span class="p">}</span>
                        <span class="k">elif</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                            <span class="n">operations</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span> <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">i</span> <span class="k">else</span> <span class="n">UNIT</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;eq_sets&#39;</span><span class="p">:</span> <span class="n">eq_sets</span><span class="p">,</span>
                <span class="s1">&#39;sym_ops&#39;</span><span class="p">:</span> <span class="n">operations</span><span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_combine_eq_sets</span><span class="p">(</span><span class="n">eq_sets</span><span class="p">,</span> <span class="n">operations</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combines the dicts of _get_equivalent_atom_dicts into one</span>

<span class="sd">        Args:</span>
<span class="sd">            eq_sets (dict)</span>
<span class="sd">            operations (dict)</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: The returned dictionary has two possible keys:</span>

<span class="sd">            ``eq_sets``:</span>
<span class="sd">            A dictionary of indices mapping to sets of indices,</span>
<span class="sd">            each key maps to indices of all equivalent atoms.</span>
<span class="sd">            The keys are guaranteed to be not equivalent.</span>

<span class="sd">            ``sym_ops``:</span>
<span class="sd">            Twofold nested dictionary.</span>
<span class="sd">            ``operations[i][j]`` gives the symmetry operation</span>
<span class="sd">            that maps atom ``i`` unto ``j``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">UNIT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">all_equivalent_atoms_of_i</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">eq_sets</span><span class="p">,</span> <span class="n">ops</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;WORKS INPLACE on operations</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
            <span class="n">tmp_eq_sets</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">:</span> <span class="p">(</span><span class="n">eq_sets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">visited</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">eq_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]}</span>

            <span class="k">while</span> <span class="n">tmp_eq_sets</span><span class="p">:</span>
                <span class="n">new_tmp_eq_sets</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tmp_eq_sets</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tmp_eq_sets</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">new_tmp_eq_sets</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">eq_sets</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">visited</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                            <span class="n">ops</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">ops</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                                         <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">i</span> <span class="k">else</span> <span class="n">UNIT</span><span class="p">)</span>
                        <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                <span class="n">tmp_eq_sets</span> <span class="o">=</span> <span class="n">new_tmp_eq_sets</span>
            <span class="k">return</span> <span class="n">visited</span><span class="p">,</span> <span class="n">ops</span>

        <span class="n">eq_sets</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">eq_sets</span><span class="p">)</span>
        <span class="n">new_eq_sets</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">operations</span><span class="p">)</span>
        <span class="n">to_be_deleted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">eq_sets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_be_deleted</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">visited</span><span class="p">,</span> <span class="n">ops</span> <span class="o">=</span> <span class="n">all_equivalent_atoms_of_i</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">eq_sets</span><span class="p">,</span> <span class="n">ops</span><span class="p">)</span>
            <span class="n">to_be_deleted</span> <span class="o">|=</span> <span class="n">visited</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">to_be_deleted</span><span class="p">:</span>
            <span class="n">eq_sets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;eq_sets&#39;</span><span class="p">:</span> <span class="n">eq_sets</span><span class="p">,</span>
                <span class="s1">&#39;sym_ops&#39;</span><span class="p">:</span> <span class="n">ops</span><span class="p">}</span>

<div class="viewcode-block" id="PointGroupAnalyzer.get_equivalent_atoms"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.PointGroupAnalyzer.get_equivalent_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">get_equivalent_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns sets of equivalent atoms with symmetry operations</span>

<span class="sd">        Args:</span>
<span class="sd">            None</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: The returned dictionary has two possible keys:</span>

<span class="sd">            ``eq_sets``:</span>
<span class="sd">            A dictionary of indices mapping to sets of indices,</span>
<span class="sd">            each key maps to indices of all equivalent atoms.</span>
<span class="sd">            The keys are guaranteed to be not equivalent.</span>

<span class="sd">            ``sym_ops``:</span>
<span class="sd">            Twofold nested dictionary.</span>
<span class="sd">            ``operations[i][j]`` gives the symmetry operation</span>
<span class="sd">            that maps atom ``i`` unto ``j``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_eq_sets</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine_eq_sets</span><span class="p">(</span><span class="n">eq</span><span class="p">[</span><span class="s1">&#39;eq_sets&#39;</span><span class="p">],</span>
                                     <span class="n">eq</span><span class="p">[</span><span class="s1">&#39;sym_ops&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="PointGroupAnalyzer.symmetrize_molecule"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.PointGroupAnalyzer.symmetrize_molecule">[docs]</a>    <span class="k">def</span> <span class="nf">symmetrize_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a symmetrized molecule</span>

<span class="sd">        The equivalent atoms obtained via</span>
<span class="sd">        :meth:`~pymatgen.symmetry.analyzer.PointGroupAnalyzer.get_equivalent_atoms`</span>
<span class="sd">        are rotated, mirrored... unto one position.</span>
<span class="sd">        Then the average position is calculated.</span>
<span class="sd">        The average position is rotated, mirrored... back with the inverse</span>
<span class="sd">        of the previous symmetry operations, which gives the</span>
<span class="sd">        symmetrized molecule</span>

<span class="sd">        Args:</span>
<span class="sd">            None</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: The returned dictionary has three possible keys:</span>

<span class="sd">            ``sym_mol``:</span>
<span class="sd">            A symmetrized molecule instance.</span>

<span class="sd">            ``eq_sets``:</span>
<span class="sd">            A dictionary of indices mapping to sets of indices,</span>
<span class="sd">            each key maps to indices of all equivalent atoms.</span>
<span class="sd">            The keys are guaranteed to be not equivalent.</span>

<span class="sd">            ``sym_ops``:</span>
<span class="sd">            Twofold nested dictionary.</span>
<span class="sd">            ``operations[i][j]`` gives the symmetry operation</span>
<span class="sd">            that maps atom ``i`` unto ``j``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_equivalent_atoms</span><span class="p">()</span>
        <span class="n">eq_sets</span><span class="p">,</span> <span class="n">ops</span> <span class="o">=</span> <span class="n">eq</span><span class="p">[</span><span class="s1">&#39;eq_sets&#39;</span><span class="p">],</span> <span class="n">eq</span><span class="p">[</span><span class="s1">&#39;sym_ops&#39;</span><span class="p">]</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span><span class="o">.</span><span class="n">cart_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eq_indices</span> <span class="ow">in</span> <span class="n">eq_sets</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">eq_indices</span><span class="p">:</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">eq_indices</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">eq_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">molecule</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">species</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">centered_mol</span><span class="o">.</span><span class="n">species</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;sym_mol&#39;</span><span class="p">:</span> <span class="n">molecule</span><span class="p">,</span>
                <span class="s1">&#39;eq_sets&#39;</span><span class="p">:</span> <span class="n">eq_sets</span><span class="p">,</span>
                <span class="s1">&#39;sym_ops&#39;</span><span class="p">:</span> <span class="n">ops</span><span class="p">}</span></div></div>


<div class="viewcode-block" id="iterative_symmetrize"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.iterative_symmetrize">[docs]</a><span class="k">def</span> <span class="nf">iterative_symmetrize</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">max_n</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a symmetrized molecule</span>

<span class="sd">    The equivalent atoms obtained via</span>
<span class="sd">    :meth:`~pymatgen.symmetry.analyzer.PointGroupAnalyzer.get_equivalent_atoms`</span>
<span class="sd">    are rotated, mirrored... unto one position.</span>
<span class="sd">    Then the average position is calculated.</span>
<span class="sd">    The average position is rotated, mirrored... back with the inverse</span>
<span class="sd">    of the previous symmetry operations, which gives the</span>
<span class="sd">    symmetrized molecule</span>

<span class="sd">    Args:</span>
<span class="sd">        mol (Molecule): A pymatgen Molecule instance.</span>
<span class="sd">        max_n (int): Maximum number of iterations.</span>
<span class="sd">        tolerance (float): Tolerance for detecting symmetry.</span>
<span class="sd">            Gets passed as Argument into</span>
<span class="sd">            :class:`~pymatgen.analyzer.symmetry.PointGroupAnalyzer`.</span>
<span class="sd">        epsilon (float): If the elementwise absolute difference of two</span>
<span class="sd">            subsequently symmetrized structures is smaller epsilon,</span>
<span class="sd">            the iteration stops before ``max_n`` is reached.</span>


<span class="sd">    Returns:</span>
<span class="sd">        dict: The returned dictionary has three possible keys:</span>

<span class="sd">        ``sym_mol``:</span>
<span class="sd">        A symmetrized molecule instance.</span>

<span class="sd">        ``eq_sets``:</span>
<span class="sd">        A dictionary of indices mapping to sets of indices,</span>
<span class="sd">        each key maps to indices of all equivalent atoms.</span>
<span class="sd">        The keys are guaranteed to be not equivalent.</span>

<span class="sd">        ``sym_ops``:</span>
<span class="sd">        Twofold nested dictionary.</span>
<span class="sd">        ``operations[i][j]`` gives the symmetry operation</span>
<span class="sd">        that maps atom ``i`` unto ``j``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">mol</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">finished</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">finished</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">max_n</span><span class="p">:</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">new</span>
        <span class="n">PA</span> <span class="o">=</span> <span class="n">PointGroupAnalyzer</span><span class="p">(</span><span class="n">previous</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">PA</span><span class="o">.</span><span class="n">symmetrize_molecule</span><span class="p">()</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">eq</span><span class="p">[</span><span class="s1">&#39;sym_mol&#39;</span><span class="p">]</span>
        <span class="n">finished</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">,</span> <span class="n">previous</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">,</span>
                               <span class="n">atol</span><span class="o">=</span><span class="n">epsilon</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">eq</span></div>


<div class="viewcode-block" id="cluster_sites"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.cluster_sites">[docs]</a><span class="k">def</span> <span class="nf">cluster_sites</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">give_only_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cluster sites based on distance and species type.</span>

<span class="sd">    Args:</span>
<span class="sd">        mol (Molecule): Molecule **with origin at center of mass**.</span>
<span class="sd">        tol (float): Tolerance to use.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (origin_site, clustered_sites): origin_site is a site at the center</span>
<span class="sd">        of mass (None if there are no origin atoms). clustered_sites is a</span>
<span class="sd">        dict of {(avg_dist, species_and_occu): [list of sites]}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Cluster works for dim &gt; 2 data. We just add a dummy 0 for second</span>
    <span class="c1"># coordinate.</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">coords</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">mol</span><span class="p">]</span>
    <span class="kn">import</span> <span class="nn">scipy.cluster</span> <span class="k">as</span> <span class="nn">spcluster</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">spcluster</span><span class="o">.</span><span class="n">hierarchy</span><span class="o">.</span><span class="n">fclusterdata</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">)</span>
    <span class="n">clustered_dists</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mol</span><span class="p">):</span>
        <span class="n">clustered_dists</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">avg_dist</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">clustered_dists</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">clustered_sites</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">origin_site</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mol</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">avg_dist</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">give_only_index</span><span class="p">:</span>
                <span class="n">origin_site</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">origin_site</span> <span class="o">=</span> <span class="n">site</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">give_only_index</span><span class="p">:</span>
                <span class="n">clustered_sites</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">avg_dist</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">clustered_sites</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">avg_dist</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">origin_site</span><span class="p">,</span> <span class="n">clustered_sites</span></div>


<div class="viewcode-block" id="generate_full_symmops"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.generate_full_symmops">[docs]</a><span class="k">def</span> <span class="nf">generate_full_symmops</span><span class="p">(</span><span class="n">symmops</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursive algorithm to permute through all possible combinations of the</span>
<span class="sd">    initially supplied symmetry operations to arrive at a complete set of</span>
<span class="sd">    operations mapping a single atom to all other equivalent atoms in the</span>
<span class="sd">    point group.  This assumes that the initial number already uniquely</span>
<span class="sd">    identifies all operations.</span>

<span class="sd">    Args:</span>
<span class="sd">        symmops ([SymmOp]): Initial set of symmetry operations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Full set of symmetry operations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Uses an algorithm described in:</span>
    <span class="c1"># Gregory Butler. Fundamental Algorithms for Permutation Groups.</span>
    <span class="c1"># Lecture Notes in Computer Science (Book 559). Springer, 1991. page 15</span>
    <span class="n">UNIT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">generators</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">affine_matrix</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">symmops</span>
                  <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">affine_matrix</span><span class="p">,</span> <span class="n">UNIT</span><span class="p">)]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">generators</span><span class="p">:</span>
        <span class="c1"># C1 symmetry breaks assumptions in the algorithm afterwards</span>
        <span class="k">return</span> <span class="n">symmops</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">full</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">generators</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">full</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">generators</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">full</span> <span class="o">-</span> <span class="n">op</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                    <span class="n">full</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">full</span> <span class="o">-</span> <span class="n">UNIT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">full</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">UNIT</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">SymmOp</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">full</span><span class="p">]</span></div>


<div class="viewcode-block" id="SpacegroupOperations"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupOperations">[docs]</a><span class="k">class</span> <span class="nc">SpacegroupOperations</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a space group, which is a collection of symmetry operations.</span>

<span class="sd">    Args:</span>
<span class="sd">        int_symbol (str): International symbol of the spacegroup.</span>
<span class="sd">        int_number (int): International number of the spacegroup.</span>
<span class="sd">        symmops ([SymmOp]): Symmetry operations associated with the</span>
<span class="sd">            spacegroup.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">int_symbol</span><span class="p">,</span> <span class="n">int_number</span><span class="p">,</span> <span class="n">symmops</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">int_symbol</span> <span class="o">=</span> <span class="n">int_symbol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">int_number</span> <span class="o">=</span> <span class="n">int_number</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SpacegroupOperations</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">symmops</span><span class="p">)</span>

<div class="viewcode-block" id="SpacegroupOperations.are_symmetrically_equivalent"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.SpacegroupOperations.are_symmetrically_equivalent">[docs]</a>    <span class="k">def</span> <span class="nf">are_symmetrically_equivalent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sites1</span><span class="p">,</span> <span class="n">sites2</span><span class="p">,</span> <span class="n">symm_prec</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given two sets of PeriodicSites, test if they are actually</span>
<span class="sd">        symmetrically equivalent under this space group.  Useful, for example,</span>
<span class="sd">        if you want to test if selecting atoms 1 and 2 out of a set of 4 atoms</span>
<span class="sd">        are symmetrically the same as selecting atoms 3 and 4, etc.</span>

<span class="sd">        One use is in PartialRemoveSpecie transformation to return only</span>
<span class="sd">        symmetrically distinct arrangements of atoms.</span>

<span class="sd">        Args:</span>
<span class="sd">            sites1 ([Site]): 1st set of sites</span>
<span class="sd">            sites2 ([Site]): 2nd set of sites</span>
<span class="sd">            symm_prec (float): Tolerance in atomic distance to test if atoms</span>
<span class="sd">                are symmetrically similar.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (bool): Whether the two sets of sites are symmetrically</span>
<span class="sd">            equivalent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">in_sites</span><span class="p">(</span><span class="n">site</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">test_site</span> <span class="ow">in</span> <span class="n">sites1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">test_site</span><span class="o">.</span><span class="n">is_periodic_image</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">symm_prec</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">newsites2</span> <span class="o">=</span> <span class="p">[</span><span class="n">PeriodicSite</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">,</span>
                                      <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">),</span>
                                      <span class="n">site</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">newsites2</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">in_sites</span><span class="p">(</span><span class="n">site</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">) spacegroup&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">int_symbol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_number</span><span class="p">)</span></div>


<div class="viewcode-block" id="PointGroupOperations"><a class="viewcode-back" href="../../../pymatgen.symmetry.analyzer.html#pymatgen.symmetry.analyzer.PointGroupOperations">[docs]</a><span class="k">class</span> <span class="nc">PointGroupOperations</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a point group, which is essentially a sequence of symmetry</span>
<span class="sd">    operations.</span>

<span class="sd">    Args:</span>
<span class="sd">        sch_symbol (str): Schoenflies symbol of the point group.</span>
<span class="sd">        operations ([SymmOp]): Initial set of symmetry operations. It is</span>
<span class="sd">            sufficient to provide only just enough operations to generate</span>
<span class="sd">            the full set of symmetries.</span>
<span class="sd">        tol (float): Tolerance to generate the full set of symmetry</span>
<span class="sd">            operations.</span>

<span class="sd">    .. attribute:: sch_symbol</span>

<span class="sd">        Schoenflies symbol of the point group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sch_symbol</span><span class="p">,</span> <span class="n">operations</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span> <span class="o">=</span> <span class="n">sch_symbol</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PointGroupOperations</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">generate_full_symmops</span><span class="p">(</span><span class="n">operations</span><span class="p">,</span> <span class="n">tol</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sch_symbol</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pymatgen 2018.9.12 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../pymatgen.html" >pymatgen</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2011, Pymatgen Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.0.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>