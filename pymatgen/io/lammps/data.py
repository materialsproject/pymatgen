# coding: utf-8
# Copyright (c) Pymatgen Development Team.
# Distributed under the terms of the MIT License.

from __future__ import division, print_function, unicode_literals, \
    absolute_import

import itertools
import warnings
import re
import ast

import numpy as np
from monty.json import MSONable
from ruamel.yaml import YAML

from pymatgen.util.io_utils import clean_lines
from pymatgen.core.structure import SiteCollection
from pymatgen import Molecule, Element

__author__ = 'Kiran Mathew'
__email__ = "kmathew@lbl.gov"
__credits__ = 'Brandon Wood'


SECTION_KEYWORDS = {"atom": ["Atoms", "Velocities", "Masses",
                             "Ellipsoids", "Lines", "Triangles", "Bodies"],
                    "molecule": ["Bonds", "Angles", "Dihedrals", "Impropers"],
                    "ff": ["Pair Coeffs", "PairIJ Coeffs", "Bond Coeffs",
                           "Angle Coeffs", "Dihedral Coeffs",
                           "Improper Coeffs"],
                    "class2": ["BondBond Coeffs", "BondAngle Coeffs",
                               "MiddleBondTorsion Coeffs",
                               "EndBondTorsion Coeffs", "AngleTorsion Coeffs",
                               "AngleAngleTorsion Coeffs",
                               "BondBond13 Coeffs", "AngleAngle Coeffs"]}

ATOMS_LINE_FORMAT = {"angle": ["molecule-ID", "type", "x", "y", "z"],
                     "atomic": ["type", "x", "y", "z"],
                     "bond": ["molecule-ID", "type", "x", "y", "z"],
                     "charge": ["type", "q", "x", "y", "z"],
                     "full": ["molecule-ID", "type", "q", "x", "y", "z"],
                     "molecular": ["molecule-ID", "type", "x", "y", "z"]}

ATOMS_FLOATS = ["q", "x", "y", "z"]


class LammpsData(MSONable):

    def __init__(self, masses, atoms, box_bounds, box_tilt=None,
                 velocities=None, force_field=None, topology=None,
                 atom_style="full"):
        if force_field:
            force_field = {k: v for k, v in force_field.items()
                           if k in SECTION_KEYWORDS["ff"]}
        if topology:
            topology = {k: v for k, v in topology.items()
                        if k in SECTION_KEYWORDS["molecule"]}
        self.masses = masses
        self.atoms = atoms
        self.box_bounds = box_bounds
        self.box_tilt = box_tilt
        self.velocities = velocities
        self.force_field = force_field
        self.topology = topology
        self.atom_style = atom_style

    def __str__(self):
        return self.get_string()

    def get_string(self, significant_figures=6):
        template = """Generated by pymatgen.io.lammps.data.LammpsData

{stats}

{box}

{masses}

{ff_sections}

{atoms}

{velocities}

{topo_sections}
        """

        contents = {}

        float_ph = "{:.%df}" % significant_figures \
            if significant_figures else "{}"

        def _pretty_section(title, str_mat):
            lens = [max(map(len, col)) for col in zip(*str_mat)]
            fmt = "  ".join("{:>%d}" % x for x in lens)
            rows = [title, ""] + [fmt.format(*row) for row in str_mat]
            sec = "\n".join(rows)
            return sec

        counts = {"atoms": len(self.atoms)}
        types = {"atom": len(self.masses)}

        # box
        box_lines = []
        for bound, d in zip(self.box_bounds, "xyz"):
            fillers = bound + [d] * 2
            bound_format = " ".join([float_ph] * 2 + ["{}lo {}hi"])
            box_lines.append(bound_format.format(*fillers))
        if self.box_tilt:
            tilt_format = " ".join([float_ph] * 3 + ["xy xz yz"])
            box_lines.append(tilt_format.format(*self.box_tilt))
        contents["box"] = "\n".join(box_lines)

        # masses
        masses_mat = [["%d" % m["id"], "{:.4f}".format(m["mass"])]
                      for m in self.masses]
        contents["masses"] = _pretty_section("Masses", masses_mat)

        # ff_sections
        contents["ff_sections"] = ""
        if self.force_field:
            ff_parts = []
            for kw in self.force_field.keys():
                if kw is "PairIJ Coeffs":
                    ff_mat = [[str(i) for i in
                               [d["id1"], d["id2"]] + d["coeffs"]]
                              for d in self.force_field[kw]]
                else:
                    ff_mat = [[str(i) for i in [d["id"]] + d["coeffs"]]
                              for d in self.force_field[kw]]
                if not kw.startswith("Pair"):
                    types[kw.lower()[:-7]] = len(ff_mat)
                ff_parts.append(_pretty_section(kw, ff_mat))
            contents["ff_sections"] = "\n\n".join(ff_parts)

        # atoms
        atom_format = ["id"] + ATOMS_LINE_FORMAT[self.atom_style]
        if "nx" in self.atoms[0].keys():
            atom_format.extend(["nx", "ny", "nz"])
        map_str = lambda t: float_ph if t in ATOMS_FLOATS else "{}"
        atoms_mat = []
        for a in self.atoms:
            atoms_mat.append([map_str(k).format(a[k]) for k in atom_format])
        contents["atoms"] = _pretty_section("Atoms", atoms_mat)

        # velocities
        contents["velocities"] = ""
        if self.velocities:
            velocities_mat = []
            for v in self.velocities:
                vs = [float_ph.format(i) for i in v["velocity"]]
                velocities_mat.append(["%d" % v["id"]] + vs)
            contents["velocities"] = _pretty_section("Velocities",
                                                     velocities_mat)

        # topo_sections
        contents["topo_sections"] = ""
        if self.topology:
            topo_parts = []
            for kw in self.topology.keys():
                skw = kw.lower()[:-1]
                topo_mat = [["%d" % v for v in [d["id"], d["type"]] + d[skw]]
                            for d in self.topology[kw]]
                counts[kw.lower()] = len(topo_mat)
                topo_parts.append(_pretty_section(kw, topo_mat))
            contents["topo_sections"] = "\n\n".join(topo_parts)

        # stats
        all_stats = list(counts.values()) + list(types.values())
        line_fmt = "{:>%d} {}" % len(str(max(all_stats)))
        count_lines = [line_fmt.format(v, k) for k, v in counts.items()]
        type_lines = [line_fmt.format(v, k + " types")
                      for k, v in types.items()]
        contents["stats"] = "\n".join(count_lines + [""] + type_lines)

        return template.format(**contents)

    def write_file(self, filename, significant_figures=6):
        with open(filename, "w") as f:
            f.write(self.get_string(significant_figures=significant_figures))

    @classmethod
    def from_file(cls, filename, atom_style="full", sort_id=False):

        with open(filename) as f:
            lines = f.readlines()
        clines = list(clean_lines(lines))
        section_marks = [i for i, l in enumerate(clines) if l
                         in itertools.chain(*SECTION_KEYWORDS.values())]
        parts = np.split(clines, section_marks)

        # First, parse header
        float_group = r'([0-9eE.+-]+)'
        header_pattern = {}
        header_pattern["counts"] = r'^\s*(\d+)\s+([a-zA-Z]+)$'
        header_pattern["types"] = r'^\s*(\d+)\s+([a-zA-Z]+)\s+types$'
        header_pattern["bounds"] = r'^\s*{}$'.format(r'\s+'.join(
            [float_group] * 2 + [r"([xyz])lo \3hi"]))
        header_pattern["tilt"] = r'^\s*{}$'.format(r'\s+'.join(
            [float_group] * 3 + ["xy xz yz"]))

        header = {"counts": {}, "types": {}}
        bounds = {}
        for l in parts[0]:
            match = None
            for k, v in header_pattern.items():
                match = re.match(v, l)
                if match:
                    break
                else:
                    continue
            if match and k in ["counts", "types"]:
                header[k][match.group(2)] = int(match.group(1))
            elif match and k == "bounds":
                g = match.groups()
                bounds[g[2]] = [float(i) for i in g[:2]]
            elif match and k == "tilt":
                header["tilt"] = [float(i) for i in match.groups()]
        header["bounds"] = [bounds.get(i, [-0.5, 0.5]) for i in "xyz"]

        # Then, parse each section
        topo_sections = SECTION_KEYWORDS["molecule"]

        def parse_section(single_section_lines):
            kw = single_section_lines[0]

            if kw in SECTION_KEYWORDS["ff"] and kw != "PairIJ Coeffs":
                parse_line = lambda l: {"coeffs": [ast.literal_eval(x)
                                                   for x in l[1:]]}
            elif kw == "PairIJ Coeffs":
                parse_line = lambda l: {"id1": int(l[0]), "id2": int(l[1]),
                                        "coeffs": [ast.literal_eval(x)
                                                   for x in l[2:]]}
            elif kw in topo_sections:
                n = {"Bonds": 2, "Angles": 3, "Dihedrals": 4, "Impropers": 4}
                parse_line = lambda l: {"type": int(l[1]), kw[:-1].lower():
                    [int(x) for x in l[2:n[kw] + 2]]}
            elif kw == "Atoms":
                keys = ATOMS_LINE_FORMAT[atom_style].copy()
                sample_l = single_section_lines[1].split()
                if len(sample_l) == len(keys) + 1:
                    pass
                elif len(sample_l) == len(keys) + 4:
                    keys += ["nx", "ny", "nz"]
                else:
                    warnings.warn("Atoms section format might be imcompatible"
                                  " with atom_style %s." % atom_style)
                float_keys = [k for k in keys if k in ATOMS_FLOATS]
                parse_line = lambda l: {k: float(v) if k in float_keys
                else int(v) for (k, v) in zip(keys, l[1:len(keys) + 1])}
            elif kw == "Velocities":
                parse_line = lambda l: {"velocity": [float(x)
                                                     for x in l[1:4]]}
            elif kw == "Masses":
                parse_line = lambda l: {"mass": float(l[1])}
            else:
                warnings.warn("%s section parser has not been implemented. "
                              "Skipping..." % kw)
                return kw, []

            section = []
            splitted_lines = [l.split() for l in single_section_lines[1:]]
            if sort_id and kw != "PairIJ Coeffs":
                splitted_lines = sorted(splitted_lines,
                                        key=lambda l: int(l[0]))
            for l in splitted_lines:
                line_data = parse_line(l)
                if kw != "PairIJ Coeffs":
                    line_data["id"] = int(l[0])
                section.append(line_data)
            return kw, section

        err_msg = "Bad LAMMPS data format where "
        body = {}
        seen_atoms = False
        for part in parts[1:]:
            name, section = parse_section(part)
            if name == "Atoms":
                seen_atoms = True
            if name in ["Velocities"] + topo_sections and not seen_atoms:
                raise RuntimeError(err_msg + "%s section appears before"
                                             " Atoms section" % name)
            body.update({name: section})

        err_msg += "Nos. of {} do not match between header and {} section"
        assert len(body["Masses"]) == header["types"]["atom"], \
            err_msg.format("atom types", "Masses")
        atom_sections = ["Atoms", "Velocities"] \
            if body.get("Velocities") else ["Atoms"]
        for s in atom_sections:
            assert len(body[s]) == header["counts"]["atoms"], \
                err_msg.format("atoms", s)
        for s in topo_sections:
            if header["counts"].get(s.lower(), 0) > 0:
                assert len(body[s]) == header["counts"][s.lower()], \
                    err_msg.format(s.lower(), s)

        items = {k.lower(): body[k] for k in ["Masses", "Atoms"]}
        items["box_bounds"] = header["bounds"]
        items["box_tilt"] = header.get("tilt")
        items["velocities"] = body.get("Velocities")
        ff_kws = [k for k in body.keys() if k in SECTION_KEYWORDS["ff"]]
        items["force_field"] = {k: body[k] for k in ff_kws} if ff_kws \
            else None
        topo_kws = [k for k in body.keys()
                    if k in SECTION_KEYWORDS["molecule"]]
        items["topology"] = {k: body[k] for k in topo_kws} \
            if topo_kws else None
        items["atom_style"] = atom_style
        return cls(**items)


class Topology(MSONable):
    """
    Class carrying most data in Atoms, Velocities and molecular
    topology (Bonds, Angles, Dihedrals, and Impropers) sections for ONE
    single SiteCollection or its subclasses (Molecule/Structure), or a
    plain list of Sites.

    """

    def __init__(self, sites, atom_type=None, charges=None, velocities=None,
                 topologies=None):
        """

        Args:
            sites ([Site] or SiteCollection): A group of sites in a
                list or as a Molecule/Structure.
            atom_type (str): Site property key for labeling atoms of
                different types. Default to None, i.e., use
                site.species_string.
            charges ([q, ...]): Charge of each site in a (n,)
                array/list, where n is the No. of sites.
            velocities ([[vx, vy, vz], ...]): Velocity of each site in
                a (n, 3) array/list, where n is the No. of sites.
            topologies (dict): Bonds, angles, dihedrals and improper
                dihedrals defined by site indices.
                {
                    "Bonds": [[i, j], ...],
                    "Angles": [[i, j, k], ...],
                    "Dihedrals": [[i, j, k, l], ...],
                    "Impropers": [[i, j, k, l], ...]
                }

        """
        if not isinstance(sites, SiteCollection):
            sites = Molecule.from_sites(sites)

        if atom_type:
            types = sites.site_properties.get(atom_type)
        else:
            types = [site.species_string for site in sites]
        # search for site property if not override
        if charges is None:
            charges = sites.site_properties.get("charge")
        if velocities is None:
            velocities = sites.site_properties.get("velocities")
        # validate shape
        if charges is not None:
            charge_arr = np.array(charges)
            assert charge_arr.shape == (len(sites),),\
                "Wrong format for charges"
            charges = charge_arr.tolist()
        if velocities is not None:
            velocities_arr = np.array(velocities)
            assert velocities_arr.shape == (len(sites), 3), \
                "Wrong format for velocities"
            velocities = velocities_arr.tolist()

        if topologies:
            topologies = {k: v for k, v in topologies.items()
                          if k in SECTION_KEYWORDS["molecule"]}

        self.sites = sites
        self.atom_type = atom_type
        self.types = types
        self.charges = charges
        self.velocities = velocities
        self.topologies = topologies

    @classmethod
    def from_bonding(cls, molecule, bond=True, angle=True, dihedral=True,
                     atom_type=None, charges=None, velocities=None, tol=0.1):
        """
        Another constructor that creates an instance from a molecule.
        Covalent bonds and other bond-based topologies (angles and
        dihedrals) can be automatically determined. Cannot be used for
        non bond-based topologies, e.g., improper dihedrals.

        Args:
            molecule (Molecule): Input molecule.
            bond (bool): Whether find bonds. If set to False, angle and
                dihedral searching will be skipped. Default to True.
            angle (bool): Whether find angles. Default to True.
            dihedral (bool): Whether find dihedrals. Default to True.
            atom_type (str): Site property key for labeling atoms of
                different types. Default to None, i.e., use
                site.species_string.
            charges ([q, ...]): Charge of each site in a (n,)
                array/list, where n is the No. of atoms in molecule.
            velocities ([[vx, vy, vz], ...]): Velocity of each site in
                a (n, 3) array/list, where n is the No. of sites in
                molecule.
            tol (float): Bond distance tolerance. Default to 0.1.
                Not recommended to alter.

        """
        real_bonds = molecule.get_covalent_bonds(tol=tol)
        bond_list = [list(map(molecule.index, [b.site1, b.site2]))
                     for b in real_bonds]
        if not all((bond, bond_list)):
            return cls(sites=molecule, atom_type=atom_type, charges=charges,
                       velocities=velocities)
        else:
            angle_list, dihedral_list = [], []
            dests, freq = np.unique(bond_list, return_counts=True)
            hubs = dests[np.where(freq > 1)]
            bond_arr = np.array(bond_list)
            if len(hubs) > 0:
                hub_spokes = {}
                for hub in hubs:
                    ix = np.any(np.isin(bond_arr, hub), axis=1)
                    bonds = np.unique(bond_arr[ix]).tolist()
                    bonds.remove(hub)
                    hub_spokes[hub] = bonds
            dihedral = False if len(bond_list) < 3 or len(hubs) < 2 \
                else dihedral
            angle = False if len(bond_list) < 2 or len(hubs) < 1 else angle

            if angle:
                for k, v in hub_spokes.items():
                    angle_list.extend([[i, k, j] for i, j in
                                       itertools.combinations(v, 2)])
            if dihedral:
                hub_cons = bond_arr[np.all(np.isin(bond_arr, hubs), axis=1)]
                for i, j in hub_cons:
                    ks = [k for k in hub_spokes[i] if k != j]
                    ls = [l for l in hub_spokes[j] if l != i]
                    dihedral_list.extend([[k, i, j, l] for k,l in
                                          itertools.product(ks, ls)
                                          if k != l])

            topo_list = list(map(lambda l: None if len(l) == 0 else l,
                                 [bond_list, angle_list, dihedral_list]))
            topologies = {k: v for k, v
                          in zip(SECTION_KEYWORDS["molecule"][:3], topo_list)}
            topologies = None if not any(topologies.values()) else topologies
            return cls(sites=molecule, atom_type=atom_type, charges=charges,
                       velocities=velocities, topologies=topologies)


class ForceField(MSONable):

    def __init__(self, mass_dict, ff_coeffs=None):
        mass_dict = {k: v.atomic_mass.real if isinstance(v, Element)
                     else Element(v).atomic_mass.real if isinstance(v, str)
                     else v for k, v in mass_dict.items()}
        if ff_coeffs:
            ff_coeffs = {k: v for k, v in ff_coeffs.items()
                         if k in SECTION_KEYWORDS["ff"]}
            keys_by_type = {k: v.keys() for k, v in ff_coeffs.items()}
            # check whether all labels defined in masses
            all_keys = itertools.chain(*keys_by_type.values())
            labels = itertools.chain(*[k.split('-') for k in all_keys])
            assert set(labels).issubset(mass_dict.keys()),\
                "Unknown atom type found in force field coeffs"
            # check whether reverse duplicated keys exist,
            # e.g., "C-H" and "H-C"
            # improper dihedral might need a looser rule
            for sec, keys in keys_by_type.items():
                reverse = lambda k: "-".join(k.split("-")[::-1])
                asym_keys = set([reverse(k) for k in keys if reverse(k) != k])
                assert not asym_keys.intersection(keys),\
                    "Reverse duplicated key found in %s" % sec
            # validate No. of PairIJ Coeffs
            if "PairIJ Coeffs" in keys_by_type.keys():
                n = len(mass_dict)
                comb = n * (n + 1) / 2
                nij = len(ff_coeffs["PairIJ Coeffs"])
                assert nij == comb, \
                    "Expecting {} PairIJ Coeffs for {} atom types," \
                    " got {}".format(comb, n, nij)

        self.mass_dict = mass_dict
        self.ff_coeffs = ff_coeffs
        self.masses, self._atom_map = self.get_coeffs_and_mapper("Masses")

    def get_coeffs_and_mapper(self, section):
        if section == "Masses":
            coeff_dict = self.mass_dict
            key = "mass"
        elif section in SECTION_KEYWORDS["ff"][2:]:
            coeff_dict = self.ff_coeffs[section]
            key = "coeffs"
        else:
            raise RuntimeError("Invalid coefficient section keyword")

        data = []
        mapper = {}
        for i, (k, v) in enumerate(coeff_dict.items()):
            data.append({"id": i + 1, key: v})
            mapper[k] = i + 1
        return data, mapper

    def get_pair_coeffs(self, section, sort_id=True):
        if section not in SECTION_KEYWORDS["ff"][:2]:
            raise RuntimeError("Invalid pair coefficient section keyword")
        else:
            coeff_dict = self.ff_coeffs[section]

        def map_key_and_coeffs(key, coeffs):
            if section.startswith("PairIJ"):
                k1, k2 = key.split("-")
                ids = sorted(map(self._atom_map.get, [k1, k2]))
                d = {"id%d" % i: v for i, v in zip([1, 2], ids)}
            else:
                d = {"id": self._atom_map[key]}
            d["coeffs"] = coeffs
            return d

        data = []
        for k, v in coeff_dict.items():
            data.append(map_key_and_coeffs(k, v))
        if sort_id:
            key = lambda d: (d["id1"], d["id2"]) \
                if section.startswith("PairIJ") else d["id"]
            data = sorted(data, key=key)
        return data

    # def get_all_data(self, topologies, atom_style="full"):
    #     atom_types = set(itertools.chain(*[t.types for t in topologies]))
    #     assert atom_types.issubset(self._atom_map.keys()),\
    #         "Unknown atom type found in topologies"
    #     atoms_data = []
    #     velo = [] if topologies[0].velocities else None
    #     masses_data = self.masses_data
    #     lookup = {"Atoms": self._atom_map}
    #     ff_coeffs = {} if self.ff_coeffs else None
    #     if isinstance(ff_coeffs, dict):
    #         ff_kws =


    def to_file(self, filename):
        yaml = YAML(typ="safe")
        with open(filename, "w") as f:
            yaml.dump(self.__dict__, f)

    @classmethod
    def from_file(cls, filename):
        yaml = YAML(typ="safe")
        with open(filename, "r") as f:
            d = yaml.load(f)
        return cls(d["masses"], d["ff_coeffs"])
