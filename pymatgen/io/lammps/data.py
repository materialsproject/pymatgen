# coding: utf-8
# Copyright (c) Pymatgen Development Team.
# Distributed under the terms of the MIT License.

from __future__ import division, print_function, unicode_literals, \
    absolute_import

import itertools
import warnings
import re
import ast

import numpy as np
from monty.json import MSONable
from ruamel.yaml import YAML

from pymatgen.util.io_utils import clean_lines
from pymatgen.core.structure import SiteCollection

__author__ = 'Kiran Mathew'
__email__ = "kmathew@lbl.gov"
__credits__ = 'Brandon Wood'


class LammpsData(MSONable):

    SECTION_KEYWORDS = {"atom": ["Atoms", "Velocities", "Masses",
                                 "Ellipsoids", "Lines", "Triangles",
                                 "Bodies"],
                        "molecule": ["Bonds", "Angles", "Dihedrals",
                                     "Impropers"],
                        "ff": ["Pair Coeffs", "PairIJ Coeffs", "Bond Coeffs",
                               "Angle Coeffs", "Dihedral Coeffs",
                               "Improper Coeffs"],
                        "class2": ["BondBond Coeffs", "BondAngle Coeffs",
                                   "MiddleBondTorsion Coeffs",
                                   "EndBondTorsion Coeffs",
                                   "AngleTorsion Coeffs",
                                   "AngleAngleTorsion Coeffs",
                                   "BondBond13 Coeffs", "AngleAngle Coeffs"]}

    ATOMS_LINE_FORMAT = {"angle": ["molecule-ID", "type", "x", "y", "z"],
                         "atomic": ["type", "x", "y", "z"],
                         "bond": ["molecule-ID", "type", "x", "y", "z"],
                         "charge": ["type", "q", "x", "y", "z"],
                         "full": ["molecule-ID", "type", "q", "x", "y", "z"],
                         "molecular": ["molecule-ID", "type", "x", "y", "z"]}

    ATOMS_FLOATS = ["q", "x", "y", "z"]

    def __init__(self, masses, atoms, box_bounds, box_tilt=None,
                 velocities=None, ff_coeffs=None, topology=None,
                 atom_style="full"):
        self.masses = masses
        self.atoms = atoms
        self.box_bounds = box_bounds
        self.box_tilt = box_tilt
        self.velocities = velocities
        self.ff_coeffs = ff_coeffs
        self.topology = topology
        self.atom_style = atom_style

    def __str__(self):
        return self.get_string()

    def get_string(self, significant_figures=6):
        template = """Generated by pymatgen.io.lammps.data.LammpsData

{stats}

{box}

{masses}

{ff_sections}

{atoms}

{velocities}

{topo_sections}
        """

        contents = {}

        float_ph = "{:.%df}" % significant_figures \
            if significant_figures else "{}"

        def _pretty_section(title, str_mat):
            lens = [max(map(len, col)) for col in zip(*str_mat)]
            fmt = "  ".join("{:>%d}" % x for x in lens)
            rows = [title, ""] + [fmt.format(*row) for row in str_mat]
            sec = "\n".join(rows)
            return sec

        counts = {"atoms": len(self.atoms)}
        types = {"atom": len(self.masses)}

        # box
        box_lines = []
        for bound, d in zip(self.box_bounds, "xyz"):
            fillers = bound + [d] * 2
            bound_format = " ".join([float_ph] * 2 + ["{}lo {}hi"])
            box_lines.append(bound_format.format(*fillers))
        if self.box_tilt:
            tilt_format = " ".join([float_ph] * 3 + ["xy xz yz"])
            box_lines.append(tilt_format.format(*self.box_tilt))
        contents["box"] = "\n".join(box_lines)

        # masses
        masses_mat = [["%d" % m["id"], "{:.4f}".format(m["mass"])]
                      for m in self.masses]
        contents["masses"] = _pretty_section("Masses", masses_mat)

        # ff_sections
        contents["ff_sections"] = ""
        if self.ff_coeffs:
            ff_kws = [k for k in self.SECTION_KEYWORDS["ff"]
                      if k in self.ff_coeffs.keys()]
            ff_parts = []
            for kw in ff_kws:
                if kw is "PairIJ Coeffs":
                    ff_mat = [[str(i) for i in
                               [d["id1"], d["id2"]] + d["coeffs"]]
                              for d in self.ff_coeffs[kw]]
                else:
                    ff_mat = [[str(i) for i in [d["id"]] + d["coeffs"]]
                              for d in self.ff_coeffs[kw]]
                if not kw.startswith("Pair"):
                    types[kw.lower()[:-7]] = len(ff_mat)
                ff_parts.append(_pretty_section(kw, ff_mat))
            contents["ff_sections"] = "\n\n".join(ff_parts)

        # atoms
        atom_format = ["id"] + self.ATOMS_LINE_FORMAT[self.atom_style]
        if "nx" in self.atoms[0].keys():
            atom_format.extend(["nx", "ny", "nz"])
        map_str = lambda t: float_ph if t in self.ATOMS_FLOATS else "{}"
        atoms_mat = []
        for a in self.atoms:
            atoms_mat.append([map_str(k).format(a[k]) for k in atom_format])
        contents["atoms"] = _pretty_section("Atoms", atoms_mat)

        # velocities
        contents["velocities"] = ""
        if self.velocities:
            velocities_mat = []
            for v in self.velocities:
                vs = [float_ph.format(i) for i in v["velocity"]]
                velocities_mat.append(["%d" % v["id"]] + vs)
            contents["velocities"] = _pretty_section("Velocities",
                                                     velocities_mat)

        # topo_sections
        contents["topo_sections"] = ""
        if self.topology:
            topo_kws = [k for k in self.SECTION_KEYWORDS["molecule"]
                        if k in self.topology.keys()]
            topo_parts = []
            for kw in topo_kws:
                skw = kw.lower()[:-1]
                topo_mat = [["%d" % v for v in [d["id"], d["type"]] + d[skw]]
                            for d in self.topology[kw]]
                counts[kw.lower()] = len(topo_mat)
                topo_parts.append(_pretty_section(kw, topo_mat))
            contents["topo_sections"] = "\n\n".join(topo_parts)

        # stats
        all_stats = list(counts.values()) + list(types.values())
        line_fmt = "{:>%d} {}" % len(str(max(all_stats)))
        count_lines = [line_fmt.format(v, k) for k, v in counts.items()]
        type_lines = [line_fmt.format(v, k + " types")
                      for k, v in types.items()]
        contents["stats"] = "\n".join(count_lines + [""] + type_lines)

        return template.format(**contents)

    def write_file(self, filename, significant_figures=6):
        with open(filename, "w") as f:
            f.write(self.get_string(significant_figures=significant_figures))

    @classmethod
    def from_file(cls, filename, atom_style="full", sort_id=False):

        with open(filename) as f:
            lines = f.readlines()
        clines = list(clean_lines(lines))
        section_marks = [i for i, l in enumerate(clines) if l
                         in itertools.chain(*cls.SECTION_KEYWORDS.values())]
        parts = np.split(clines, section_marks)

        # First, parse header
        float_group = r'([0-9eE.+-]+)'
        header_pattern = {}
        header_pattern["counts"] = r'^\s*(\d+)\s+([a-zA-Z]+)$'
        header_pattern["types"] = r'^\s*(\d+)\s+([a-zA-Z]+)\s+types$'
        header_pattern["bounds"] = r'^\s*{}$'.format(r'\s+'.join(
            [float_group] * 2 + [r"([xyz])lo \3hi"]))
        header_pattern["tilt"] = r'^\s*{}$'.format(r'\s+'.join(
            [float_group] * 3 + ["xy xz yz"]))

        header = {"counts": {}, "types": {}}
        bounds = {}
        for l in parts[0]:
            match = None
            for k, v in header_pattern.items():
                match = re.match(v, l)
                if match:
                    break
                else:
                    continue
            if match and k in ["counts", "types"]:
                header[k][match.group(2)] = int(match.group(1))
            elif match and k == "bounds":
                g = match.groups()
                bounds[g[2]] = [float(i) for i in g[:2]]
            elif match and k == "tilt":
                header["tilt"] = [float(i) for i in match.groups()]
        header["bounds"] = [bounds.get(i, [-0.5, 0.5]) for i in "xyz"]

        # Then, parse each section
        topo_sections = cls.SECTION_KEYWORDS["molecule"]

        def parse_section(single_section_lines):
            kw = single_section_lines[0]

            if kw in cls.SECTION_KEYWORDS["ff"] and kw != "PairIJ Coeffs":
                parse_line = lambda l: {"coeffs": [ast.literal_eval(x)
                                                   for x in l[1:]]}
            elif kw == "PairIJ Coeffs":
                parse_line = lambda l: {"id1": int(l[0]), "id2": int(l[1]),
                                        "coeffs": [ast.literal_eval(x)
                                                   for x in l[2:]]}
            elif kw in topo_sections:
                n = {"Bonds": 2, "Angles": 3, "Dihedrals": 4, "Impropers": 4}
                parse_line = lambda l: {"type": int(l[1]), kw[:-1].lower():
                    [int(x) for x in l[2:n[kw] + 2]]}
            elif kw == "Atoms":
                keys = cls.ATOMS_LINE_FORMAT[atom_style].copy()
                sample_l = single_section_lines[1].split()
                if len(sample_l) == len(keys) + 1:
                    pass
                elif len(sample_l) == len(keys) + 4:
                    keys += ["nx", "ny", "nz"]
                else:
                    warnings.warn("Atoms section format might be imcompatible"
                                  " with atom_style %s." % atom_style)
                float_keys = [k for k in keys if k in cls.ATOMS_FLOATS]
                parse_line = lambda l: {k: float(v) if k in float_keys
                else int(v) for (k, v) in zip(keys, l[1:len(keys) + 1])}
            elif kw == "Velocities":
                parse_line = lambda l: {"velocity": [float(x)
                                                     for x in l[1:4]]}
            elif kw == "Masses":
                parse_line = lambda l: {"mass": float(l[1])}
            else:
                warnings.warn("%s section parser has not been implemented. "
                              "Skipping..." % kw)
                return kw, []

            section = []
            splitted_lines = [l.split() for l in single_section_lines[1:]]
            if sort_id and kw != "PairIJ Coeffs":
                splitted_lines = sorted(splitted_lines,
                                        key=lambda l: int(l[0]))
            for l in splitted_lines:
                line_data = parse_line(l)
                if kw != "PairIJ Coeffs":
                    line_data["id"] = int(l[0])
                section.append(line_data)
            return kw, section

        err_msg = "Bad LAMMPS data format where "
        body = {}
        seen_atoms = False
        for part in parts[1:]:
            name, section = parse_section(part)
            if name == "Atoms":
                seen_atoms = True
            if name in ["Velocities"] + topo_sections and not seen_atoms:
                raise RuntimeError(err_msg + "%s section appears before"
                                             " Atoms section" % name)
            body.update({name: section})

        err_msg += "Nos. of {} do not match between header and {} section"
        assert len(body["Masses"]) == header["types"]["atom"], \
            err_msg.format("atom types", "Masses")
        atom_sections = ["Atoms", "Velocities"] \
            if body.get("Velocities") else ["Atoms"]
        for s in atom_sections:
            assert len(body[s]) == header["counts"]["atoms"], \
                err_msg.format("atoms", s)
        for s in topo_sections:
            if header["counts"].get(s.lower(), 0) > 0:
                assert len(body[s]) == header["counts"][s.lower()], \
                    err_msg.format(s.lower(), s)

        items = {k.lower(): body[k] for k in ["Masses", "Atoms"]}
        items["box_bounds"] = header["bounds"]
        items["box_tilt"] = header.get("tilt")
        items["velocities"] = body.get("Velocities")
        ff_kws = [k for k in body.keys() if k in cls.SECTION_KEYWORDS["ff"]]
        items["ff_coeffs"] = {k: body[k] for k in ff_kws} if ff_kws else None
        topo_kws = [k for k in body.keys()
                    if k in cls.SECTION_KEYWORDS["molecule"]]
        items["topology"] = {k: body[k] for k in topo_kws} \
            if topo_kws else None
        items["atom_style"] = atom_style
        return cls(**items)


class Topology(MSONable):

    def __init__(self, sites, velocities=None, topologies=None):

        if not velocities:
            if isinstance(sites, SiteCollection):
                velocities = sites.site_properties.get("velocities")
            else:
                velocities = [s.properties["velocities"] for s in sites]

        self.sites = sites
        self.velocities = velocities
        self.topologies = topologies

    @classmethod
    def from_bonding(cls, molecule, velocities=None, tol=0.1):

        bonds = molecule.get_covalent_bonds(tol=tol)
        bond_arr = np.array([list(map(molecule.index,
                                      [b.site1, b.site2])) for b in bonds])

        bond_sites, counts = np.unique(bond_arr, return_counts=True)
        endpoints = bond_sites[np.where(counts > 1)]
        ep_bonds = {}
        for ep in endpoints:
            ix = np.any(np.isin(bond_arr, ep), axis=1)
            bonds = np.unique(np.array(bond_arr)[ix]).tolist()
            bonds.remove(ep)
            ep_bonds[ep] = bonds

        angle_arr = []
        for k, v in ep_bonds.items():
            angle_arr.extend([[i, k, j]
                              for i, j in itertools.combinations(v, 2)])

        dihedral_bonds = bond_arr[np.all(np.isin(bond_arr, endpoints),
                                         axis=1)]
        dihedral_arr = []
        for i, j in dihedral_bonds:
            ks = [k for k in ep_bonds[i] if k != j]
            ls = [l for l in ep_bonds[j] if l != i]
            dihedral_arr.extend([[k, i, j, l]
                                 for k, l in itertools.product(ks, ls)
                                 if k != l])

        topologies = {"Bonds": bond_arr.tolist(), "Angle": angle_arr,
                      "Dihedrals": dihedral_arr}
        return cls(sites=molecule, velocities=velocities,
                   topologies=topologies)


class Forcefield(MSONable):

    def __init__(self, masses, ff_coeffs=None):
        self.masses = masses
        self.ff_coeffs = ff_coeffs

    def to_file(self, filename):
        yaml = YAML(typ="safe")
        with open(filename, "w") as f:
            yaml.dump(self.__dict__, f)


    @classmethod
    def from_file(cls, filename):
        yaml = YAML(typ="safe")
        with open(filename, "r") as f:
            d = yaml.load(f)
        return cls(d["masses"], d["ff_coeffs"])


