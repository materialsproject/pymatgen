# coding: utf-8
"""
A Flow is a container for Works, and works consist of tasks.
Flows are the final objects that can be dumped directly to a pickle file on disk
Flows are executed using abirun (abipy).
"""
from __future__ import unicode_literals, division, print_function

import os
import sys
import time
import collections
import warnings
import shutil
import copy

from pprint import pprint
from six.moves import map
from atomicfile import AtomicFile
from prettytable import PrettyTable
from pydispatch import dispatcher
from monty.collections import as_set
from monty.string import list_strings, is_string
from monty.io import FileLock
from monty.pprint import draw_tree
from monty.termcolor import stream_has_colours, cprint, colored, cprint_map
from monty.inspect import find_top_pyfile
from pymatgen.serializers.pickle_coders import pmg_pickle_load, pmg_pickle_dump 
from pymatgen.core.units import Time, Memory
from .nodes import Status, Node, NodeResults, Dependency, GarbageCollector #, check_spectator
from .tasks import (Task, ScfTask, PhononTask, TaskManager, NscfTask, DdkTask,
                    AnaddbTask, DdeTask, TaskManager)
from .utils import Directory, Editor
from .abiinspect import yaml_read_irred_perts
from .works import Work, BandStructureWork, PhononWork, G0W0Work, QptdmWork
from .events import EventsParser


import logging
logger = logging.getLogger(__name__)

__author__ = "Matteo Giantomassi"
__copyright__ = "Copyright 2013, The Materials Project"
__version__ = "0.1"
__maintainer__ = "Matteo Giantomassi"


__all__ = [
    "Flow",
    "G0W0WithQptdmFlow",
    "bandstructure_flow",
    "g0w0_flow",
    "phonon_flow",
]


class FlowResults(NodeResults):

    JSON_SCHEMA = NodeResults.JSON_SCHEMA.copy()
    #JSON_SCHEMA["properties"] = {
    #    "queries": {"type": "string", "required": True},
    #}

    @classmethod
    def from_node(cls, flow):
        """Initialize an instance from a Work instance."""
        new = super(FlowResults, cls).from_node(flow)

        #new.update(
        #    #input=flow.strategy
        #)

        # Will put all files found in outdir in GridFs
        d = {os.path.basename(f): f for f in flow.outdir.list_filepaths()}

        # Add the pickle file.
        d["pickle"] = flow.pickle_file if flow.pickle_protocol != 0 else (flow.pickle_file, "t")
        new.add_gridfs_files(**d)

        return new


class Flow(Node):
    """
    This object is a container of work. Its main task is managing the
    possible inter-dependencies among the work and the creation of
    dynamic workflows that are generated by callbacks registered by the user.

    .. attributes::

        creation_date: String with the creation_date
        pickle_protocol: Protocol for Pickle database (default: -1 i.e. latest protocol)

    Important methods for constructing flows:

    .. methods::

        register_work: register (add) a work to the flow
        resister_task: register a work that contains only this task returns the work
        allocate: propagate the workdir and manager of the flow to all the registered tasks
        build:
        build_and_pickle_dump:
    """
    VERSION = "0.1"
    PICKLE_FNAME = "__AbinitFlow__.pickle"

    Results = FlowResults

    @classmethod
    def from_inputs(cls, workdir, inputs, manager=None, pickle_protocol=-1, task_class=ScfTask, work_class=Work):
        """
        Construct a simple flow from a list of inputs. The flow contains a single Work with
        tasks whose class is given by task_class.

        .. warning::
            Don't use this interface if you have a dependencies among the tasks

        Args:
            workdir: String specifying the directory where the works will be produced.
            inputs: List of inputs.
            manager: :class:`TaskManager` object responsible for the submission of the jobs.
                If manager is None, the object is initialized from the yaml file
                located either in the working directory or in the user configuration dir.
            pickle_procol: Pickle protocol version used for saving the status of the object.
                -1 denotes the latest version supported by the python interpreter.
            task_class: The class of the :class:`Task`.
            work_class: The class of the :class:`Work`.
        """
        if not isinstance(inputs, (list, tuple)): inputs = [inputs]

        flow = cls(workdir, manager=manager, pickle_protocol=pickle_protocol)
        work = work_class()
        for inp in inputs:
            work.register(inp, task_class=task_class)
        flow.register_work(work)

        return flow.allocate()

    @classmethod
    def as_flow(cls, obj):
        """Convert obj into a Flow. Accepts filepath, dict Flow object."""
        if isinstance(obj, cls): return obj
        if is_string(obj):
            return cls.pickle_load(obj)
        elif isinstance(obj, collections.Mapping):
            return cls.from_dict(obj)
        else:
            raise TypeError("Don't know how to convert type %s into a Flow" % type(obj))

    def __init__(self, workdir, manager=None, pickle_protocol=-1):
        """
        Args:
            workdir: String specifying the directory where the works will be produced.
            manager: :class:`TaskManager` object responsible for the submission of the jobs.
                     If manager is None, the object is initialized from the yaml file
                     located either in the working directory or in the user configuration dir.
            pickle_procol: Pickle protocol version used for saving the status of the object.
                          -1 denotes the latest version supported by the python interpreter.
        """
        super(Flow, self).__init__()

        self.set_workdir(workdir)

        self.creation_date = time.asctime()

        if manager is None: manager = TaskManager.from_user_config()
        self.manager = manager.deepcopy()

        # List of works.
        self._works = []

        self._waited = 0

        # List of callbacks that must be executed when the dependencies reach S_OK
        self._callbacks = []

        # Install default list of handlers at the flow level.
        # Users can override the default list by calling flow.install_event_handlers in the script.
        # Example:
        #
        #    # flow level (common case)
        #    flow.install_event_handlers(handlers=my_handlers)
        #
        #    # task level (advanced mode)
        #    flow[0][0].install_event_handlers(handlers=my_handlers)
        # 
        self.install_event_handlers()

        self.pickle_protocol = int(pickle_protocol)

        # ID used to access mongodb
        self._mongo_id = None

        # Save the location of the script used to generate the flow.
        # This trick won't work if we are running with nosetests, py.test etc
        pyfile = find_top_pyfile()
        if "python" in pyfile or "ipython" in pyfile: pyfile = "<" + pyfile + ">"
        self.set_pyfile(pyfile)

        # TODO
        # Signal slots: a dictionary with the list
        # of callbacks indexed by node_id and SIGNAL_TYPE.
        # When the node changes its status, it broadcast a signal.
        # The flow is listening to all the nodes of the calculation
        # [node_id][SIGNAL] = list_of_signal_handlers
        #self._sig_slots =  slots = {}
        #for work in self:
        #    slots[work] = {s: [] for s in work.S_ALL}

        #for task in self.iflat_tasks():
        #    slots[task] = {s: [] for s in work.S_ALL}

    def as_dict(self, **kwargs):
        """
        JSON serialization, note that we only need to save
        a string with the working directory since the object will be
        reconstructed from the pickle file located in workdir
        """
        return {"workdir": self.workdir}

    # This is needed for fireworks.
    to_dict = as_dict

    @classmethod
    def from_dict(cls, d, **kwargs):
        """Reconstruct the flow from the pickle file."""
        return cls.pickle_load(d["workdir"], **kwargs)

    def set_workdir(self, workdir, chroot=False):
        """
        Set the working directory. Cannot be set more than once unless chroot is True
        """
        if not chroot and hasattr(self, "workdir") and self.workdir != workdir:
            raise ValueError("self.workdir != workdir: %s, %s" % (self.workdir,  workdir))

        # Directories with (input|output|temporary) data.
        self.workdir = os.path.abspath(workdir)
        self.indir = Directory(os.path.join(self.workdir, "indata"))
        self.outdir = Directory(os.path.join(self.workdir, "outdata"))
        self.tmpdir = Directory(os.path.join(self.workdir, "tmpdata"))

    @classmethod
    def pickle_load(cls, filepath, spectator_mode=False, remove_lock=False):
        """
        Loads the object from a pickle file and performs initial setup.

        Args:
            filepath: Filename or directory name. It filepath is a directory, we
                scan the directory tree starting from filepath and we
                read the first pickle database. Raise RuntimeError if multiple
                databases are found.
            spectator_mode: If True, the nodes of the flow are not connected by signals.
                This option is usually used when we want to read a flow
                in read-only mode and we want to avoid callbacks that can change the flow.
            remove_lock:
                True to remove the file lock if any (use it carefully).
        """
        if os.path.isdir(filepath):
            # Walk through each directory inside path and find the pickle database.
            for dirpath, dirnames, filenames in os.walk(filepath):
                fnames = [f for f in filenames if f == cls.PICKLE_FNAME]
                if fnames:
                    if len(fnames) == 1:
                        filepath = os.path.join(dirpath, fnames[0])
                        break  # Exit os.walk
                    else:
                        err_msg = "Found multiple databases:\n %s" % str(fnames)
                        raise RuntimeError(err_msg)
            else:
                err_msg = "Cannot find %s inside directory %s" % (cls.PICKLE_FNAME, filepath)
                raise ValueError(err_msg)

        if remove_lock and os.path.exists(filepath + ".lock"):
            try: 
                os.remove(filepath + ".lock")
            except:
                pass

        with FileLock(filepath):
            with open(filepath, "rb") as fh:
                flow = pmg_pickle_load(fh)

        # Check if versions match.
        if flow.VERSION != cls.VERSION:
            msg = ("File flow version %s != latest version %s\n."
                   "Regenerate the flow to solve the problem " % (flow.VERSION, cls.VERSION))
            warnings.warn(msg)

        flow.set_spectator_mode(spectator_mode)

        # Recompute the status of each task since tasks that
        # have been submitted previously might be completed.
        flow.check_status()
        return flow

    def __len__(self):
        return len(self.works)

    def __iter__(self):
        return self.works.__iter__()

    def __getitem__(self, slice):
        return self.works[slice]

    def set_pyfile(self, pyfile):
        """
        Set the path of the python script used to generate the flow.

        .. Example:

            flow.set_pyfile(__file__)
        """
        # TODO: Could use a frame hack to get the caller outside abinitio
        # so that pyfile is automatically set when we __init__ it!
        self._pyfile = os.path.abspath(pyfile)

    @property
    def pyfile(self):
        """
        Absolute path of the python script used to generate the flow. Set by `set_pyfile`
        """
        try: 
            return self._pyfile
        except AttributeError:
            return None

    @property
    def pid_file(self):
        """The path of the pid file created by PyFlowScheduler."""
        return os.path.join(self.workdir, "_PyFlowScheduler.pid")

    @property
    def pickle_file(self):
        """The path of the pickle file."""
        return os.path.join(self.workdir, self.PICKLE_FNAME)

    @property
    def mongo_id(self):
        return self._mongo_id

    @mongo_id.setter
    def mongo_id(self, value):
        if self.mongo_id is not None:
            raise RuntimeError("Cannot change mongo_id %s" % self.mongo_id)
        self._mongo_id = value

    def validate_json_schema(self):
        """Validate the JSON schema. Return list of errors."""
        errors = []

        for work in self:
            for task in work:
                if not task.get_results().validate_json_schema():
                    errors.append(task)
            if not work.get_results().validate_json_schema():
                errors.append(work)
        if not self.get_results().validate_json_schema():
            errors.append(self)

        return errors

    @property
    def works(self):
        """List of :class:`Work` objects contained in self.."""
        return self._works

    @property
    def all_ok(self):
        """True if all the tasks in works have reached `S_OK`."""
        return all(work.all_ok for work in self)

    @property
    def num_tasks(self):
        """Total number of tasks"""
        return len(list(self.iflat_tasks()))

    @property
    def errored_tasks(self):
        """List of errored tasks."""
        etasks = []
        for status in [self.S_ERROR, self.S_QCRITICAL, self.S_ABICRITICAL]:
            etasks.extend(list(self.iflat_tasks(status=status)))

        return set(etasks)

    @property
    def num_errored_tasks(self):
        """The number of tasks whose status is `S_ERROR`."""
        return len(self.errored_tasks)

    @property
    def unconverged_tasks(self):
        """List of unconverged tasks."""
        return list(self.iflat_tasks(status=self.S_UNCONVERGED))

    @property
    def num_unconverged_tasks(self):
        """The number of tasks whose status is `S_UNCONVERGED`."""
        return len(self.unconverged_tasks)

    @property
    def status_counter(self):
        """
        Returns a `Counter` object that counts the number of tasks with
        given status (use the string representation of the status as key).
        """
        # Count the number of tasks with given status in each work.
        counter = self[0].status_counter
        for work in self[1:]:
            counter += work.status_counter

        return counter

    @property
    def ncores_reserved(self):
        """
        Returns the number of cores reserved in this moment.
        A core is reserved if the task is not running but
        we have submitted the task to the queue manager.
        """
        return sum(work.ncores_reserved for work in self)

    @property
    def ncores_allocated(self):
        """
        Returns the number of cores allocated in this moment.
        A core is allocated if it's running a task or if we have
        submitted a task to the queue manager but the job is still pending.
        """
        return sum(work.ncores_allocated for work in self)

    @property
    def ncores_used(self):
        """
        Returns the number of cores used in this moment.
        A core is used if there's a job that is running on it.
        """
        return sum(work.ncores_used for work in self)

    @property
    def has_chrooted(self):
        """
        Returns a string that evaluates to True if we have changed
        the workdir for visualization purposes e.g. we are using sshfs.
        to mount the remote directory where the `Flow` is located.
        The string gives the previous workdir of the flow.
        """
        try:
            return self._chrooted_from
        except AttributeError:
            return ""

    def chroot(self, new_workdir):
        """
        Change the workir of the :class:`Flow`. Mainly used for
        allowing the user to open the GUI on the local host
        and access the flow from remote via sshfs.

        .. note::
            Calling this method will make the flow go in read-only mode.
        """
        self._chrooted_from = self.workdir
        self.set_workdir(new_workdir, chroot=True)

        for i, work in enumerate(self):
            new_wdir = os.path.join(self.workdir, "w" + str(i))
            work.chroot(new_wdir)

    def groupby_status(self):
        """
        Returns a ordered dictionary mapping the task status to
        the list of named tuples (task, work_index, task_index).
        """
        Entry = collections.namedtuple("Entry", "task wi ti")
        d = collections.defaultdict(list)

        for task, wi, ti in self.iflat_tasks_wti():
            d[task.status].append(Entry(task, wi, ti))

        # Sort keys according to their status.
        return collections.OrderedDict([(k, d[k]) for k in sorted(list(d.keys()))])

    def iflat_tasks_wti(self, status=None, op="==", nids=None):
        """
        Generator to iterate over all the tasks of the `Flow`.
        Yields:

            (task, work_index, task_index)

        If status is not None, only the tasks whose status satisfies
        the condition (task.status op status) are selected
        status can be either one of the flags defined in the :class:`Task` class
        (e.g Task.S_OK) or a string e.g "S_OK"
        nids is an optional list of node identifiers used to filter the tasks.
        """
        return self._iflat_tasks_wti(status=status, op=op, nids=nids, with_wti=True)

    def iflat_tasks(self, status=None, op="==", nids=None):
        """
        Generator to iterate over all the tasks of the :class:`Flow`.

        If status is not None, only the tasks whose status satisfies
        the condition (task.status op status) are selected
        status can be either one of the flags defined in the :class:`Task` class
        (e.g Task.S_OK) or a string e.g "S_OK"
        nids is an optional list of node identifiers used to filter the tasks.
        """
        return self._iflat_tasks_wti(status=status, op=op, nids=nids, with_wti=False)

    def _iflat_tasks_wti(self, status=None, op="==", nids=None, with_wti=True):
        """
        Generators that produces a flat sequence of task.
        if status is not None, only the tasks with the specified status are selected.
        nids is an optional list of node identifiers used to filter the tasks.

        Returns:
            (task, work_index, task_index) if with_wti is True else task
        """
        nids = as_set(nids)

        if status is None:
            for wi, work in enumerate(self):
                for ti, task in enumerate(work):
                    if nids and task.node_id not in nids: continue
                    if with_wti:
                        yield task, wi, ti
                    else:
                        yield task

        else:
            # Get the operator from the string.
            import operator
            op = {
                "==": operator.eq,
                "!=": operator.ne,
                ">": operator.gt,
                ">=": operator.ge,
                "<": operator.lt,
                "<=": operator.le,
            }[op]

            # Accept Task.S_FLAG or string.
            status = Status.as_status(status)

            for wi, work in enumerate(self):
                for ti, task in enumerate(work):
                    if nids and task.node_id not in nids: continue
                    if op(task.status, status):
                        if with_wti:
                            yield task, wi, ti
                        else:
                            yield task

    def check_dependencies(self):
        """Test the dependencies of the nodes for possible deadlocks."""
        deadlocks = []

        for task in self.iflat_tasks():
            for dep in task.deps:
                if dep.node.depends_on(task):
                    deadlocks.append((task, dep.node))

        if deadlocks:
            lines = ["Detect wrong list of dependecies that will lead to a deadlock:"]
            lines.extend(["%s <--> %s" % nodes for nodes in deadlocks])
            raise RuntimeError("\n".join(lines))

    def deadlocked_runnables_running(self):
        """
        This function detects deadlocks

        Return:
            deadlocks, runnables, running
        """
        runnables = []
        for work in self:
            runnables.extend(work.fetch_alltasks_to_run())

        running = list(self.iflat_tasks(status=self.S_RUN))

        err_tasks = self.errored_tasks
        deadlocked = []
        if err_tasks:
            for task in self.iflat_tasks():
                if any(task.depends_on(err_task) for err_task in err_tasks):
                    deadlocked.append(task)

        return deadlocked, runnables, running

    def check_status(self, **kwargs):
        """
        Check the status of the works in self.

        Args:
            show: True to show the status of the flow.
            kwargs: keyword arguments passed to show_status
        """
        for work in self:
            work.check_status()

        if kwargs.pop("show", False):
            self.show_status(**kwargs)

    #def set_status(self, status):

    @property
    def status(self):
        """The status of the :class:`Flow` i.e. the minimum of the status of its tasks and its works"""
        return min(work.get_all_status(only_min=True) for work in self)

    def fix_abi_critical(self):
        """
        This function tries to fix critical events originating from ABINIT.
        Returns the number of tasks that have been fixed.
        """
        count = 0
        for task in self.iflat_tasks(status=self.S_ABICRITICAL):
            count += task.fix_abi_critical()

        return count

    def fix_queue_critical(self):
        """
        This function tries to fix critical events originating from the queue submission system.

        Returns the number of tasks that have been fixed.
        """
        count = 0
        for task in self.iflat_tasks(status=self.S_QCRITICAL):
            logger.info("Will try to fix task %s" % str(task))
            count += task.fix_queue_critical()

        return count

    def show_summary(self, **kwargs):
        """
        Print a short summary with the status of the flow and a counter task_status --> number_of_tasks

        Args:
            stream: File-like object, Default: sys.stdout
        """
        stream = kwargs.pop("stream", sys.stdout)

        lines = ["%s, num_tasks=%s, all_ok=%s" % (str(self), self.num_tasks, self.all_ok)]
        for k, v in self.status_counter.items():
            lines.append("    %s: %s" % (k, v))
        lines.append("")

        stream.write("\n".join(lines))

    def show_status(self, **kwargs):
        """
        Report the status of the works and the status  of the different tasks on the specified stream.

        Args:
            stream: File-like object, Default: sys.stdout
            nids:  List of node identifiers. By defaults all nodes are shown
            wslice: Slice object used to select works.
            verbose: Verbosity level (default 0). > 0 to show only the works that are not finalized.
        """
        stream = kwargs.pop("stream", sys.stdout)
        nids = as_set(kwargs.pop("nids", None))
        wslice = kwargs.pop("wslice", None)
        wlist = None
        if wslice is not None:
            # Convert range to list of work indices.
            wlist = list(range(wslice.start, wslice.step, wslice.stop))
        verbose = kwargs.pop("verbose", 0)

        #has_colours = stream_has_colours(stream)
        has_colours = True
        red = "red" if has_colours else None

        for i, work in enumerate(self):
            print("", file=stream)
            cprint_map("Work #%d: %s, Finalized=%s" % (i, work, work.finalized), cmap={"True": "green"}, file=stream)
            if wlist is not None and i in wlist: continue
            if verbose == 0 and work.finalized: 
                print("  Finalized works are not shown. Use verbose > 0 to force output.", file=stream)
                continue

            table = PrettyTable(["Task", "Status", "Queue", "MPI|Omp|Mem[Gb]", 
                                 "Err|Warn|Com", "Class", "Rest|Sub|Corr", "Time", "Node_ID"])

            tot_num_errors = 0
            for task in work:
                if nids and task.node_id not in nids: continue
                task_name = os.path.basename(task.name)

                # FIXME: This should not be done here.
                # get_event_report should be called only in check_status
                # Parse the events in the main output.
                report = task.get_event_report()
                
                # Get time info (run-time or time in queue or None)
                stime = None
                timedelta = task.datetimes.get_runtime()
                if timedelta is not None:
                    stime = str(timedelta) + "R"
                else:
                    timedelta = task.datetimes.get_time_inqueue()
                    if timedelta is not None:
                        stime = str(timedelta) + "Q"

                events = "|".join(3*["NA"])
                if report is not None:
                    events = "|".join(map(str, [report.num_errors, report.num_warnings, report.num_comments]))

                para_info = "|".join(map(str, (task.mpi_procs, task.omp_threads, "%.1f" % task.mem_per_proc.to("Gb"))))
                task_info = list(map(str, [task.__class__.__name__, 
                                 (task.num_restarts, task.num_launches, task.num_corrections), stime, task.node_id]))

                qinfo = "None"
                if task.queue_id is not None:
                    qinfo = str(task.queue_id) + "@" + str(task.qname)

                if task.status.is_critical:
                    tot_num_errors += 1
                    task_name = colored(task_name, red)

                if has_colours:
                    table.add_row([task_name, task.status.colored, qinfo, para_info, events] + task_info)
                else:
                    table.add_row([task_name, str(task.status), qinfo, events, para_info] + task_info)

            # Print table and write colorized line with the total number of errors.
            print(table, file=stream)
            if tot_num_errors:
                cprint("Total number of errors: %d" % tot_num_errors, red, file=stream)
            print("", file=stream)

        if self.all_ok:
            print("\nall_ok reached\n", file=stream)

    def show_inputs(self, nids=None, wslice=None, stream=sys.stdout):
        """
        Print the input of the tasks to the given stream.

        Args:
            stream:
                File-like object, Default: sys.stdout
            nids: 
                List of node identifiers. By defaults all nodes are shown
            wslice: Slice object used to select works.
        """
        lines = []
        for task in self.select_tasks(nids=nids, wslice=wslice):
            s = task.make_input(with_header=True)

            # Add info on dependencies.
            if task.deps:
                s += "\n\nDependencies:\n" + "\n".join(str(dep) for dep in task.deps)
            else:
                s += "\n\nDependencies: None"

            lines.append(2*"\n" + 80 * "=" + "\n" + s + 2*"\n")

        stream.writelines(lines)

    def select_tasks(self, nids=None, wslice=None):
        """
        Return a list with a subset of tasks.

        Args:
            nids: List of node identifiers.
            wslice: Slice object used to select works.

        .. note::

            nids and wslice are mutually exclusive.
            If no argument is provided, the full list of tasks is returned.
        """
        if nids is not None:
            assert wslice is None
            tasks = self.tasks_from_nids(nids)

        elif wslice is not None:
            tasks = []
            for work in self[wslice]:
                tasks.extend([t for t in work])
        else:
            # All tasks selected if no option is provided.
            tasks = list(self.iflat_tasks())

        return tasks

    def inspect(self, nids=None, wslice=None, **kwargs):
        """
        Inspect the tasks (SCF iterations, Structural relaxation ...) and 
        produces matplotlib plots.

        Args:
            nids: List of node identifiers.
            wslice: Slice object used to select works.
            kwargs: keyword arguments passed to `task.inspect` method.

        .. note::

            nids and wslice are mutually exclusive. 
            If nids and wslice are both None, all tasks in self are inspected.

        Returns: 
            List of `matplotlib` figures.
        """
        figs = []
        for task in self.select_tasks(nids=nids, wslice=wslice):
            if hasattr(task, "inspect"):
                fig = task.inspect(**kwargs)
                if fig is None: 
                    cprint("Cannot inspect Task %s" % task, color="blue")
                else:
                    figs.append(fig)
            else:
                cprint("Task %s does not provide an inspect method" % task, color="blue")

        return figs

    def get_results(self, **kwargs):
        results = self.Results.from_node(self)
        results.update(self.get_dict_for_mongodb_queries())
        return results

    def get_dict_for_mongodb_queries(self):
        """
        This function returns a dictionary with the attributes that will be
        put in the mongodb document to facilitate the query.
        Subclasses may want to replace or extend the default behaviour.
        """
        d = {}
        return d
        # TODO
        all_structures = [task.strategy.structure for task in self.iflat_tasks()]
        all_pseudos = [task.strategy.pseudos for task in self.iflat_tasks()]

    def look_before_you_leap(self):
        """
        This method should be called before running the calculation to make
        sure that the most important requirements are satisfied.

        Return:
            List of strings with inconsistencies/errors.
        """
        errors = []

        try:
            self.check_dependencies()
        except self.Error as exc:
            errors.append(str(exc))

        if self.has_db:
            try:
                self.manager.db_connector.get_collection()
            except Exception as exc:
                errors.append("""
                    ERROR while trying to connect to the MongoDB database:
                        Exception:
                            %s
                        Connector:
                            %s
                    """ % (exc, self.manager.db_connector))

        return "\n".join(errors)

    @property
    def has_db(self):
        """True if flow uses `MongoDB` to store the results."""
        return self.manager.has_db

    def db_insert(self):
        """
        Insert results in the `MongDB` database.
        """
        assert self.has_db
        # Connect to MongoDb and get the collection.
        coll = self.manager.db_connector.get_collection()
        print("Mongodb collection %s with count %d", coll, coll.count())

        start = time.time()
        for work in self:
            for task in work:
                results = task.get_results()
                pprint(results)
                results.update_collection(coll)
            results = work.get_results()
            pprint(results)
            results.update_collection(coll)
        print("MongoDb update done in %s [s]" % time.time() - start)

        results = self.get_results()
        pprint(results)
        results.update_collection(coll)

        # Update the pickle file to save the mongo ids.
        self.pickle_dump()

        for d in coll.find():
            pprint(d)

    def tasks_from_nids(self, nids):
        """
        Return the list of tasks associated to the given list of node identifiers (nids).

        .. note::

            Invalid ids are ignored
        """
        if not isinstance(nids, collections.Iterable): nids = [nids]

        tasks = []
        for nid in nids:
            for task in self.iflat_tasks():
                if task.node_id == nid:
                    tasks.append(task)
                    break

        return tasks

    def wti_from_nids(self, nids):
        """Return the list of (w, t) indices from the list of node identifiers nids."""
        return [task.pos for task in self.tasks_from_nids(nids)]

    def open_files(self, what="o", status=None, op="==", nids=None, editor=None):
        """
        Open the files of the flow inside an editor (command line interface).

        Args:
            what: string with the list of characters selecting the file type
                  Possible choices:
                    i ==> input_file,
                    o ==> output_file,
                    f ==> files_file,
                    j ==> job_file,
                    l ==> log_file,
                    e ==> stderr_file,
                    q ==> qout_file,
            status: if not None, only the tasks with this status are select
            op: status operator. Requires status. A task is selected
                if task.status op status evaluates to true.
            nids: optional list of node identifiers used to filter the tasks.
            editor: Select the editor. None to use the default editor ($EDITOR shell env var)
        """
        def get_files(task):
            """Helper function used to select the files of a task."""
            choices = {
                "i": task.input_file,
                "o": task.output_file,
                "f": task.files_file,
                "j": task.job_file,
                "l": task.log_file,
                "e": task.stderr_file,
                "q": task.qout_file,
            }

            selected = []
            for c in what:
                try:
                    selected.append(getattr(choices[c], "path"))
                except KeyError:
                    warnings.warn("Wrong keyword %s" % c)

            return selected

        # Build list of files to analyze.
        files = []
        for task in self.iflat_tasks(status=status, op=op, nids=nids):
            lst = get_files(task)
            if lst:
                files.extend(lst)

        return Editor(editor=editor).edit_files(files)

    def show_abierrors(self, nids=None, stream=sys.stdout):
        """
        Write to the given stream the list of ABINIT errors for all tasks whose status is S_ABICRITICAL.

        Args:
            nids: optional list of node identifiers used to filter the tasks.
            stream: File-like object. Default: sys.stdout
        """
        lines = []
        app = lines.append

        for task in self.iflat_tasks(status=self.S_ABICRITICAL, nids=nids):
            header = "=== " + task.qout_file.path + "==="
            app(header)
            report = task.get_event_report()

            app("num_errors: %s, num_warnings: %s, num_comments: %s" % (
            report.num_errors, report.num_warnings, report.num_comments))

            app("*** ERRORS ***")
            app("\n".join(str(e) for e in report.errors))

            app("*** BUGS ***")
            app("\n".join(str(b) for e in report.bugs))

            lines.append("=" * len(header) + 2*"\n")

        return stream.writelines(lines)

    def show_qouts(self, nids=None, stream=sys.stdout):
        """
        Write to the given stream the content of the queue output file for all tasks whose status is S_QCRITICAL.

        Args:
            nids: optional list of node identifiers used to filter the tasks.
            stream: File-like object. Default: sys.stdout
        """
        lines = []

        for task in self.iflat_tasks(status=self.S_QCRITICAL, nids=nids):
            header = "=== " + task.qout_file.path + "==="
            lines.append(header)
            if task.qout_file.exists:
                with open(task.qout_file.path, "rt") as fh:
                    lines += fh.readlines()
            else:
                lines.append("File does not exist!")

            lines.append("=" * len(header) + 2*"\n")

        return stream.writelines(lines)

    def cancel(self, nids=None):
        """
        Cancel all the tasks that are in the queue.
        nids is an optional list of node identifiers used to filter the tasks.

        Returns:
            Number of jobs cancelled, negative value if error
        """
        if self.has_chrooted:
            # TODO: Use paramiko to kill the job?
            warnings.warn("Cannot cancel the flow via sshfs!")
            return -1

        # If we are running with the scheduler, we must send a SIGKILL signal.
        pid_file = os.path.join(self.workdir, "_PyFlowScheduler.pid")
        if os.path.exists(pid_file):
            with open(pid_file, "r") as fh:
                pid = int(fh.readline())

            retcode = os.system("kill -9 %d" % pid)
            flow.history.info("Sent SIGKILL to the scheduler, retcode = %s" % retcode)
            try:
                os.remove(pid_file)
            except IOError:
                pass

        num_cancelled = 0
        for task in self.iflat_tasks(nids=nids):
            num_cancelled += task.cancel()

        return num_cancelled

    def get_njobs_in_queue(self, username=None):
        """
        returns the number of jobs in the queue, None when the number of jobs cannot be determined.

        Args:
            username: (str) the username of the jobs to count (default is to autodetect)
        """
        return self.manager.qadapter.get_njobs_in_queue(username=username)

    def rmtree(self, ignore_errors=False, onerror=None):
        """Remove workdir (same API as shutil.rmtree)."""
        if not os.path.exists(self.workdir): return
        shutil.rmtree(self.workdir, ignore_errors=ignore_errors, onerror=onerror)

    def rm_and_build(self):
        """Remove the workdir and rebuild the flow."""
        self.rmtree()
        self.build()

    def build(self, *args, **kwargs):
        """Make directories and files of the `Flow`."""
        self.indir.makedirs()
        self.outdir.makedirs()
        self.tmpdir.makedirs()

        for work in self:
            work.build(*args, **kwargs)

    def build_and_pickle_dump(self):
        """
        Build dirs and file of the `Flow` and save the object in pickle format.
        Returns 0 if success
        """
        self.build()
        return self.pickle_dump()

    def pickle_dump(self):
        """
        Save the status of the object in pickle format.
        Returns 0 if success
        """
        if self.has_chrooted:
            warnings.warn("Cannot pickle_dump since we have chrooted from %s" % self.has_chrooted)
            return -1

        if self.in_spectator_mode:
            warnings.warn("Cannot pickle_dump since flow is in_spectator_mode")
            return -2

        protocol = self.pickle_protocol

        # Atomic transaction with FileLock.
        with FileLock(self.pickle_file):
            with AtomicFile(self.pickle_file, mode="wb") as fh:
                pmg_pickle_dump(self, fh, protocol=protocol)

        return 0

    def register_task(self, input, deps=None, manager=None, task_class=None):
        """
        Utility function that generates a `Work` made of a single task

        Args:
            input: :class:`AbinitInput` or :class:`Strategy` object.
            deps: List of :class:`Dependency` objects specifying the dependency of this node.
                  An empy list of deps implies that this node has no dependencies.
            manager: The :class:`TaskManager` responsible for the submission of the task.
                     If manager is None, we use the :class:`TaskManager` specified during the creation of the work.
            task_class: Task subclass to instantiate. Default: :class:`AbinitTask`

        Returns:
            The generated :class:`Work` for the task, work[0] is the actual task.
        """
        work = Work(manager=manager)
        task = work.register(input, deps=deps, task_class=task_class)
        self.register_work(work)

        return work

    def register_work(self, work, deps=None, manager=None, workdir=None):
        """
        Register a new :class:`Work` and add it to the internal list, taking into account possible dependencies.

        Args:
            work: :class:`Work` object.
            deps: List of :class:`Dependency` objects specifying the dependency of this node.
                  An empy list of deps implies that this node has no dependencies.
            manager: The :class:`TaskManager` responsible for the submission of the task.
                     If manager is None, we use the `TaskManager` specified during the creation of the work.
            workdir: The name of the directory used for the :class:`Work`.

        Returns:
            The registered :class:`Work`.
        """
        # Directory of the work.
        if workdir is None:
            work_workdir = os.path.join(self.workdir, "w" + str(len(self)))
        else:
            work_workdir = os.path.join(self.workdir, os.path.basename(workdir))

        work.set_workdir(work_workdir)

        if manager is not None:
            work.set_manager(manager)

        self.works.append(work)

        if deps:
            deps = [Dependency(node, exts) for node, exts in deps.items()]
            work.add_deps(deps)

        return work

    def register_work_from_cbk(self, cbk_name, cbk_data, deps, work_class, manager=None):
        """
        Registers a callback function that will generate the :class:`Task` of the :class:`Work`.

        Args:
            cbk_name: Name of the callback function (must be a bound method of self)
            cbk_data: Additional data passed to the callback function.
            deps: List of :class:`Dependency` objects specifying the dependency of the work.
            work_class: :class:`Work` class to instantiate.
            manager: The :class:`TaskManager` responsible for the submission of the task.
                    If manager is None, we use the `TaskManager` specified during the creation of the :class:`Flow`.

        Returns:
            The :class:`Work` that will be finalized by the callback.
        """
        # TODO: pass a Work factory instead of a class
        # Directory of the Work.
        work_workdir = os.path.join(self.workdir, "w" + str(len(self)))

        # Create an empty work and register the callback
        work = work_class(workdir=work_workdir, manager=manager)

        self._works.append(work)

        deps = [Dependency(node, exts) for node, exts in deps.items()]
        if not deps:
            raise ValueError("A callback must have deps!")

        work.add_deps(deps)

        # Wrap the callable in a Callback object and save
        # useful info such as the index of the work and the callback data.
        cbk = FlowCallback(cbk_name, self, deps=deps, cbk_data=cbk_data)
        self._callbacks.append(cbk)

        return work

    def allocate(self):
        """
        Allocate the `Flow` i.e. assign the `workdir` and (optionally)
        the :class:`TaskManager` to the different tasks in the Flow.
        """
        for work in self:
            # Each work has a reference to its flow.
            work.allocate(manager=self.manager)
            work.set_flow(self)
            # Each task has a reference to its work.
            for task in work:
                task.set_work(work)

        self.check_dependencies()

        return self

    def use_smartio(self):
        """
        This function should be called when the entire `Flow` has been built. 
        It tries to reduce the pressure on the hard disk by using Abinit smart-io 
        capabilities for those files that are not needed by other nodes.
        Smart-io means that big files (e.g. WFK) are written only if the calculation
        is unconverged so that we can restart from it. No output is produced if 
        convergence is achieved. 
        """
        for task in self.iflat_tasks():
            children = task.get_children()
            if not children:
                # Change the input so that output files are produced only if the 
                # calculation is not converged.
                #print("Will disable IO for task %s:" % task)
                # TODO: prtwf = -1 for DFPT
                task._set_inpvars(prtwf=-1, prtden=0) # prt1wf=-1, 
            else:
                must_produce_abiexts = []
                for child in children:
                    # Get the list of dependencies. Find that task 
                    for d in child.deps:
                        must_produce_abiexts.extend(d.exts)

                must_produce_abiexts = set(must_produce_abiexts)
                #print("must_produce_abiexts", must_produce_abiexts)

                # Variables supporting smart-io.
                smart_prtvars = {
                    "prtwf": "WFK",
                }

                # Set the variable to -1 to disable the output 
                for varname, abiext in smart_prtvars.items():
                    if abiext not in must_produce_abiexts:
                        print("%s: setting %s to -1" % (self, varname))
                        task._set_inpvars({varname: -1})

    #def new_from_input_decorators(self, new_workdir, decorators)
    #    """
    #    Return a new :class:`Flow` in which all the Abinit inputs have been
    #    decorated by decorators.
    #    """
    #    # The trick part here is how to assign a new id to the new nodes while maintaing the
    #    # correct dependencies! The safest approach would be to pass through __init__
    #    # instead of using copy.deepcopy()
    #    return flow

    def show_dependencies(self, stream=sys.stdout):
        """Writes to the given stream the ASCII representation of the dependency tree."""
        def child_iter(node):
            return [d.node for d in node.deps]

        def text_str(node):
            return colored(str(node), color=node.status.color_opts["color"])

        for task in self.iflat_tasks():
            print(draw_tree(task, child_iter, text_str), file=stream)

    def on_dep_ok(self, signal, sender):
        # TODO
        # Replace this callback with dynamic dispatch
        # on_all_S_OK for work
        # on_S_OK for task
        logger.info("on_dep_ok with sender %s, signal %s" % (str(sender), signal))

        for i, cbk in enumerate(self._callbacks):
            if not cbk.handle_sender(sender):
                logger.info("%s does not handle sender %s" % (cbk, sender))
                continue

            if not cbk.can_execute():
                logger.info("Cannot execute %s" % cbk)
                continue

            # Execute the callback and disable it
            self.history.info("flow in on_dep_ok: about to execute callback %s" % str(cbk))
            cbk()
            cbk.disable()

            # Update the database.
            self.pickle_dump()

    def finalize(self):
        """This method is called when the flow is completed."""
        if self.finalized: return 1
        self.finalized = False

        if self.has_db:
            self.history.info("Saving results in database.")
            try:
                self.flow.db_insert()
                self.finalized = True
            except Exception:
                 logger.critical("MongoDb insertion failed.")
                 return 2

        # Here we remove the big output files if we have the garbage collector 
        # and the policy is set to "flow."
        if self.gc is not None and self.gc.policy == "flow":
            self.history.info("gc.policy set to flow. Will clean task output files.")
            for task in self.iflat_tasks():
                task.clean_output_files()

    def set_garbage_collector(self, exts=None, policy="task"):
        """
        Enable the garbage collector that will remove the big output files that are not needed.

        Args:
            exts: string or list with the Abinit file extensions to be removed. A default is
                provided if exts is None
            policy: Either `flow` or `task`. If policy is set to 'task', we remove the output
                files as soon as the task reaches S_OK. If 'flow', the files are removed 
                only when the flow is finalized. This option should be used when we are dealing
                with a dynamic flow with callbacks generating other tasks since a :class:`Task`
                might not be aware of its children when it reached S_OK.
        """
        assert policy in ("task", "flow")
        exts = list_string(exts) if exts is not None else ("WFK", "SUS", "SCR")

        gc = GarbageCollector(exts=set(exts), policy=policy)

        self.set_gc(gc)
        for work in self:
            #work.set_gc(gc) # TODO Add support for Works and flow policy
            for task in work:
                task.set_gc(gc)

    def connect_signals(self):
        """
        Connect the signals within the `Flow`.
        The `Flow` is responsible for catching the important signals raised from its works.
        """
        # Connect the signals inside each Work.
        for work in self:
            work.connect_signals()

        # Observe the nodes that must reach S_OK in order to call the callbacks.
        for cbk in self._callbacks:
            for dep in cbk.deps:
                logger.info("connecting %s \nwith sender %s, signal %s" % (str(cbk), dep.node, dep.node.S_OK))
                dispatcher.connect(self.on_dep_ok, signal=dep.node.S_OK, sender=dep.node, weak=False)

        # Associate to each signal the callback _on_signal
        # (bound method of the node that will be called by `Flow`
        # Each node will set its attribute _done_signal to True to tell
        # the flow that this callback should be disabled.

        # Register the callbacks for the Work.
        #for work in self:
        #    slot = self._sig_slots[work]
        #    for signal in S_ALL:
        #        done_signal = getattr(work, "_done_ " + signal, False)
        #        if not done_sig:
        #            cbk_name = "_on_" + str(signal)
        #            cbk = getattr(work, cbk_name, None)
        #            if cbk is None: continue
        #            slot[work][signal].append(cbk)
        #            print("connecting %s\nwith sender %s, signal %s" % (str(cbk), dep.node, dep.node.S_OK))
        #            dispatcher.connect(self.on_dep_ok, signal=signal, sender=dep.node, weak=False)

        # Register the callbacks for the Tasks.

        #self.show_receivers()

    def show_receivers(self, sender=None, signal=None):
        sender = sender if sender is not None else dispatcher.Any
        signal = signal if signal is not None else dispatcher.Any
        print("*** live receivers ***")
        for rec in dispatcher.liveReceivers(dispatcher.getReceivers(sender, signal)):
            print("receiver -->", rec)
        print("*** end live receivers ***")
    
    def set_spectator_mode(self, mode=True):
        """
        When the flow is in spectator_mode we have to disable signals, pickle dump and possible callbacks
        A spectator can still operate on the flow but the new status of the flow won't be saved in 
        the pickle file. Usually the flow is in spectator mode when we are already running it via
        the scheduler or other means and we should not interfere with its evolution.
        This is the reason why signals and callbacks must be disabled.
        Unfortunately preventing client-code from calling methods with side-effects when
        the flow is in spectator mode is not easy (e.g. flow.cancel will cancel the tasks submitted to the
        queue and the flow used by the scheduler won't see this change!
        """
        mode = bool(mode)
        for work in self:
            for task in work:
                task.in_spectator_mode = mode

        if not mode:
            self.connect_signals()

        #if mode:
        #    flow.disable_signals()

    #def get_results(self, **kwargs)

    def rapidfire(self, check_status=False, **kwargs):
        """
        Use :class:`PyLauncher` to submits tasks in rapidfire mode.
        kwargs contains the options passed to the launcher.

        Return: 
            number of tasks submitted.
        """
        if check_status: self.check_status()
        from .launcher import PyLauncher
        return PyLauncher(self, **kwargs).rapidfire()

    def make_scheduler(self, **kwargs):
        """
        Build a return a :class:`PyFlowScheduler` to run the flow.

        Args:
            kwargs: if empty we use the user configuration file.
                    if `filepath` in kwargs we init the scheduler from filepath.
                    else pass **kwargs to :class:`PyFlowScheduler` __init__ method.
        """
        # Build dirs and files (if not yet done)
        self.build()

        from .launcher import PyFlowScheduler
        if not kwargs:
            # User config if kwargs is empty
            sched = PyFlowScheduler.from_user_config()
        else:
            # Use from_file if filepath if present, else call __init__
            filepath = kwargs.pop("filepath", None)
            if filepath is not None:
                assert not kwargs
                sched = PyFlowScheduler.from_file(filepath)
            else:
                sched = PyFlowScheduler.from_file(**kwargs)

        sched.add_flow(self)
        return sched

    def batch(self, **kwargs):
        """
        Run the flow in batch mode, return exit status of the job script.
        """
        from .launcher import BatchLauncher
        # Create a batch dir from the flow.workdir.
        prev_dir = os.path.join(*self.workdir.split(os.path.sep)[:-1])
        prev_dir = os.path.join(os.path.sep, prev_dir)
        workdir = os.path.join(prev_dir, os.path.basename(self.workdir) + "_batch")

        return BatchLauncher(workdir=workdir, flows=self).submit()

    def make_light_tarfile(self, name=None):
        """Lightweight tarball file. Mainly used for debugging. Return the name of the tarball file."""
        name = os.path.basename(self.workdir) + "-light.tar.gz" if name is None else name
        return self.make_tarfile(name=name, exclude_dirs=["outdata", "indata", "tmpdata"])

    def make_tarfile(self, name=None, max_filesize=None, exclude_exts=None, exclude_dirs=None, verbose=0, **kwargs):
        """
        Create a tarball file.

        Args:
            name: Name of the tarball file. Set to os.path.basename(`flow.workdir`) + "tar.gz"` if name is None.
            max_filesize (int or string with unit): a file is included in the tar file if its size <= max_filesize
                Can be specified in bytes e.g. `max_files=1024` or with a string with unit e.g. `max_filesize="1 Mb"`.
                No check is done if max_filesize is None.
            exclude_exts: List of file extensions to be excluded from the tar file.
            exclude_dirs: List of directory basenames to be excluded.
            verbose (int): Verbosity level.
            kwargs: keyword arguments passed to the :class:`TarFile` constructor.

        Returns:
            The name of the tarfile.
        """
        def any2bytes(s):
            """Convert string or number to memory in bytes."""
            if is_string(s):
                return int(Memory.from_string(s).to("b"))
            else:
                return int(s)

        if max_filesize is not None:
            max_filesize = any2bytes(max_filesize) 

        if exclude_exts:
            # Add/remove ".nc" so that we can simply pass "GSR" instead of "GSR.nc"
            # Moreover this trick allows one to treat WFK.nc and WFK file on the same footing.
            exts = []
            for e in list_strings(exclude_exts):
                exts.append(e)
                if e.endswith(".nc"):
                    exts.append(e.replace(".nc", ""))
                else:
                    exts.append(e + ".nc")
            exclude_exts = exts

        def filter(tarinfo):
            """
            Function that takes a TarInfo object argument and returns the changed TarInfo object. 
            If it instead returns None the TarInfo object will be excluded from the archive. 
            """
            # Skip links.
            if tarinfo.issym() or tarinfo.islnk():
                if verbose: print("Excluding link: %s" % tarinfo.name)
                return None

            # Check size in bytes
            if max_filesize is not None and tarinfo.size > max_filesize:
                if verbose: print("Excluding %s due to max_filesize" % tarinfo.name)
                return None

            # Filter filenames.
            if exclude_exts and any(tarinfo.name.endswith(ext) for ext in exclude_exts):
                if verbose: print("Excluding %s due to extension" % tarinfo.name)
                return None

            # Exlude directories (use dir basenames).
            if exclude_dirs and any(dir_name in exclude_dirs for dir_name in tarinfo.name.split(os.path.sep)):
                if verbose: print("Excluding %s due to exclude_dirs" % tarinfo.name)
                return None

            return tarinfo

        back = os.getcwd()
        os.chdir(os.path.join(self.workdir, ".."))

        import tarfile
        name = os.path.basename(self.workdir) + ".tar.gz" if name is None else name
        with tarfile.open(name=name, mode='w:gz', **kwargs) as tar:
            tar.add(os.path.basename(self.workdir), arcname=None, recursive=True, exclude=None, filter=filter)

            # Add the script used to generate the flow.
            if self.pyfile is not None and os.path.exists(self.pyfile):
                tar.add(self.pyfile)
        
        os.chdir(back)
        return name


class G0W0WithQptdmFlow(Flow):
    def __init__(self, workdir, scf_input, nscf_input, scr_input, sigma_inputs, manager=None):
        """
        Build a :class:`Flow` for one-shot G0W0 calculations.
        The computation of the q-points for the screening is parallelized with qptdm
        i.e. we run independent calculations for each q-point and then we merge the final results.

        Args:
            workdir: Working directory.
            scf_input: Input for the GS SCF run.
            nscf_input: Input for the NSCF run (band structure run).
            scr_input: Input for the SCR run.
            sigma_inputs: Input(s) for the SIGMA run(s).
            manager: :class:`TaskManager` object used to submit the jobs
                     Initialized from manager.yml if manager is None.
        """
        super(G0W0WithQptdmFlow, self).__init__(workdir, manager)

        # Register the first work (GS + NSCF calculation)
        bands_work = self.register_work(BandStructureWork(scf_input, nscf_input))

        # Register the callback that will be executed the work for the SCR with qptdm.
        scr_work = self.register_work_from_cbk(cbk_name="cbk_qptdm_workflow", cbk_data={"input": scr_input},
                                               deps={bands_work.nscf_task: "WFK"}, work_class=QptdmWork)

        # The last work contains a list of SIGMA tasks
        # that will use the data produced in the previous two works.
        if not isinstance(sigma_inputs, (list, tuple)):
            sigma_inputs = [sigma_inputs]

        sigma_work = Work()
        for sigma_input in sigma_inputs:
            sigma_work.register_sigma_task(sigma_input, deps={bands_work.nscf_task: "WFK", scr_work: "SCR"})
        self.register_work(sigma_work)

        self.allocate()

    def cbk_qptdm_workflow(self, cbk):
        """
        This callback is executed by the flow when bands_work.nscf_task reaches S_OK.

        It computes the list of q-points for the W(q,G,G'), creates nqpt tasks
        in the second work (QptdmWork), and connect the signals.
        """
        scr_input = cbk.data["input"]
        # Use the WFK file produced by the second
        # Task in the first Work (NSCF step).
        nscf_task = self[0][1]
        wfk_file = nscf_task.outdir.has_abiext("WFK")

        work = self[1]
        work.set_manager(self.manager)
        work.create_tasks(wfk_file, scr_input)
        work.add_deps(cbk.deps)

        work.set_flow(self)
        # Each task has a reference to its work.
        for task in work:
            task.set_work(work)
            # Add the garbage collector.
            if self.gc is not None: task.set_gc(self.gc)

        work.connect_signals()
        work.build()

        return work


class FlowCallbackError(Exception):
    """Exceptions raised by FlowCallback."""


class FlowCallback(object):
    """
    This object implements the callbacks executed by the :class:`flow` when
    particular conditions are fulfilled. See on_dep_ok method of :class:`Flow`.

    .. note::

        I decided to implement callbacks via this object instead of a standard
        approach based on bound methods because:

            1) pickle (v<=3) does not support the pickling/unplickling of bound methods

            2) There's some extra logic and extra data needed for the proper functioning
               of a callback at the flow level and this object provides an easy-to-use interface.
    """
    Error = FlowCallbackError

    def __init__(self, func_name, flow, deps, cbk_data):
        """
        Args:
            func_name: String with the name of the callback to execute.
                       func_name must be a bound method of flow with signature:

                            func_name(self, cbk)

                       where self is the Flow instance and cbk is the callback
            flow: Reference to the :class:`Flow`
            deps: List of dependencies associated to the callback
                  The callback is executed when all dependencies reach S_OK.
            cbk_data: Dictionary with additional data that will be passed to the callback via self.
        """
        self.func_name = func_name
        self.flow = flow
        self.deps = deps
        self.data = cbk_data or {}
        self._disabled = False

    def __str__(self):
        return "%s: %s bound to %s" % (self.__class__.__name__, self.func_name, self.flow)

    def __call__(self):
        """Execute the callback."""
        if self.can_execute():
            # Get the bound method of the flow from func_name.
            # We use this trick because pickle (format <=3) does not support bound methods.
            try:
                func = getattr(self.flow, self.func_name)
            except AttributeError as exc:
                raise self.Error(str(exc))

            return func(self)

        else:
            raise self.Error("You tried to __call_ a callback that cannot be executed!")

    def can_execute(self):
        """True if we can execute the callback."""
        return not self._disabled and all(dep.status == dep.node.S_OK for dep in self.deps)

    def disable(self):
        """
        True if the callback has been disabled.
        This usually happens when the callback has been executed.
        """
        self._disabled = True

    def handle_sender(self, sender):
        """
        True if the callback is associated to the sender
        i.e. if the node who sent the signal appears in the
        dependencies of the callback.
        """
        return sender in [d.node for d in self.deps]


# Factory functions.
def bandstructure_flow(workdir, scf_input, nscf_input, dos_inputs=None, manager=None, flow_class=Flow):
    """
    Build a :class:`Flow` for band structure calculations.

    Args:
        workdir: Working directory.
        scf_input: Input for the GS SCF run.
        nscf_input: Input for the NSCF run (band structure run).
        dos_inputs: Input(s) for the NSCF run (dos run).
        manager: :class:`TaskManager` object used to submit the jobs
                 Initialized from manager.yml if manager is None.
        flow_class: Flow subclass

    Returns:
        :class:`Flow` object
    """
    flow = flow_class(workdir, manager=manager)
    work = BandStructureWork(scf_input, nscf_input, dos_inputs=dos_inputs)
    flow.register_work(work)

    # Handy aliases
    flow.scf_task, flow.nscf_task, flow.dos_tasks = work.scf_task, work.nscf_task, work.dos_tasks

    return flow.allocate()


def g0w0_flow(workdir, scf_input, nscf_input, scr_input, sigma_inputs, manager=None, flow_class=Flow):
    """
    Build a :class:`Flow` for one-shot $G_0W_0$ calculations.

    Args:
        workdir: Working directory.
        scf_input: Input for the GS SCF run.
        nscf_input: Input for the NSCF run (band structure run).
        scr_input: Input for the SCR run.
        sigma_inputs: List of inputs for the SIGMA run.
        flow_class: Flow class
        manager: :class:`TaskManager` object used to submit the jobs.
                 Initialized from manager.yml if manager is None.

    Returns:
        :class:`Flow` object
    """
    flow = flow_class(workdir, manager=manager)
    work = G0W0Work(scf_input, nscf_input, scr_input, sigma_inputs)
    flow.register_work(work)
    return flow.allocate()


def phonon_flow(workdir, scf_input, ph_inputs, with_nscf=False, with_ddk=False, with_dde=False, 
                manager=None, flow_class=Flow):
    """
    Build a :class:`Flow` for phonon calculations.

    Args:
        workdir: Working directory.
        scf_input: Input for the GS SCF run.
        ph_inputs: List of Inputs for the phonon runs.
        with_nscf: add an nscf task in front of al phonon tasks to make sure the q point is covered
        with_ddk: add the ddk step
        with_dde: add the dde step it the dde is set ddk is switched on automatically
        manager: :class:`TaskManager` used to submit the jobs
                 Initialized from manager.yml if manager is None.
        flow_class: Flow class

    Returns:
        :class:`Flow` object
    """
    if with_dde:
        with_ddk = True

    natom = len(scf_input.structure)

    # Create the container that will manage the different works.
    flow = flow_class(workdir, manager=manager)

    # Register the first work (GS calculation)
    # register_task creates a work for the task, registers it to the flow and returns the work
    # the 0the element of the work is the task
    scf_task = flow.register_task(scf_input, task_class=ScfTask)[0]

    # Build a temporary work with a shell manager just to run
    # ABINIT to get the list of irreducible pertubations for this q-point.
    shell_manager = manager.to_shell_manager(mpi_procs=1)

    if with_ddk:
        logger.info('add ddk')
        ddk_input = ph_inputs[0].deepcopy()
        ddk_input.set_vars(qpt=[0, 0, 0], rfddk=1, rfelfd=2, rfdir=[1, 1, 1])
        ddk_task = flow.register_task(ddk_input, deps={scf_task: 'WFK'}, task_class=DdkTask)[0]

    if with_dde:
        logger.info('add dde')
        dde_input = ph_inputs[0].deepcopy()
        dde_input.set_vars(qpt=[0, 0, 0], rfddk=1, rfelfd=2)
        dde_input_idir = dde_input.deepcopy()
        dde_input_idir.set_vars(rfdir=[1, 1, 1])
        dde_task = flow.register_task(dde_input, deps={scf_task: 'WFK', ddk_task: 'DDK'}, task_class=DdeTask)[0]

    if not isinstance(ph_inputs, (list, tuple)):
        ph_inputs = [ph_inputs]

    for i, ph_input in enumerate(ph_inputs):

        fake_input = ph_input.deepcopy()

        # Run abinit on the front-end to get the list of irreducible pertubations.
        tmp_dir = os.path.join(workdir, "__ph_run" + str(i) + "__")
        w = PhononWork(workdir=tmp_dir, manager=shell_manager)
        fake_task = w.register(fake_input)

        # Use the magic value paral_rf = -1 to get the list of irreducible perturbations for this q-point.
        abivars = dict(
            paral_rf=-1,
            rfatpol=[1, natom],  # Set of atoms to displace.
            rfdir=[1, 1, 1],     # Along this set of reduced coordinate axis.
            )

        fake_task.strategy.add_extra_abivars(abivars)
        w.allocate()
        w.start(wait=True)

        # Parse the file to get the perturbations.
        irred_perts = yaml_read_irred_perts(fake_task.log_file.path)
        logger.info(irred_perts)

        w.rmtree()

        # Now we can build the final list of works:
        # One work per q-point, each work computes all 
        # the irreducible perturbations for a singe q-point.

        work_qpt = PhononWork()

        if with_nscf:
            nscf_input = copy.deepcopy(scf_input)
            nscf_input.set_vars(kptopt=3, iscf=-3, qpt=irred_perts[0]['qpt'], nqpt=1)
            nscf_task = work_qpt.register_nscf_task(nscf_input, deps={scf_task: "DEN"})
            deps = {nscf_task: "WFQ", scf_task: "WFK"}
        else:
            deps = {scf_task: "WFK"}

        if with_ddk:
            deps[ddk_task] = 'DDK'

        logger.info(irred_perts[0]['qpt'])

        for irred_pert in irred_perts:
            #print(irred_pert)
            new_input = ph_input.deepcopy()

            #rfatpol   1 1   # Only the first atom is displaced
            #rfdir   1 0 0   # Along the first reduced coordinate axis
            qpt = irred_pert["qpt"]
            idir = irred_pert["idir"]
            ipert = irred_pert["ipert"]

            # TODO this will work for phonons, but not for the other types of perturbations.
            rfdir = 3 * [0]
            rfdir[idir -1] = 1
            rfatpol = [ipert, ipert]

            new_input.set_vars(
                #rfpert=1,
                qpt=qpt,
                rfdir=rfdir,
                rfatpol=rfatpol,
            )

            if with_ddk:
                new_input.set_vars(rfelfd=3)

            work_qpt.register_phonon_task(new_input, deps=deps)

        flow.register_work(work_qpt)

        #if ana_input is not None:
        #    merge_input = {}
        #    qp_merge_task = flow.register_task(merge_input, deps={work_qpt: "DDB"}, task_class=QpMergeTask)
        #    flow.register_task(ana_input, deps={qp_merge_task: "DDB"}, task_class=AnaddbTask)
                                            
    return flow.allocate()
